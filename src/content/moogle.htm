<p>Moogle is a wireframe editor.</p>

<p>Moogle is a minimal <b>3D wireframe tool</b> designed to be used alongside its companion tool <a href='noodle.html'>Noodle</a>, both can export to the <a href='chr_format.html'>chr_format</a>. It offers a handful of basic geometry drawing functions, it was written in <a href='ansi_c.html'>ANSI C</a>, and was inspired by <a href='graf3dscene.html'>Graf3DScene</a>.</p>
<p>Moogle was first written on <a href='plan9.html'>Plan9</a>, the original <a href='plan9_c.html'>Plan9 C</a> implementation is available <a href='../src/inc/text/moogle9.c.txt' target='_blank'>here</a>.</p>
<h3>moogle.c</h3>
<p>To control the window size and default colors, edit the values defined at the top of the file itself. To learn more, visit the <a href='https://git.sr.ht/~rabbits/moogle' target='_blank'>repository</a>.</p>
<pre>cc -std=c89 -Wall moogle.c -L/usr/local/lib -lSDL2 -lm -o moogle</pre>
<p>The following code is a single-file implementation written in <a href='ansi_c.html'>ANSI C</a>, the only dependecy is <a href='https://www.libsdl.org' target='_blank'>SDL2</a>.</p>
<pre>#include &lt;SDL2/SDL.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;math.h&gt;<br /><br />/* <br />Copyright (c) 2020 Devine Lu Linvega<br /><br />Permission to use, copy, modify, and distribute this software for any<br />purpose with or without fee is hereby granted, provided that the above<br />copyright notice and this permission notice appear in all copies.<br /><br />THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES<br />WITH REGARD TO THIS SOFTWARE.<br />*/<br /><br />#define HOR 32<br />#define VER 16<br />#define PAD 8<br />#define SZ (HOR * VER * 16)<br /><br />#define VLIMIT 256<br />#define ELIMIT 512<br />#define MLIMIT 128<br />#define PI 3.14159265358979323846<br /><br />#define VIEWFRONT Pt3d(180, 0, 0)<br />#define VIEWTOP Pt3d(90, 0, 0)<br />#define VIEWSIDE Pt3d(90, 90, 0)<br /><br />typedef struct {<br />	double x, y;<br />} Point2d;<br /><br />typedef struct {<br />	double x, y, z;<br />} Point3d;<br /><br />typedef struct {<br />	int color;<br />	Point3d *a, *b;<br />} Edge;<br /><br />typedef struct {<br />	int verticeslen, edgeslen;<br />	Point3d position, vertices[VLIMIT];<br />	Edge edges[ELIMIT];<br />} Mesh;<br /><br />typedef struct {<br />	int len;<br />	Point3d position, scale, rotation;<br />	Mesh meshes[MLIMIT];<br />} Scene;<br /><br />typedef enum {<br />	ISOMETRIC,<br />	PERSPECTIVE<br />} Projection;<br /><br />typedef struct {<br />	double range;<br />	Point3d origin, rotation, torigin, trotation;<br />	Projection projection;<br />} Camera;<br /><br />int WIDTH = 8 * HOR + PAD * 2;<br />int HEIGHT = 8 * (VER + 2) + PAD * 2;<br />int FPS = 30, GUIDES = 1, ZOOM = 2;<br /><br />Scene scn;<br />Camera cam;<br /><br />/* interface */<br /><br />Uint32 theme[] = {<br />	0x000000,<br />	0xFFFFFF,<br />	0x72DEC2,<br />	0x666666,<br />	0x222222};<br /><br />Uint8 icons[][8] = {<br />	{0x10, 0x28, 0x44, 0x92, 0x44, 0x28, 0x10, 0x00},<br />	{0x10, 0x28, 0x44, 0x82, 0x82, 0x82, 0xd6, 0x00},<br />	{0x1e, 0x22, 0x40, 0x82, 0x40, 0x22, 0x1e, 0x00},<br />	{0x04, 0x08, 0x50, 0xa4, 0x50, 0x08, 0x04, 0x00},<br />	{0x1e, 0x20, 0x40, 0xa2, 0x40, 0x20, 0x1e, 0x00},<br />	{0x00, 0x00, 0x00, 0x82, 0x44, 0x38, 0x00, 0x00}, /* eye open */<br />	{0x00, 0x38, 0x44, 0x92, 0x28, 0x10, 0x00, 0x00}  /* eye closed */<br />};<br /><br />SDL_Window *gWindow = NULL;<br />SDL_Renderer *gRenderer = NULL;<br />SDL_Texture *gTexture = NULL;<br />Uint32 *pixels;<br /><br />/* helpers */<br /><br />Point2d<br />Pt2d(double x, double y)<br />{<br />	Point2d p;<br />	p.x = x;<br />	p.y = y;<br />	return p;<br />}<br /><br />Point3d *<br />set3d(Point3d *v, double x, double y, double z)<br />{<br />	v-&gt;x = x;<br />	v-&gt;y = y;<br />	v-&gt;z = z;<br />	return v;<br />}<br /><br />Point3d<br />Pt3d(double x, double y, double z)<br />{<br />	Point3d p;<br />	set3d(&amp;p, x, y, z);<br />	return p;<br />}<br /><br />Mesh<br />Ms3d(double x, double y, double z)<br />{<br />	Mesh m;<br />	set3d(&amp;m.position, x, y, z);<br />	m.verticeslen = 0;<br />	m.edgeslen = 0;<br />	return m;<br />}<br /><br />Scene<br />Sc3d(void)<br />{<br />	Scene s;<br />	s.len = 0;<br />	set3d(&amp;s.position, 0, 0, 0);<br />	set3d(&amp;s.scale, 1, 1, 1);<br />	set3d(&amp;s.rotation, 0, 0, 0);<br />	return s;<br />}<br /><br />Camera<br />Cm3d(double pitch, double yaw, double roll)<br />{<br />	Camera c;<br />	set3d(&amp;c.rotation, pitch, yaw, roll);<br />	set3d(&amp;c.trotation, pitch, yaw, roll);<br />	c.projection = PERSPECTIVE;<br />	c.range = 50;<br />	return c;<br />}<br /><br />int<br />colortheme(Uint32 hex)<br />{<br />	int i = 0;<br />	for(i = 0; i &lt; 5; ++i)<br />		if(theme[i] == hex)<br />			return i;<br />	return 0;<br />}<br /><br />/* geometry */<br /><br />double<br />interpolate(double a, double b, double speed, double range)<br />{<br />	if(a &lt; b - range || a &gt; b + range) {<br />		a += (b - a) / speed;<br />	} else<br />		a = b;<br />	return a;<br />}<br /><br />Point2d<br />rot2d(Point2d a, Point2d b, double deg)<br />{<br />	double radian = deg * (PI / 180);<br />	double angle = atan2(b.y - a.y, b.x - a.x) + radian;<br />	double r = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));<br />	return Pt2d(a.x + r * cos(angle), a.y + r * sin(angle));<br />}<br /><br />int<br />equpt3d(Point3d p0, Point3d p1)<br />{<br />	return p0.x == p1.x &amp;&amp; p0.y == p1.y &amp;&amp; p0.z == p1.z;<br />}<br /><br />Point3d *<br />addpt3d(Point3d *p, double x, double y, double z)<br />{<br />	return set3d(p, p-&gt;x + x, p-&gt;y + y, p-&gt;z + z);<br />}<br /><br />Point3d<br />add3d(Point3d *a, Point3d *b)<br />{<br />	return Pt3d(a-&gt;x + b-&gt;x, a-&gt;y + b-&gt;y, a-&gt;z + b-&gt;z);<br />}<br /><br />Point3d<br />mul3d(Point3d *a, Point3d *b)<br />{<br />	return Pt3d(a-&gt;x * b-&gt;x, a-&gt;y * b-&gt;y, a-&gt;z * b-&gt;z);<br />}<br /><br />/* scene */<br /><br />Point3d *<br />translate3d(Point3d *p, Point3d *t)<br />{<br />	*p = add3d(p, t);<br />	return p;<br />}<br /><br />Point3d *<br />scale3d(Point3d *p, Point3d *t)<br />{<br />	*p = mul3d(p, t);<br />	return p;<br />}<br /><br />Point3d *<br />rotate3d(Point3d *p, Point3d *o, Point3d *t)<br />{<br />	if(t-&gt;x) {<br />		Point2d r = rot2d(Pt2d(o-&gt;y, o-&gt;z), Pt2d(p-&gt;y, p-&gt;z), t-&gt;x);<br />		p-&gt;y = r.x;<br />		p-&gt;z = r.y;<br />	}<br />	if(t-&gt;y) {<br />		Point2d r = rot2d(Pt2d(o-&gt;x, o-&gt;z), Pt2d(p-&gt;x, p-&gt;z), t-&gt;y);<br />		p-&gt;x = r.x;<br />		p-&gt;z = r.y;<br />	}<br />	if(t-&gt;z) {<br />		Point2d r = rot2d(Pt2d(o-&gt;x, o-&gt;y), Pt2d(p-&gt;x, p-&gt;y), t-&gt;z);<br />		p-&gt;x = r.x;<br />		p-&gt;y = r.y;<br />	}<br />	return p;<br />}<br /><br />Scene *<br />moveto(Scene *s, double x, double y, double z)<br />{<br />	set3d(&amp;s-&gt;position, x, y, z);<br />	return s;<br />}<br /><br />Scene *<br />scaleto(Scene *s, double x, double y, double z)<br />{<br />	set3d(&amp;s-&gt;scale, x, y, z);<br />	return s;<br />}<br /><br />Scene *<br />rotateto(Scene *s, double x, double y, double z)<br />{<br />	set3d(&amp;s-&gt;rotation, x, y, z);<br />	return s;<br />}<br /><br />Scene *<br />reset(Scene *s)<br />{<br />	moveto(scaleto(rotateto(s, 0, 0, 0), 1, 1, 1), 0, 0, 0);<br />	return s;<br />}<br /><br />Point3d *<br />addvertex(Mesh *m, double x, double y, double z)<br />{<br />	int i;<br />	Point3d v = Pt3d(x, y, z);<br />	if(m-&gt;verticeslen == VLIMIT) {<br />		printf("Warning: Reached vertex limit\n");<br />		return NULL;<br />	}<br />	translate3d(&amp;v, &amp;scn.position);<br />	scale3d(&amp;v, &amp;scn.scale);<br />	rotate3d(&amp;v, &amp;scn.position, &amp;scn.rotation);<br />	for(i = 0; i &lt; m-&gt;verticeslen; ++i)<br />		if(equpt3d(m-&gt;vertices[i], v))<br />			return &amp;m-&gt;vertices[i];<br />	return set3d(&amp;m-&gt;vertices[m-&gt;verticeslen++], v.x, v.y, v.z);<br />}<br /><br />Edge *<br />addedge(Mesh *m, Point3d *a, Point3d *b, int color)<br />{<br />	if(m-&gt;edgeslen == ELIMIT) {<br />		printf("Warning: Reached edge limit\n");<br />		return NULL;<br />	}<br />	m-&gt;edges[m-&gt;edgeslen].a = a;<br />	m-&gt;edges[m-&gt;edgeslen].b = b;<br />	m-&gt;edges[m-&gt;edgeslen].color = color;<br />	return &amp;m-&gt;edges[m-&gt;edgeslen++];<br />}<br /><br />Mesh *<br />addmesh(Scene *s)<br />{<br />	if(s-&gt;len == MLIMIT) {<br />		printf("Warning: Reached mesh limit\n");<br />		return NULL;<br />	}<br />	return &amp;s-&gt;meshes[s-&gt;len++];<br />}<br /><br />/* transforms */<br /><br />Mesh *<br />translate(Mesh *m, double x, double y, double z)<br />{<br />	int i;<br />	Point3d t = Pt3d(x, y, z);<br />	for(i = 0; i &lt; m-&gt;verticeslen; i++)<br />		translate3d(&amp;m-&gt;vertices[i], &amp;t);<br />	return m;<br />}<br /><br />Mesh *<br />scale(Mesh *m, double x, double y, double z)<br />{<br />	int i;<br />	Point3d t = Pt3d(x, y, z);<br />	for(i = 0; i &lt; m-&gt;verticeslen; i++)<br />		scale3d(&amp;m-&gt;vertices[i], &amp;t);<br />	return m;<br />}<br /><br />Mesh *<br />rotate(Mesh *m, double pitch, double yaw, double roll)<br />{<br />	int i;<br />	Point3d t = Pt3d(pitch, yaw, roll);<br />	for(i = 0; i &lt; m-&gt;verticeslen; i++)<br />		rotate3d(&amp;m-&gt;vertices[i], &amp;m-&gt;position, &amp;t);<br />	return m;<br />}<br /><br />Mesh *<br />extrude(Mesh *m, Point3d t, int color)<br />{<br />	int i, j, vl = m-&gt;verticeslen, el = m-&gt;edgeslen;<br />	for(i = 0; i &lt; vl; i++) {<br />		Point3d *a = &amp;m-&gt;vertices[i];<br />		addedge(m, &amp;m-&gt;vertices[i], addvertex(m, a-&gt;x + t.x, a-&gt;y + t.y, a-&gt;z + t.z), color);<br />	}<br />	for(i = 0; i &lt; el; i++) {<br />		Edge *e0 = &amp;m-&gt;edges[i];<br />		Edge *e1 = addedge(m, e0-&gt;a, e0-&gt;b, e0-&gt;color);<br />		for(j = 0; j &lt; vl; j++) {<br />			if(e0-&gt;a == &amp;m-&gt;vertices[j])<br />				e1-&gt;a = &amp;m-&gt;vertices[vl + j];<br />			else if(e0-&gt;b == &amp;m-&gt;vertices[j])<br />				e1-&gt;b = &amp;m-&gt;vertices[vl + j];<br />		}<br />	}<br />	return m;<br />}<br /><br />/* Primitives */<br /><br />Mesh *<br />addpoly(Mesh *m, int a, int b, int c, int color)<br />{<br />	addedge(m, &amp;m-&gt;vertices[a], &amp;m-&gt;vertices[b], color);<br />	addedge(m, &amp;m-&gt;vertices[b], &amp;m-&gt;vertices[c], color);<br />	addedge(m, &amp;m-&gt;vertices[c], &amp;m-&gt;vertices[a], color);<br />	return m;<br />}<br /><br />Mesh *<br />addline(Mesh *m, Point3d a, Point3d b, int color)<br />{<br />	addedge(m, addvertex(m, a.x, a.y, a.z), addvertex(m, b.x, b.y, b.z), color);<br />	return m;<br />}<br /><br />Mesh *<br />addarc(Mesh *m, double radius, double segs, double angle, int color)<br />{<br />	int i;<br />	double arc = 2 * PI * angle / 360 / segs;<br />	Point3d b;<br />	for(i = 0; i &lt; segs + 1; i++) {<br />		Point3d a = Pt3d(radius * cos(i * arc), radius * sin(i * arc), 0);<br />		if(i &gt; 0)<br />			addline(m, a, b, color);<br />		b = a;<br />	}<br />	return m;<br />}<br /><br />Mesh *<br />addshape(Mesh *m, double radius, int segs, int color)<br />{<br />	return addarc(m, radius, segs, 360, color);<br />}<br /><br />/* Primitives */<br /><br />Mesh *<br />createfrustum(Scene *s, double radius, int segs, double depth, double cap, int color)<br />{<br />	int i;<br />	Mesh *m = addmesh(s);<br />	addshape(m, cap, segs, color);<br />	translate(m, 0, 0, depth);<br />	addshape(m, radius, segs, color);<br />	for(i = 0; i &lt; segs + 1; i++)<br />		addedge(m, &amp;m-&gt;vertices[i], &amp;m-&gt;vertices[segs + i + 1], color);<br />	return m;<br />}<br /><br />Mesh *<br />createpyramid(Scene *s, double radius, int segs, double depth, int color)<br />{<br />	int i;<br />	Mesh *m = addmesh(s);<br />	Point3d *p = addvertex(m, 0, 0, depth);<br />	addshape(m, radius, segs, color);<br />	for(i = 0; i &lt; segs + 1; i++)<br />		addedge(m, &amp;m-&gt;vertices[i], p, color);<br />	return m;<br />}<br /><br />Mesh *<br />createprism(Scene *s, double radius, int segs, double depth, int color)<br />{<br />	return createfrustum(s, radius, segs, depth, radius, color);<br />}<br /><br />Mesh *<br />createplane(Scene *s, double width, double height, double xsegs, double ysegs, int color)<br />{<br />	int ix, iy;<br />	Mesh *m = addmesh(s);<br />	for(ix = 0; ix &lt; xsegs + 1; ix++)<br />		addline(m,<br />			Pt3d(ix * (width / xsegs) - width / 2, height / 2, 0),<br />			Pt3d(ix * (width / xsegs) - width / 2, -height / 2, 0),<br />			color);<br />	for(iy = 0; iy &lt; ysegs + 1; iy++)<br />		addline(m,<br />			Pt3d(width / 2, iy * (height / ysegs) - height / 2, 0),<br />			Pt3d(-width / 2, iy * (height / ysegs) - height / 2, 0),<br />			color);<br />	return m;<br />}<br /><br />Mesh *<br />createbox(Scene *s, double width, double height, double depth, int color)<br />{<br />	int i;<br />	Mesh *m = createplane(s, width, height, 1, 1, color);<br />	extrude(m, Pt3d(0, 0, depth), color);<br />	return m;<br />}<br /><br />Mesh *<br />createicosaedron(Scene *s, double radius, int color)<br />{<br />	int i;<br />	Mesh *m = addmesh(s);<br />	double t = (1.0 + sqrt(5.0)) / 2.0;<br />	addvertex(m, -1, t, 0);<br />	addvertex(m, 1, t, 0);<br />	addvertex(m, -1, -t, 0);<br />	addvertex(m, 1, -t, 0);<br />	addvertex(m, 0, -1, t);<br />	addvertex(m, 0, 1, t);<br />	addvertex(m, 0, -1, -t);<br />	addvertex(m, 0, 1, -t);<br />	addvertex(m, t, 0, -1);<br />	addvertex(m, t, 0, 1);<br />	addvertex(m, -t, 0, -1);<br />	addvertex(m, -t, 0, 1);<br />	addpoly(m, 0, 11, 5, 3); /* - */<br />	addpoly(m, 0, 5, 1, 3);<br />	addpoly(m, 0, 1, 7, 3);<br />	addpoly(m, 0, 7, 10, 3);<br />	addpoly(m, 0, 10, 11, 3);<br />	addpoly(m, 1, 5, 9, 3); /* - */<br />	addpoly(m, 5, 11, 4, 3);<br />	addpoly(m, 11, 10, 2, 3);<br />	addpoly(m, 10, 7, 6, 3);<br />	addpoly(m, 7, 1, 8, 3);<br />	addpoly(m, 3, 9, 4, 3); /* - */<br />	addpoly(m, 3, 4, 2, 3);<br />	addpoly(m, 3, 2, 6, 3);<br />	addpoly(m, 3, 6, 8, 3);<br />	addpoly(m, 3, 8, 9, 3);<br />	addpoly(m, 4, 9, 5, 3); /* - */<br />	addpoly(m, 2, 4, 11, 3);<br />	addpoly(m, 6, 2, 10, 3);<br />	addpoly(m, 8, 6, 7, 3);<br />	addpoly(m, 9, 8, 1, 3);<br />	scale(m, radius / 2, radius / 2, radius / 2);<br />	return m;<br />}<br /><br />Mesh *<br />createumbrella(Scene *s)<br />{<br />	int i;<br />	Mesh *umbrella = addmesh(s);<br />	reset(s);<br />	for(i = 0; i &lt; 5; ++i) {<br />		addarc(umbrella, 10, 8, 180, 2);<br />		rotateto(s, 0, 45 * i, 0);<br />	}<br />	rotateto(s, 90, 0, 0);<br />	addshape(umbrella, 10, 8, 1);<br />	translate(scale(umbrella, 1, 0.6, 1), 0, 2, 0);<br />	addline(umbrella, Pt3d(0, 0, -10), Pt3d(0, 0, 8), 1);<br />	rotateto(moveto(s, 0, -8, 2), 90, 90, 90);<br />	addarc(umbrella, 2, 8, 180, 2);<br />	reset(s);<br />	return umbrella;<br />}<br /><br />/* draw */<br /><br />void<br />clear(Uint32 *dst)<br />{<br />	int i, j;<br />	for(i = 0; i &lt; HEIGHT; i++)<br />		for(j = 0; j &lt; WIDTH; j++)<br />			dst[i * WIDTH + j] = theme[0];<br />}<br /><br />int<br />getpixel(Uint32 *dst, int x, int y)<br />{<br />	return dst[(y + PAD) * WIDTH + (x + PAD)];<br />}<br /><br />void<br />putpixel(Uint32 *dst, int x, int y, int color)<br />{<br />	if(x &gt;= 0 &amp;&amp; x &lt; WIDTH - 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; HEIGHT - 8)<br />		dst[(y + PAD) * WIDTH + (x + PAD)] = theme[color];<br />}<br /><br />void<br />line(Uint32 *dst, Point2d p0, Point2d p1, int color)<br />{<br />	int p0x = (int)p0.x, p0y = (int)p0.y;<br />	int p1x = (int)p1.x, p1y = (int)p1.y;<br />	int dx = abs(p1x - p0x), sx = p0x &lt; p1x ? 1 : -1;<br />	int dy = -abs(p1y - p0y), sy = p0y &lt; p1y ? 1 : -1;<br />	int err = dx + dy, e2;<br />	for(;;) {<br />		putpixel(dst, p0x, p0y, color);<br />		if(p0x == p1x &amp;&amp; p0y == p1y)<br />			break;<br />		e2 = 2 * err;<br />		if(e2 &gt;= dy) {<br />			err += dy;<br />			p0x += sx;<br />		}<br />		if(e2 &lt;= dx) {<br />			err += dx;<br />			p0y += sy;<br />		}<br />	}<br />}<br /><br />void<br />drawicon(Uint32 *dst, int x, int y, Uint8 *icon, int color)<br />{<br />	int v, h;<br />	for(v = 0; v &lt; 8; v++)<br />		for(h = 0; h &lt; 8; h++) {<br />			int c = (icon[v] &gt;&gt; (8 - h)) &amp; 0x1;<br />			putpixel(dst, x + h, y + v, c ? color : 0);<br />		}<br />}<br /><br />void<br />drawui(Uint32 *dst)<br />{<br />	int bottom = VER * 8 + 8;<br />	drawicon(dst, 0 * 8, bottom, icons[0], equpt3d(cam.rotation, VIEWFRONT) ? 1 : 2);<br />	drawicon(dst, 1 * 8, bottom, icons[1], equpt3d(cam.rotation, VIEWTOP) ? 1 : 2);<br />	drawicon(dst, 2 * 8, bottom, icons[2], equpt3d(cam.rotation, VIEWSIDE) ? 1 : 2);<br />	drawicon(dst, 4 * 8, bottom, icons[cam.projection == ISOMETRIC ? 4 : 3], 1);<br />	drawicon(dst, 5 * 8, bottom, icons[GUIDES ? 6 : 5], GUIDES ? 1 : 2);<br />}<br /><br />Point2d<br />project(Camera *c, Point3d v)<br />{<br />	double r;<br />	if(c-&gt;projection == ISOMETRIC)<br />		return Pt2d(<br />			(WIDTH / 2) + v.x * (10 - c-&gt;range / 10),<br />			(HEIGHT / 2) + v.y * (10 - c-&gt;range / 10));<br />	r = 200 / (v.z + c-&gt;range);<br />	return Pt2d(WIDTH / 2 + r * v.x, HEIGHT / 2 + r * v.y);<br />}<br /><br />void<br />redraw(Uint32 *dst)<br />{<br />	int i, j;<br />	clear(dst);<br />	for(i = 0; i &lt; scn.len; i++) {<br />		Mesh *m = &amp;scn.meshes[i];<br />		for(j = 0; j &lt; m-&gt;edgeslen; j++) {<br />			Edge *edge = &amp;m-&gt;edges[j];<br />			Point3d a = add3d(edge-&gt;a, &amp;m-&gt;position);<br />			Point3d b = add3d(edge-&gt;b, &amp;m-&gt;position);<br />			rotate3d(&amp;a, &amp;cam.origin, &amp;cam.rotation);<br />			rotate3d(&amp;b, &amp;cam.origin, &amp;cam.rotation);<br />			line(dst,<br />				project(&amp;cam, add3d(&amp;cam.origin, &amp;a)),<br />				project(&amp;cam, add3d(&amp;cam.origin, &amp;b)),<br />				edge-&gt;color);<br />		}<br />	}<br />	drawui(dst);<br />	SDL_UpdateTexture(gTexture, NULL, dst, WIDTH * sizeof(Uint32));<br />	SDL_RenderClear(gRenderer);<br />	SDL_RenderCopy(gRenderer, gTexture, NULL, NULL);<br />	SDL_RenderPresent(gRenderer);<br />}<br /><br />/* options */<br /><br />int<br />error(char *msg, const char *err)<br />{<br />	printf("Error %s: %s\n", msg, err);<br />	return 0;<br />}<br /><br />void<br />update(Camera *c, double speed)<br />{<br />	if(!equpt3d(c-&gt;rotation, c-&gt;trotation) || !equpt3d(c-&gt;origin, c-&gt;torigin)) {<br />		set3d(&amp;c-&gt;rotation,<br />			interpolate(c-&gt;rotation.x, c-&gt;trotation.x, speed, 1),<br />			interpolate(c-&gt;rotation.y, c-&gt;trotation.y, speed, 1),<br />			interpolate(c-&gt;rotation.z, c-&gt;trotation.z, speed, 1));<br />		set3d(&amp;c-&gt;origin,<br />			interpolate(c-&gt;origin.x, c-&gt;torigin.x, speed, 1),<br />			interpolate(c-&gt;origin.y, c-&gt;torigin.y, speed, 1),<br />			interpolate(c-&gt;origin.z, c-&gt;torigin.z, speed, 1));<br />		redraw(pixels);<br />	}<br />}<br /><br />void<br />modzoom(int mod)<br />{<br />	if((mod &gt; 0 &amp;&amp; ZOOM &lt; 4) || (mod &lt; 0 &amp;&amp; ZOOM &gt; 1))<br />		ZOOM += mod;<br />	SDL_SetWindowSize(gWindow, WIDTH * ZOOM, HEIGHT * ZOOM);<br />	redraw(pixels);<br />}<br /><br />void<br />toggleprojection(Camera *c)<br />{<br />	c-&gt;projection = c-&gt;projection == ISOMETRIC ? PERSPECTIVE : ISOMETRIC;<br />	redraw(pixels);<br />}<br /><br />void<br />setguides(int v)<br />{<br />	GUIDES = v;<br />	redraw(pixels);<br />}<br /><br />void<br />modrange(int mod)<br />{<br />	int res = cam.range + mod;<br />	if(res &gt; 0 &amp;&amp; res &lt; 90)<br />		cam.range = res;<br />	redraw(pixels);<br />}<br /><br />void<br />selectoption(int option)<br />{<br />	switch(option) {<br />	case 0: set3d(&amp;cam.trotation, VIEWFRONT.x, VIEWFRONT.y, VIEWFRONT.z); break;<br />	case 1: set3d(&amp;cam.trotation, VIEWTOP.x, VIEWTOP.y, VIEWTOP.z); break;<br />	case 2: set3d(&amp;cam.trotation, VIEWSIDE.x, VIEWSIDE.y, VIEWSIDE.z); break;<br />	case 4: toggleprojection(&amp;cam); break;<br />	case 5: setguides(!GUIDES); break;<br />	}<br />}<br /><br />void<br />putchr(Uint8 *chrbuf, int row, int col, int color)<br />{<br />	if(row &lt; 0 || row &gt; SZ - 8)<br />		return;<br />	if(color == 0 || color == 2)<br />		chrbuf[row] &amp;= ~(1UL &lt;&lt; (7 - col));<br />	else<br />		chrbuf[row] |= 1UL &lt;&lt; (7 - col);<br />	if(color == 0 || color == 1)<br />		chrbuf[row + 8] &amp;= ~(1UL &lt;&lt; (7 - col));<br />	else<br />		chrbuf[row + 8] |= 1UL &lt;&lt; (7 - col);<br />}<br /><br />void<br />exportchr(void)<br />{<br />	int h, v, x, y;<br />	Uint8 chrbuf[SZ];<br />	FILE *f = fopen("moogle-export.chr", "wb");<br />	setguides(0);<br />	for(v = 0; v &lt; VER; ++v)<br />		for(h = 0; h &lt; HOR; ++h)<br />			for(y = 0; y &lt; 8; ++y)<br />				for(x = 0; x &lt; 8; ++x) {<br />					int row = y + (h + v * HOR) * 16;<br />					int col = x;<br />					int clr = pixels[(v * 8 + y + PAD) * WIDTH + (h * 8 + x + PAD)];<br />					putchr(chrbuf, row, col, colortheme(clr));<br />				}<br />	if(!fwrite(chrbuf, sizeof(chrbuf), 1, f))<br />		error("Save", "Invalid output file");<br />	fclose(f);<br />	puts("Exported moogle-export.chr");<br />}<br /><br />void<br />renderbmp(void)<br />{<br />	SDL_Surface *surface = SDL_GetWindowSurface(gWindow);<br />	setguides(0);<br />	SDL_RenderReadPixels(gRenderer,<br />		NULL,<br />		SDL_PIXELFORMAT_ARGB8888,<br />		surface-&gt;pixels,<br />		surface-&gt;pitch);<br />	if(SDL_SaveBMP(surface, "moogle-render.bmp"))<br />		printf("SDL_SaveBMP failed: %s\n", SDL_GetError());<br />	else<br />		puts("Rendered moogle-render.bmp");<br />	SDL_FreeSurface(surface);<br />}<br /><br />void<br />quit(void)<br />{<br />	free(pixels);<br />	SDL_DestroyTexture(gTexture);<br />	gTexture = NULL;<br />	SDL_DestroyRenderer(gRenderer);<br />	gRenderer = NULL;<br />	SDL_DestroyWindow(gWindow);<br />	gWindow = NULL;<br />	SDL_Quit();<br />	exit(0);<br />}<br /><br />void<br />domouse(SDL_Event *event)<br />{<br />	switch(event-&gt;type) {<br />	case SDL_MOUSEBUTTONUP:<br />		break;<br />	case SDL_MOUSEBUTTONDOWN:<br />		if(event-&gt;motion.y / ZOOM / 8 == VER + 2)<br />			selectoption(event-&gt;motion.x / ZOOM / 8 - 1);<br />		break;<br />	case SDL_MOUSEMOTION:<br />		break;<br />	}<br />}<br /><br />void<br />dokey(SDL_Event *event)<br />{<br />	int shift = SDL_GetModState() &amp; KMOD_LSHIFT || SDL_GetModState() &amp; KMOD_RSHIFT;<br />	switch(event-&gt;key.keysym.sym) {<br />	case SDLK_EQUALS:<br />	case SDLK_PLUS: modzoom(1); break;<br />	case SDLK_UNDERSCORE:<br />	case SDLK_MINUS: modzoom(-1); break;<br />	case SDLK_TAB: toggleprojection(&amp;cam); break;<br />	case SDLK_1: set3d(&amp;cam.trotation, VIEWFRONT.x, VIEWFRONT.y, VIEWFRONT.z); break;<br />	case SDLK_2: set3d(&amp;cam.trotation, VIEWTOP.x, VIEWTOP.y, VIEWTOP.z); break;<br />	case SDLK_3: set3d(&amp;cam.trotation, VIEWSIDE.x, VIEWSIDE.y, VIEWSIDE.z); break;<br />	case SDLK_e: exportchr(); break;<br />	case SDLK_r: renderbmp(); break;<br />	case SDLK_h: setguides(!GUIDES); break;<br />	case SDLK_UP:<br />	case SDLK_w:<br />		if(shift)<br />			addpt3d(&amp;cam.torigin, 0, 2.5, 0);<br />		else<br />			addpt3d(&amp;cam.trotation, 5, 0, 0);<br />		break;<br />	case SDLK_LEFT:<br />	case SDLK_a:<br />		if(shift)<br />			addpt3d(&amp;cam.torigin, 2.5, 0, 0);<br />		else<br />			addpt3d(&amp;cam.trotation, 0, -5, 0);<br />		break;<br />	case SDLK_DOWN:<br />	case SDLK_s:<br />		if(shift)<br />			addpt3d(&amp;cam.torigin, 0, -2.5, 0);<br />		else<br />			addpt3d(&amp;cam.trotation, -5, 0, 0);<br />		break;<br />	case SDLK_RIGHT:<br />	case SDLK_d:<br />		if(shift)<br />			addpt3d(&amp;cam.torigin, -2.5, 0, 0);<br />		else<br />			addpt3d(&amp;cam.trotation, 0, 3.0, 0);<br />		break;<br />	case SDLK_f:<br />		set3d(&amp;cam.torigin, 0, 0, 0);<br />		set3d(&amp;cam.trotation, VIEWFRONT.x, VIEWFRONT.y, VIEWFRONT.z);<br />		break;<br />	case SDLK_z:<br />		if(shift)<br />			addpt3d(&amp;cam.torigin, 0, 0, 2.5);<br />		else<br />			modrange(3.0);<br />		break;<br />	case SDLK_x:<br />		if(shift)<br />			addpt3d(&amp;cam.torigin, 0, 0, -2.5);<br />		else<br />			modrange(-3.0);<br />		break;<br />	}<br />	redraw(pixels);<br />}<br /><br />int<br />init(void)<br />{<br />	if(SDL_Init(SDL_INIT_VIDEO) &lt; 0)<br />		return error("Init", SDL_GetError());<br />	gWindow = SDL_CreateWindow("Moogle",<br />		SDL_WINDOWPOS_UNDEFINED,<br />		SDL_WINDOWPOS_UNDEFINED,<br />		WIDTH * ZOOM,<br />		HEIGHT * ZOOM,<br />		SDL_WINDOW_SHOWN);<br />	if(gWindow == NULL)<br />		return error("Window", SDL_GetError());<br />	gRenderer = SDL_CreateRenderer(gWindow, -1, 0);<br />	if(gRenderer == NULL)<br />		return error("Renderer", SDL_GetError());<br />	gTexture = SDL_CreateTexture(gRenderer,<br />		SDL_PIXELFORMAT_ARGB8888,<br />		SDL_TEXTUREACCESS_STATIC,<br />		WIDTH,<br />		HEIGHT);<br />	if(gTexture == NULL)<br />		return error("Texture", SDL_GetError());<br />	pixels = (Uint32 *)malloc(WIDTH * HEIGHT * sizeof(Uint32));<br />	if(pixels == NULL)<br />		return error("Pixels", "Failed to allocate memory");<br />	clear(pixels);<br />	return 1;<br />}<br /><br />int<br />main(void)<br />{<br />	int ticknext = 0;<br />	scn = Sc3d();<br />	cam = Cm3d(180, 20, 0);<br />	if(!init())<br />		return error("Init", "Failure");<br />	createumbrella(&amp;scn);<br />	redraw(pixels);<br />	while(1) {<br />		int tick = SDL_GetTicks();<br />		SDL_Event event;<br />		if(tick &lt; ticknext)<br />			SDL_Delay(ticknext - tick);<br />		ticknext = tick + (1000 / FPS);<br />		update(&amp;cam, 5);<br />		while(SDL_PollEvent(&amp;event) != 0) {<br />			if(event.type == SDL_QUIT)<br />				quit();<br />			else if(event.type == SDL_MOUSEBUTTONUP ||<br />					event.type == SDL_MOUSEBUTTONDOWN ||<br />					event.type == SDL_MOUSEMOTION)<br />				domouse(&amp;event);<br />			else if(event.type == SDL_KEYDOWN)<br />				dokey(&amp;event);<br />			else if(event.type == SDL_WINDOWEVENT)<br />				if(event.window.event == SDL_WINDOWEVENT_EXPOSED)<br />					redraw(pixels);<br />		}<br />	}<br />	quit();<br />	return 0;<br />}<br /></pre>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/moogle' target='_blank'>source</a></li>
</ul>

