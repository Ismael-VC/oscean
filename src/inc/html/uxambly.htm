<h2>Opcodes</h2>

<p>There are 32 opcodes, each opcode occupies 5 bits of a byte, the remaining 3 are used to select modes of that opcode, modes are explained below.</p>

<table border="1">
	<tr><td colspan="3">mode</td><td colspan="5">opcode</td></tr>
	<tr><td><i>nil</i></td><td>return<code>[r]</code></td><td>short<code>[2]</code></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>

<p>Operator modes are indicated by appending extra characters at the end of the opcode, for example, the <i>short mode</i> for the <code>ADD</code> opcode is <code>ADD2</code>, modes can also be combined, for example: <code>ADD2r</code>.</p>

<table border="1" width="700">
	<tr><td></td><th colspan="3">Stack</th><td></td>                                           <th colspan="3">Memory</th></tr>
	<tr><th>0x00</th><td><code class='op'>BRK</code> Break</td><td></td><td></td>              <th>0x10</th><td><code class='op'>PEK</code> Load(zero-page)</td><td>a</td><td>[b]</td></tr>
	<tr><th>0x01</th><td><code class='op'>LIT</code> Literal</td><td>++</td><td></td>          <th>0x11</th><td><code class='op'>POK</code> Save(zero-page)</td><td>b a</td><td></td></tr>
	<tr><th>0x02</th><td><code class='op'>---</code> </td><td></td><td></td>                   <th>0x12</th><td><code class='op'>GET</code> Load(absolute)</td><td>a*</td><td>[b]</td></tr>
	<tr><th>0x03</th><td><code class='op'>POP</code> Pop</td><td>a</td><td></td>               <th>0x13</th><td><code class='op'>PUT</code> Save(absolute)</td><td>[b] a*</td><td></td></tr>
	<tr><th>0x04</th><td><code class='op'>DUP</code> Duplicate</td><td>a</td><td>a a</td>      <th>0x14</th><td><code class='op'>---</code> </td><td></td><td></td></tr>
	<tr><th>0x05</th><td><code class='op'>SWP</code> Swap</td><td>a b</td><td>b a</td>         <th>0x15</th><td><code class='op'>---</code> </td><td></td><td></td></tr>
	<tr><th>0x06</th><td><code class='op'>OVR</code> Over</td><td>a b</td><td>a b a</td>       <th>0x16</th><td><code class='op'>DEI</code> Device In</td><td>a</td><td>[b]</td></tr>
	<tr><th>0x07</th><td><code class='op'>ROT</code> Rotate</td><td>a b c</td><td>b c a</td>   <th>0x17</th><td><code class='op'>DEO</code> Device Out</td><td>[b] a</td><td></td></tr>
	<tr><td></td><th colspan="3">Logic</th><td></td>                                           <th colspan="3">Arithmetic</th></tr>
	<tr><th>0x08</th><td><code class='op'>EQU</code> Equal</td><td>a b</td><td>c</td>          <th>0x18</th><td><code class='op'>ADD</code> Add</td><td>a b</td><td>c</td></tr>
	<tr><th>0x09</th><td><code class='op'>NEQ</code> NotEqual</td><td>a b</td><td>c</td>       <th>0x19</th><td><code class='op'>SUB</code> Subtract</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0a</th><td><code class='op'>GTH</code> GreaterThan</td><td>a b</td><td>c</td>    <th>0x1a</th><td><code class='op'>MUL</code> Multiply</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0b</th><td><code class='op'>LTH</code> LesserThan</td><td>a b</td><td>c</td>     <th>0x1b</th><td><code class='op'>DIV</code> Divide</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0c</th><td><code class='op'>JMP</code> Jump</td><td>[a]</td><td></td>            <th>0x1c</th><td><code class='op'>AND</code> And</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0d</th><td><code class='op'>JNZ</code> JumpCond</td><td>a [b]</td><td></td>      <th>0x1d</th><td><code class='op'>ORA</code> Or</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0e</th><td><code class='op'>JSR</code> JumpStash</td><td>[a]</td><td>rs</td>     <th>0x1e</th><td><code class='op'>EOR</code> ExclusiveOr</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0f</th><td><code class='op'>STH</code> Stash</td><td>a</td><td>rs</td>           <th>0x1f</th><td><code class='op'>SFT</code> Shift</td><td>a b</td><td>c</td></tr>
</table>

<p>The <b>short mode</b> allows for each operator to do 16-bits operations by pushing and popping the necessary extra items from the stack. In the case of jump opcodes(<code>JMP2</code>, <code>JSR2</code>, and <code>JNZ2</code>) the short mode operation jumps to an absolute address in memory. For the getters and setters(<code>PEK2</code>, <code>POK2</code>, <code>GET2</code> and <code>PUT2</code>) the short mode operation indicates the size of the data to read/write.</p>

<p>The <b>return mode</b> makes it possible for any operator to operate on the return-stack directly, for that reason there is no dedicated return opcode. For example, the JumpStash(<code>JSR</code>) operator pushes the program&#39;s address onto the return stash before jumping, to return to that address, the <code>JMP2r</code> opcode is used, where instead of using the address on the working-stack, it takes its address directly from the return-stack.</p>

<img src="../media/generic/uxn.team.png" width="250" style="margin:0 auto 30px">

<h2>Programming</h2>

<p>Uxambly has no reserved words besides the 32 opcodes, each element of the program has its own rune. Comments are within parentheses, the curlies are used in the definition of macros, and the square brackets are ignored.</p>

<table border="1">
	<tr><th colspan="4">Runes</th></tr>
	<tr><td><code>%</code></td><td>macro-define</td>    <td><code>#</code></td><td>literal hex</td></tr>
	<tr><td><code>|</code></td><td>pad(absolute)</td>    <td><code>.</code></td><td>literal addr(zero-page)</td></tr>
	<tr><td><code>$</code></td><td>pad(relative)</td>    <td><code>,</code></td><td>literal addr(relative)</td></tr>
	<tr><td><code>@</code></td><td>label-define</td>    <td><code>;</code></td><td>literal addr(absolute)</td></tr>
	<tr><td><code>&amp;</code></td><td>sublabel-define</td> <td><code>:</code></td><td>raw addr</td></tr>
	<tr><td><code>/</code></td><td>sublabel spacer</td> <td><code>&#39;</code></td><td>raw char</td></tr>
	<tr><td></td><td></td><td><code>&quot;</code></td><td>raw word</td></tr>
</table>

<h3>Example</h3>
<p>In the following example, our program begins with <code>;hello-world</code> pushing the address of the <code>@hello-world</code> label to the top of the stack, followed by <code>;print</code> which pushes its address on top of that first label. Each address is 2 bytes long, and so our stack contains 4 bytes before the <code>JSR2</code> opcode.</p>

<p>Next, <code>JSR2</code> consumes the address(or, two bytes) at the top of the stack and so we move to the subroutine <code>@print</code>, leaving the address of the <code>@hello-world</code> label on the stack. The first thing that happens is <code>DUP2 GET</code> copies it, and reads the value of the byte at that address, then we send it to the console device. We increment the value of the label, and start over until we reach the end of the text by hitting a byte that is equal to 0.</p>

<pre style='clear:both'>
( dev/console )

%RTN { JMP2r }

( devices )

|10 @Console    [ &pad $8 &char $1 ]

( init )

|0100 ( -> )
	
	;hello-word ,print JSR
	
BRK

@print ( addr* -- )
	
	&loop
		( send ) DUP2 GET .Console/char DEO
		( incr ) #0001 ADD2
		( loop ) DUP2 GET #00 NEQ ,&loop JNZ
	POP2

RTN

@hello-word "hello 20 "World!
</pre>

<h2>Addressing</h2>

<p>The memory and stacks contains 8-bits values, to differentiate operations from literal numbers, the <code>LIT</code> opcode will push the following byte from memory onto the stack, the 16-bits mode <code>LIT2</code> opcode will push the following short.</p>

<p><b>Immediate</b>, or literal, addressing allows to directly specify a byte or short constant. <b>Deferred</b> addressing is a form of immediate addressing where the address of a label is put on the stack.</p>

<table border="1">
	<tr><th></th><th colspan="2">Byte</th><th colspan="2">Short</th></tr>
	<tr><td><i>Immediate</i></td><td colspan="2"><code>#ab</code></td><td colspan="2"><code>#cdef</code></td></tr>
	<tr><td rowspan="2"><i>Deferred</i></td><th>Zero-page</th><th>Relative</th><th colspan="2">Absolute</th></tr>
	<tr><td><code>.label</code></td><td><code>,label</code></td><td colspan="2"><code>;label</code></td></tr>
	<tr><td rowspan="2"><i>Raw</i></td><th>Byte</th><th>Char</th><th>Short</th><th>Absolute</th></tr>
	<tr><td><code>ab</code></td><td><code>'Q</code></td><td><code>cdef</code></td><td><code>:label</code></td></tr>
</table>

<h2>Control flow</h2>

<p>Uxambly allows for basic control flow, here are some of them:</p>

<table border="1">
	<tr><th>ForLoop</th><th>WhileLoop</th><th>Switch</th></tr>
	<tr>
		<td>
<pre>
#00 #0d
&amp;loop
	( body ) 
	SWP #01 ADD SWP
	DUP2 LTH ,&amp;loop JNZ
POP2
</pre>
		</td>
		<td>
<pre>
#00 #0d
&amp;while
	( body )
	DUP2 EQU ,&amp;end JNZ
	SWP #01 ADD SWP
,&amp;while JMP &amp;end
POP2
</pre>
		</td>
		<td>
<pre>
#02 
DUP #01 NEQ ,&amp;b JNZ
	( a ) 
&amp;b DUP #02 NEQ ,&amp;c JNZ
	( b ) 
&amp;c DUP #03 NEQ ,&amp;default JNZ
	( c ) 
&amp;default
POP
</pre>
		</td>
	</tr>

</table>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:black; }
.clr3 { background:#ff0000; color:black; }
code.op { background: #ddd; color: black; font-size: smaller; display: inline-block; padding: 0px 2px; margin-right: 3px; }
pre span.comment { color:#666; }
</style>

<img src="../media/identity/uxn64.png">