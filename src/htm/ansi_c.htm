<h2>C is the native language of Unix. It has come to dominate systems programming in the computer industry.</h2>

<p>Work on the first official C standard began in 1983. The major functional additions to the language were settled by the end of 1986, at which point it became common for programmers to distinguish between "K&R C" and <a href='https://en.wikipedia.org/wiki/ANSI_C' target='_blank'>ANSI C</a>.</p>

<p>People use C because it <i>feels</i> faster. If you build a catapult that can hurl a bathtub with someone inside from London to New York, it will <i>feel very fast</i> both on take-off and landing, and probably during the ride, too, while a comfortable seat in business class on a transatlantic airliner would probably take less time but you would not <i>feel</i> the speed nearly as much. <a href='https://groups.google.com/group/comp.lang.lisp/browse_thread/thread/567df5923ced5a94/52564cc186195b05#52564cc186195b05' target="_blank">~</a></p>

<figure>
	<img src='../media/refs/vogue-ansic.jpg' width='300'/>
	<figcaption>&mdash; Typical C89 Programmer</figcaption>
</figure>

<p>One good reason to learn C, even if your programming needs are satisfied by a higher-level language, is that it can help you learn to think at hardware-architecture level. For notes specific to the <a href='plan9.html'>Plan9</a>'s C compiler, see <a href='plan9_c.html'>Plan9 C</a>.</p>

<h3>Compile</h3>

<p>To convert source to an executable binary one uses a compiler. My compiler of choice is <a href='https://bellard.org/tcc' target='_blank'>tcc</a>, but more generally <a href='https://gcc.gnu.org/' target='_blank'>gcc</a> is what most toolchains will use on <a href='linux.html'>Linux</a>.</p>

<pre>cc -Wall -o main main.c</pre>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int count = 10;

int
add_together(int x, int y)
{
	int result = x + y;
	return result;
}

typedef struct {
	int x;
	int y;
	int z;
} point;

void
print_point(point point)
{
	printf("the point is: (%d,%d,%d)\n",point.x,point.y,point.z);
}

int
main(int argc, char** argv)
{
	point p;
	p.x = 2;
	p.y = 3;
	p.z = 4;

	float length = sqrt(p.x * p.x + p.y * p.y);

	printf("float: %.6f\n", length);
	printf("int: %d\n", p.z);

	print_point(p);

	return 0;
}
</pre>

<h3>Include</h3>

<p>Generally, projects will include <code>.h</code> files which in turn will include their own <code>.c</code> files. The following form is used for system header files. It searches for a file named <code>file</code> in a standard list of system directories. </p>

<pre>#include &lt;file&gt;</pre>

<p>The following form is used for header files of your own program. It searches for a file named <code>folder/file.h</code> in the directory containing the current file. </p>

<pre>#include "folder/file.h"</pre>

<h3>IO</h3>

<p>One way to get input into a program or to display output from a program is to use standard input and standard output, respectively. The following two programs can be used with the unix pipe <code>./o | ./i</code></p>

<h4>o.c</h4>
<pre>
#include &lt;stdio.h&gt;

int
main()
{
	printf("(output hello)");
	return 0;
}
</pre>

<h4>i.c</h4>

<pre>
#include &lt;stdio.h&gt;

int
main()
{
	char line[256];
	if(fgets(line, 256, stdin) != NULL) {
		printf("(input: %s)\n", line);
	}
	return 0;
}
</pre>

<h3>Threads</h3>

<p>Threads are a way that a program can spawn concurrent operations that can then be delegated by the operating system to multiple processing cores. </p>

<pre>cc threads.c -o threads && ./threads</pre>

<pre>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NTHREADS 5

void
*myFun(void *x)
{
	int tid;
	tid = *((int *) x);
	printf("Hi from thread %d!\n", tid);
	return NULL;
}

int
main(int argc, char *argv[])
{
	pthread_t threads[NTHREADS];
	int thread_args[NTHREADS];
	int rc, i;

	/* spawn the threads */
	for (i=0; i&lt;NTHREADS; ++i)
	{
		thread_args[i] = i;
		printf("spawning thread %d\n", i);
		rc = pthread_create(&threads[i], NULL, myFun, (void *) &thread_args[i]);
	}

	/* wait for threads to finish */
	for (i=0; i&lt;NTHREADS; ++i) {
		rc = pthread_join(threads[i], NULL);
	}

	return 1;
}
</pre>

<h3>SDL</h3>

<pre>cc demo.c -I/usr/local/include -L/usr/local/lib -lSDL2 -o demo</pre>

<p>To compile the following example, place a <code>graphic.bmp</code> file in the same location as the c file, or remove the image block.</p>

<pre>
#include &lt;SDL2/SDL.h&gt;
#include &lt;stdio.h&gt;

int
error(char* msg, const char* err)
{
	printf("Error %s: %s\n", msg, err);
	return 1;
}

int
main()
{
	SDL_Window* window = NULL;
	SDL_Surface* surface = NULL;
	SDL_Surface* image = NULL;

	if(SDL_Init(SDL_INIT_VIDEO) < 0)
	return error("init", SDL_GetError());

	window = SDL_CreateWindow("Blank Window",
	SDL_WINDOWPOS_UNDEFINED,
	SDL_WINDOWPOS_UNDEFINED,
	640,
	480,
	SDL_WINDOW_SHOWN);

	if(window == NULL)
		return error("window", SDL_GetError());

	surface = SDL_GetWindowSurface(window);
	SDL_FillRect(surface, NULL,
	SDL_MapRGB(surface->format, 0x72, 0xDE, 0xC2));

	/* Display an image */
	image = SDL_LoadBMP("graphic.bmp");

	if(image == NULL)
		return error("image", SDL_GetError());

	SDL_BlitSurface(image, NULL, surface, NULL);

	/* Draw canvas */
	SDL_UpdateWindowSurface(window);
	SDL_Delay(2000);

	/* close */
	SDL_FreeSurface(surface);
	surface = NULL;
	SDL_DestroyWindow(window);
	window = NULL;
	SDL_Quit();

	return 0;
}
</pre>

<h3>Misc</h3>

<p>String padding: <code>|Hello |</code></p>

<pre>
printf("|%-10s|", "Hello");
</pre>

<h3>Macros</h3>

<pre>
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#define ABS(a) (((a) < 0) ? -(a) : (a))
#define CLAMP(x, low, high) (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
</pre>

<q>Quidquid latine dictum sit, altum sonatur.</q>

<ul>
	<li><a href='https://ftrv.se/3' target='_blank'>Sigrid on C</a></li>
	<li><a href='https://aiju.de/misc/c-style' target='_blank'>Aiju on C</a></li>
</ul>

