<p>
  Alonzo Church defined the boolean values ‘true’ and ‘false’ in lambda calculus as:
</p>
<ul>
  <li>true=λ<var>a</var><var>b</var>.<var>a</var></li>
  <li>false=λ<var>a</var><var>b</var>.<var>b</var></li>
</ul>
<p>
  Given a predicate (a function that returns a boolean value) <var>p</var>, the statement that would usually be written ‘if <var>p</var> then <var>E<sub>1</sub></var> else <var>E<sub>2</sub></var>’ becomes simply <var>p</var><var>E<sub>1</sub></var><var>E<sub>2</sub></var>.
</p>
<p>
  The various boolean functions are also simple:
</p>
<ul>
  <li>not p=(p)(false)(true)</li>
  <li>a and b=(a)(b)(false)</li>
  <li>a or b=(a)(true)(b)</li>
  <li>a xor b=(a)((b)(false)(true))(b)</li>
</ul>

<p>
  Integers are represented in lambda calculus by the ‘Church numerals’.
  Zero is represented by the lambda expression λ<var>f</var><var>x</var>.<var>x</var>, and other integers are generated by the applying successor function λ<var>n</var><var>f</var><var>x</var>.<var>f</var>(<var>n</var><var>f</var><var>x</var>) to an existing integer <var>n</var>.
  In other words, <var>n</var> is represented by λ<var>f</var><var>x</var>.<var>f</var>(<var>f</var>(...<var>f</var>(<var>f</var><var>x</var>)..)) where there are <var>n</var> <var>f</var>s on the right.
</p>
<p>
  Addition can be performed using the lambda expression λ<var>m</var><var>n</var><var>f</var><var>x</var>.(<var>m</var><var>f</var>)(<var>n</var><var>f</var><var>x</var>).
  This applies <var>f</var> to <var>x</var> <var>n</var> times, and then another <var>m</var> times.
</p>
<p>
  Multiplication is also easy, using the lambda expression λ<var>m</var><var>n</var><var>f</var>.<var>m</var>(<var>n</var><var>f</var>).
  This applies <var>f</var>^<var>n</var> <var>m</var> times to <var>x</var>.
</p>
<p>
  Even exponentiation is easy, using the lambda expression λ<var>m</var><var>n</var>.<var>n</var><var>m</var>.
  This is more difficult to understand than the previous two expressions.
  Remember that <var>n</var><var>m</var><var>f</var><var>x</var> means ((<var>n</var><var>m</var>)<var>f</var>)<var>x</var>.
  This is equivalent to <var>f</var>^<var>m</var>^...^<var>m</var><var>x</var>, which is <var>f</var>^(<var>m</var>^<var>n</var>)<var>x</var>.
</p>
<p>
  The predecessor function is defined to return the integer before n, unless n is zero in which case it returns zero.
  This can be accomplished with the lambda expression n(λ<var>a</var><var>g</var>.(a(λ<var>b</var><var>c</var>.<var>c</var>))(successor(a(λ<var>b</var><var>c</var>.<var>c</var>))))(λ<var>g</var>.00)(λ<var>a</var><var>b</var>.<var>a</var>), where ‘successor’ is the successor function, and 0 represents the zero expression.
  This is not as complicated as it looks.
  It applies <var>n</var> times a function that maps (x,y) to (y,y+1), to the pair (0,0), resulting in a pair (<var>n</var>-1,<var>n</var>), from which we take the left number, <var>n</var>-1.
</p>
<p>
  Subtraction of n from m is accomplished using the lambda expression λ<var>m</var><var>n</var>.<var>n</var>predecessor<var>m</var>, where ‘predecessor’ is the predecessor function.
</p>