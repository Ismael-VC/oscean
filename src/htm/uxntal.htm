<h2>Tal is the programming language for the Uxn virtual machine.</h2>

<p>Uxn programs are written in a unique flavor of <a href='assembly.html'>assembly</a> designed explicitly for this virtual machine. TAL files are human-readable source files, ROM files are uxn-compatible binary program files; the application that transforms a program into an application is called the <i>Assembler</i>.</p>

<img src='../media/generic/uxn.beet.png' width='150' style='float:left'/>

<p>Stack machine programming might look at bit odd, as it uses a <a href='reverse_polish.html'>postfix notation</a>, which means that operators are always found at the end of an operation. For instance, one would write <code>3 4 +</code> instead of <code>3 + 4</code>. The expression written <code>(5 + 10) * 3</code> in conventional notation would be written <code>10 5 + 3 *</code> in reverse Polish notation.</p>
<hr style='border:0'/>

<h2>Opcodes</h2>

<p>There are 32 opcodes, each opcode occupies 5 bits of a byte, the remaining 3 bits are used for the modes of that opcode. </p>

<table border="1">
	<tr><td colspan="3"><i>modes</i> <code class='op'>kr2</code></td><td colspan="5">opcode <code class='op'>BRK</code></td></tr>
	<tr><td class='clr2'>0</td><td class='clr2'>0</td><td class='clr2'>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>

<ul>
	<li>The <b>keep mode</b> does not consume items from the stack.</li>
	<li>The <b>return mode</b> operates on the return-stack directly.</li>
	<li>The <b>short mode</b> will operate on shorts instead of bytes.</li>
</ul>

<p>The following table indicates the effect of each opcode with the given stack <code>a b c</code> where <code>c</code> was the last item added to the stack. Other items in the table include the Program Counter(pc), Memory(m), Return Stack(rs) and Devices(d). For a more detailed view of the opcodes, see the <a href='uxntal_reference.html'>Uxntal Reference</a>.</p>

<table border="1" width="840">
	<tr><td></td><th>Stack</th><th></th><td></td>                                             <th>Memory</th><th></th></tr>
	<tr><th>0x00</th><td><code class='op'>BRK/LIT</code> Break</td><td>a b c m[pc+1]</td>     <th>0x10</th><td><code class='op'>LDZ</code> Load Zeropage</td><td>a b m[c8]</td></tr>
	<tr><th>0x01</th><td><code class='op'>INC</code> Increment</td><td>a b c+1</td>           <th>0x11</th><td><code class='op'>STZ</code> Save Zeropage</td><td>a {m[c8]=b}</td></tr>
	<tr><th>0x02</th><td><code class='op'>POP</code> Pop</td><td>a b</td>                     <th>0x12</th><td><code class='op'>LDR</code> Load Rel</td><td>a b m[pc+c8]</td></tr>
	<tr><th>0x03</th><td><code class='op'>DUP</code> Duplicate</td><td>a b c c</td>           <th>0x13</th><td><code class='op'>STR</code> Save Rel</td><td>a {m[pc+c8]=b}</td></tr>
	<tr><th>0x04</th><td><code class='op'>NIP</code> Nip</td><td>a c</td>                     <th>0x14</th><td><code class='op'>LDA</code> Load Abs</td><td>a b m[c16]</td></tr>
	<tr><th>0x05</th><td><code class='op'>SWP</code> Swap</td><td>a c b</td>                  <th>0x15</th><td><code class='op'>STA</code> Save Abs</td><td>a {m[c16]=b}</td></tr>
	<tr><th>0x06</th><td><code class='op'>OVR</code> Over</td><td>a b c b</td>                <th>0x16</th><td><code class='op'>DEI</code> Device In</td><td>a b d[c8]</td></tr>
	<tr><th>0x07</th><td><code class='op'>ROT</code> Rotate</td><td>b c a</td>                <th>0x17</th><td><code class='op'>DEO</code> Device Out</td><td>a {d[c8]=b}</td></tr>
	<tr><td></td><th>Logic</th><th></th><td></td>                                             <th>Arithmetic</th><th></th></tr>
	<tr><th>0x08</th><td><code class='op'>EQU</code> Equal</td><td>a (b?c)</td>              <th>0x18</th><td><code class='op'>ADD</code> Add</td><td>a b+c</td></tr>
	<tr><th>0x09</th><td><code class='op'>NEQ</code> NotEqual</td><td>a (b!c)</td>           <th>0x19</th><td><code class='op'>SUB</code> Subtract</td><td>a b-c</td></tr>
	<tr><th>0x0a</th><td><code class='op'>GTH</code> Greater</td><td>a (b&gt;c)</td>          <th>0x1a</th><td><code class='op'>MUL</code> Multiply</td><td>a b*c</td></tr>
	<tr><th>0x0b</th><td><code class='op'>LTH</code> Lesser</td><td>a (b&lt;c)</td>           <th>0x1b</th><td><code class='op'>DIV</code> Divide</td><td>a b/c</td></tr>
	<tr><th>0x0c</th><td><code class='op'>JMP</code> Jump</td><td>a b {pc+=c}</td>            <th>0x1c</th><td><code class='op'>AND</code> And</td><td>a b&c</td></tr>
	<tr><th>0x0d</th><td><code class='op'>JCN</code> JumpCond</td><td>a {(b8)pc+=c}</td>      <th>0x1d</th><td><code class='op'>ORA</code> Or</td><td>a b|c</td></tr>
	<tr><th>0x0e</th><td><code class='op'>JSR</code> JumpStash</td><td>a b {pc->rs pc+=c}</td><th>0x1e</th><td><code class='op'>EOR</code> ExclusiveOr</td><td>a b^c</td></tr>
	<tr><th>0x0f</th><td><code class='op'>STH</code> Stash</td><td>a b {c->rs}</td>           <th>0x1f</th><td><code class='op'>SFT</code> Shift</td><td>a b&gt;&gt;c8l&lt;&lt;c8h</td></tr>
</table>

<p>Operator modes are indicated by appending extra characters at the end of the opcode, for example, the <i>short mode</i> for the <code class='op'>ADD</code> opcode is <code class='op'>ADD2</code>, modes can also be combined, for example: <code class='op'>ADD2kr</code>. A boolean byte is 00 for false, or or 01 for true.</p>

<img src="../media/generic/uxn.team.png" width="250" style="margin:0 auto 30px">

<h2>Programming</h2>

<p>Uxntal has no reserved words besides the 32 opcodes, each element type begins with its own special character, or <i>rune</i>. Comments are within parentheses, curlies are used in the definition of macros, and the square brackets are ignored. Hexadecimal values are always lowercase.</p>

<h3>Hello World</h3>

<p>In this example program, we begins by creating the <code>EMIT</code> macro, which contains the byte value of the <a href='varvara.html#console'>Console/write</a> port, followed by the <code class='op'>DEO</code> device output opcode. From that point onward, using <code>EMIT</code> will send a byte from the stack, to the Console/write port. Each device has 16 ports, each port handle a specific I/O.</p>

<pre class='example'>
<b>%HALT</b> { #010f DEO }
<b>%EMIT</b> { #18 DEO }

<span class='comment'>( init )</span>

|0100 <span class='label'>@program</span>
	
	<b>;hello-word</b>

	<span class='label'>&while</span>
		<span class='comment'>( send )</span> LDAk EMIT
		<span class='comment'>( loop )</span> INC2 LDAk <b>,&while</b> JCN
	POP2

	HALT
	
BRK

<span class='label'>@hello-word</span> "Hello 20 "World! 00
</pre>

<p>Assembled(31 bytes):</p>

<pre>
a001 1294 8018 1721 9480 f70d 22a0 010f
1700 4865 6c6c 6f20 576f 726c 6421 00
</pre>

<style>
span.label { font-weight: bold;background: #fff;color: #000;padding: 2px 4px; }
span.comment { color:#aaa }
</style>

<p>Next, we pad to <code class='op'>|0100</code>, which is where the first page of memory ends, and where all Uxn programs begin. Our program begins by pushing to the stack, the absolute address of the label <code class='op'>@hello-world</code>, which is defined at the end, and points to a series of characters. An absolute address is made of two bytes.</p>

<p>We then assign the child label <code class='op'>&while</code> to this position of the program so we can return to it later.</p>

<p>Next, the <code class='op'>LDAk</code> opcode takes two bytes at the top of the stack to form an absolute address, and loads the value in memory found at that address to the top of the stack, in this case, the <a href='ascii.html'>ascii value</a> of the letter H. That value is sent to Console/write(port #18) which prints that character to the terminal.</p>

<p>To increment the absolute address found on top of the stack, we use <code class='op'>INC2</code> because we know the items on the stack to be an address made of two bytes. We load the incremented value, the <code class='op'>JCN</code> opcode will jump to the position of label <code class='op'>&while</code> as long as the item before the address is not zero. We complete the program with <code class='op'>POP2</code> to remove the address on the stack, to keep the stack clean.</p>

<p>Both <code class='op'>&while</code> and <code class='op'>@while</code> are ways to define labels, but using <code>&while</code> will automatically prefix a new <code>&label</code> with the name of the last <code>@label</code>, in this example <code>program/while</code>. Since label names are unique identifiers and you might need multiple instances of something called <i>while</i>, it's best to use sublabels when possible.</p>

<table border="1">
	<tr><th colspan="4">Runes</th></tr>
	<tr><td><code>%</code></td><td>macro-define</td><td><code>#</code></td><td>literal hex</td></tr>
	<tr><td><code>|</code></td><td>pad(absolute)</td><td><code>.</code></td><td>literal addr(zero-page)</td></tr>
	<tr><td><code>$</code></td><td>pad(relative)</td><td><code>,</code></td><td>literal addr(relative)</td></tr>
	<tr><td><code>@</code></td><td>label-define</td><td><code>;</code></td><td>literal addr(absolute)</td></tr>
	<tr><td><code>&amp;</code></td><td>sublabel-define</td> <td><code>:</code></td><td>raw addr(absolute)</td></tr>
	<tr><td></td><td></td> <td><code>&#39;</code></td><td>raw char</td></tr>
	<tr><td><code>~</code></td><td>include</td><td><code>&quot;</code></td><td>raw word</td></tr>
</table>

<h2>Addressing</h2>

<p>The memory and stacks contain bytes, values with a length of 8 bits. To differentiate between operations and literal numbers, the <code class='op'>LIT</code> opcode will push the following byte from memory onto the stack, the 16-bits mode <code class='op'>LIT2</code> opcode will push the following short. A literal is a byte or short prefixed with a LIT opcode, raw values are not prefixed with the LIT opcode.</p>

<table border="1">
	<tr><th rowspan="2"></th><th colspan="4">Single</th><th colspan="2">Double</th></tr>
	<tr><th>Byte</th><th>Char</th><th>ZeroPage</th><th>Relative</th><th>Short</th><th>Absolute</th></tr>
	<tr><td><i>Literal</i></td><td><code>#ab</code></td><td></td><td><code>.label</code></td><td><code>,label</code></td><td><code>#abcd</code></td><td><code>;label</code></td></tr>
	<tr><td><i>Raw</i></td><td><code>ab</code></td><td><code>'Q</code></td><td></td><td></td><td><code>abcd</code></td><td><code>:label</code></td></tr>
</table>

<h2>Assembler</h2>

<p>The original assembler is about 400 lines of <a href='ansi_c.html'>ANSI C</a>, it is used to create rom program files, from tal source files. Nowadays, most uxntal programmers prefer to use the <a href='https://git.sr.ht/~rabbits/uxn/tree/main/item/projects/library/asma.tal' target='_blank'>self-hosted assembler</a>.</p>

<iframe src="https://git.sr.ht/~rabbits/uxn/blob/main/src/uxnasm.c"></iframe>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:black; }
.clr3 { background:#ff0000; color:black; }
code.op { background: #000; color: white; font-size: smaller; display: inline-block; padding: 0px 6px; font-weight: bold; border-radius: 2px; line-height: 22px }
pre span.comment { color:#666; }
</style>

<img src="../media/identity/uxn64.png">

<ul>
	<li><a href='https://compudanzas.net/uxn_tutorial.html' target='_blank'>Introduction to Uxntal</a></li>
</ul>

