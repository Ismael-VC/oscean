<h2>Uxntal Signed</h2>

<p>Uxn doesn't have any built-in support for signed integers. However, you can
emulate signed numbers using unsigned numbers by treating some of the values as
having different (negative) values from their unsigned values. For example,
treating unsigned bytes as signed results in the following:</p>

<table border='1'>
	<tr><th>unsigned hex</th><th>unsigned decimal</th><th>signed decimal</th></tr>
	<tr><td>#00</td><td>0</td><td>0</td></tr>
	<tr><td>#01</td><td>1</td><td>1</td></tr>
	<tr><td>#02</td><td>2</td><td>2</td></tr>
	<tr><td>#7e</td><td>126</td><td>126</td></tr>
	<tr><td>#7f</td><td>127</td><td>127</td></tr>
	<tr><td>#80</td><td>128</td><td>-128</td></tr>
	<tr><td>#81</td><td>129</td><td>-127</td></tr>
	<tr><td>#82</td><td>130</td><td>-126</td></tr>
	<tr><td>#fd</td><td>253</td><td>-3</td></tr>
	<tr><td>#fe</td><td>254</td><td>-2</td></tr>
	<tr><td>#ff</td><td>255</td><td>-1</td></tr>
</table>

<p>The first 128 integers (0-127) are represented the same as unsigned and
signed, but the latter 128 are different. The basic idea here is that for
values greater than #7f (127) we subtract 256 to get their "signed value":</p>

<pre>signed(n) = if n > 127 then n else n - 256</pre>

<p>It turns out that many unsigned operations "work" even when treating the values
as signed. (In other words, you get the same result as you would have using a
language with signed integer types.) The following arithmetic instructions work
correctly with "signed" values:</p>

<pre>
#13 #ff ADD returns #12
#02 #03 SUB returns #ff
#02 #ff MUL returns #fe
</pre>

<p>Be careful! The smallest negative value (-128 for bytes, -32768 for shorts)
has no corresponding positive value. This means that some operations will
not work as expected:</p>

<pre>
#80 #ff MUL returns #80 (-128 * -1 = -128)
#00 #80 SUB returns #80 (0 - (-128) = -128)
</pre>

<p>Also, negative and positive values will "wrap around" in the usual way when
dealing with two's-complement representations:</p>

<pre>
#7f #01 ADD returns #80 (127 + 1 = -128)
#80 #01 SUB returns #7f (-128 - 1 = 127)
#80 #80 ADD returns #00 (-128 + (-128) = 0)
</pre>

<p>Other instructions will not handle "negative" integers correctly. These
routines will safely compare "signed" bytes:</p>

<pre>
@signed-lth ( x y -- x&lt;y )
	DUP2 #8080 AND2 EQU ?{ LTH JMP2r } LTH #00 NEQ
	JMP2r

@signed-gth ( x y -- x&gt;y )
	DUP2 #8080 AND2 EQU ?{ GTH JMP2r } GTH #00 NEQ
	JMP2r
</pre>

<p>Similarly, division will not correctly handle signed values. The simplest
way to handle this is to make both values non-negative, do unsigned
division (i.e. DIV) and then set the correct sign at the end.</p>

<pre>
@signed-div ( x y -- x/y )
	DUP2 #8080 AND2 EQU STH DIV STHr ?{ #ff MUL }
	JMP2r
</pre>

<p>The unsigned shift operator treats the sign bit like any other. This means
shifting left will lose the sign bit (reversing the sign) and that shifting
right will convert the sign bit into a value bit. Signed numbers will also need
their own routines for decimal input and output, if those are required by your
program.</p>

<p>If you need a sign-aware shift you'll likely want to convert negatives to
positive values, perform a shift, and then restore the sign. Keep in mind
that -128 cannot be converted to a positive value, and may require special
treatment.</p>

<ul>
	<li>Guide by <a href='http://plastic-idolatry.com/erik/nxu/math-notes.txt' target='_blank'>d_m</a></li>
</ul>

