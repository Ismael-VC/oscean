<h2>Uxntal is a stack-machine assembly language targeting the Uxn virtual machine.</h2>

<h3>Let's Begin.</h3>

<pre>
<code>( This is a comment )</code>

<code>( All programming in Unxtal is done by manipulating the stack )</code>

#12 <code>( 12 )</code>
#3456 <code>( 34 56 )</code>

<code>( Uxn has 32 opcodes )</code>

<b>LIT</b> a b c M[PC+1] <b>EQU</b> a b?c             <b>LDZ</b> a b M[c8]      <b>ADD</b> a b+c
<b>INC</b> a b c+1       <b>NEQ</b> a b!c             <b>STZ</b> a {M[c8]=b}    <b>SUB</b> a b-c
<b>POP</b> a b           <b>GTH</b> a b&gt;c             <b>LDR</b> a b M[PC+c8]   <b>MUL</b> a b*c
<b>NIP</b> a c           <b>LTH</b> a b&lt;c             <b>STR</b> a {M[PC+c8]=b} <b>DIV</b> a b/c
<b>SWP</b> a c b         <b>JMP</b> a b {PC+=c}       <b>LDA</b> a b M[c16]     <b>AND</b> a b&c
<b>ROT</b> b c a         <b>JCN</b> a {(b8)PC+=c}     <b>STA</b> a {M[c16]=b}   <b>ORA</b> a b|c
<b>DUP</b> a b c c       <b>JSR</b> a b {rs.PC PC+=c} <b>DEI</b> a b D[c8]      <b>EOR</b> a b^c
<b>OVR</b> a b c b       <b>STH</b> a b {rs.c}        <b>DEO</b> a {D[c8]=b}    <b>SFT</b> a b&gt;&gt;c8l&lt;&lt;c8h

<code>( Each opcode has 3 possible modes
	[2] The short mode operates on shorts instead of bytes.
	[r] The return mode operate on the return stack.
	[k] The keep mode operates without consuming items. )</code>

#12 #34 ADD <code>( 46 )</code>
#12 #34 ADDk <code>( 12 34 46 )</code>

<code>( The modes can be combined )</code>

#1234 #5678 ADD2k <code>( 12 34 56 78 68 ac )</code>

<code>( The arithmetic and bitewise opcodes are:
	ADD SUB MUL DIV
	AND ORA EOR SFT )</code>

<code>( New words can be created using macros )</code>

%MOD2 { DIV2k MUL2 SUB2 }

#1234 #0421 MOD2 <code>( 01 b0 )</code>

<code>( -------------------------------------------------------------------------- )</code>

<code>( A short is simply two bytes, each byte can be manipulated )</code>

#1234 SWP <code>( 34 12 )</code>
#1234 #5678 SWP2 <code>( 56 78 12 34 )</code>
#1234 #5678 SWP <code>( 12 34 78 56 )</code>

<code>( Individual bytes of of a short can be removed from the stack )</code>

#1234 POP <code>( 12 )</code>
#1234 NIP <code>( 34 )</code>

<code>( The stack opcodes are:
	POP DUP NIP SWP OVR ROT )</code>

<code>( -------------------------------------------------------------------------- )</code>

<code>( To compare values on the stack with each other )</code>

#12 #34 EQU <code>( 00 )</code>
#12 #12 EQU <code>( 01 )</code>

<code>( Logic opcodes will put a flag with a value of either 00 or 01 )</code>

#12 #34 LTH 
#78 #56 GTH 
	ADD <code>( 02 )</code>

<code>( The logic opcodes are:
	EQU NEQ GTH LTH )</code>

<code>( -------------------------------------------------------------------------- )</code>

<code>( Uxn's memory contains 65536 bytes )</code>

#12 #0200 STA <code>( stored 12 at 0x0200 )</code>
#3456 #0400 STA2 <code>( stored 34 at 0x0400, stored 56 at 0x0401 )</code>
#0400 LDA2 <code>( 34 56 )</code>

<code>( The zero-page can be addressed with a single byte )</code>

#1234 #80 STZ2 <code>( stored 12 at 0x0080, and 34 at 0x0081 )</code>
#80 LDZ2 <code>( 12 34 )</code>

<code>( Devices are ways for Uxn to communicate with the outside world
	There is a maximum of 16 devices connected to Uxn at once
	Device bytes are called ports, the Console device uses the 10-1f ports
	The console's port 18 is called /write )</code>

%EMIT { #18 DEO }

#31 EMIT <code>( print "1" to console )</code>

<code>( A label is equal to a position in the program )</code>
@parent <code>( defines a label "parent" )</code>
	&child <code>( defines a sublabel "parent/child" )</code>

<code>( Label positions can be pushed on stack )</code>
;parent <code>( push the absolute position, 2 bytes )</code>
,parent <code>( push the relative position, 1 byte )</code>
.parent <code>( push the zero-page position, 1 byte )</code>

<code>( The memory opcodes are:
	LDZ STZ LDR STR
	LDA STA DEI DEO )</code>

<code>( -------------------------------------------------------------------------- )</code>

<code>( Skip a piece of code )</code>

#12 #34 NEQ ,skip JCN
	<code>( body )</code>
	@skip

<code>( Create a for-loop )</code>

#3a #30
@loop
	DUP EMIT <code>( print "123456789" to console )</code>
	INC GTHk ,loop JCN
POP2

<code>( Create a while-loops )</code>

;word
@while
	LDAk EMIT <code>( print "vermillion" to console )</code>
	INC2 LDAk ,while JCN
POP2
BRK

@word "vermillion $1

<code>( Subroutines can be jumped to with JSR, and returned from with JMP2r )</code>

;word ,print-word JSR
BRK

@print-word <code>( word* -- )</code>
	@while
		LDAk EMIT
		INC2 LDAk ,while JCN
	POP2
JMP2r

@word "cerulean

<code>( The jump opcodes are: 
	JMP JCN JSR )</code>

<code>( -------------------------------------------------------------------------- )</code>

<code>( Arithmetic macros )</code>

%MOD  { DIVk MUL SUB }
%MOD2 { DIV2k MUL2 SUB2 }
%MIN2 { LTH2k JMP SWP2 POP2 }
%MAX2 { GTH2k JMP SWP2 POP2 }

<code>( Signed logic macros )</code>

%LTS2 { #8000 ADD2 SWP2 #8000 ADD2 GTH2 }
%GTS2 { #8000 ADD2 SWP2 #8000 ADD2 LTH2 }

<code>( ASCII macros )</code>

%IS-UC { DUP #40 GTH SWP #5b LTH AND }
%IS-LC { DUP #60 GTH SWP #7b LTH AND }
%IS-NUM { DUP #2f GTH SWP #3a LTH AND }

<code>( Binary macros )</code>

%ROL { DUP #07 SFT SWP #10 SFT ADD }
%ROR { DUP #70 SFT SWP #01 SFT ADD }
%ROL2 { DUP2 #0f SFT2 SWP2 #10 SFT2 ADD2 }
%ROR2 { DUP2 #f0 SFT2 SWP2 #01 SFT2 ADD2 }

<code>( A clever hack )</code>

%PC { #00 JSR STH2r }
</pre>

<p>Try the <a href='../etc/unicycle/index.html' target='_blank'>HTML5 Interpreter</a> in your browser.</p>
