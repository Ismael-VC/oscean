<h2>FLENG is a low-level concurrent logic language descending from Concurrent Prolog.</h2>

<p>A FLENG program consists of a set of "process definitions", where each definition is a set of clauses of the same name and arity.</p>

<pre>
	process_name(Argument1, ...) :- Goal1, ... .
</pre>

<h3>Hello World</h3>

<pre>
% this is a comment

-initialization(main). % start execution at "main" goal

main :- writeln('hello, world.').
</pre>

<p>Arguments are "matched" to the actual argument given when the process is created. Goals are new processes to be invoked when the clause is selected. When a process is invoked, one clause of its definition that matches the given arguments is selected and executed, by spawning a new process for each goal in the body.</p>

<p>Each clause must have a body containing a list of goals, separated by comma (","). Note that all body goals are truly executed in parallel, not in the order in which they are specified. If no clause matches the arguments, then the process "fails", resulting in a run-time error.</p>

<h3>Sequencing process execution</h3>

<p>If processes must run sequentially, there are three methods
for ensuring non-parallel execution, with different run-time
costs and partially different semantics. The cheapest method
is to assign a value to a dedicated unbound variable and 
force the argument in a clause head to be bound:</p>

<pre>
    seq :- first(A), second(A).                     [FGHC]
    first(A) :- ..., A = [].        % "[]" used by convention
    second(A) :- data(A) | ... .    % alternatively: "second(!_)"
</pre>

<p>The second option is to use "when/2":</p>

<pre>
    seq :- first(A), when(A, second).               [FGHC]
    first(A) :- ..., A = [].
    second :- ... .
</pre>

<p>"when/2" is basically equivalent to the first method, but
creates a compiler-generated intermediate predicate that
performs the dereferencing (and possible suspension) of the
assigned variable.</p>

<p>
The third method is to use "&/2", which runs the first goal
as a child task and invokes the second goal when the task and
all processes spawned by the task have completed:</p>

<pre>
    seq :- first & second.
</pre>

<h3>Data Types</h3>

<pre>
    signed integers             123  0xF00F  0'A
    floating point numbers      1.23
    strings (atoms)             abc  'one\ntwo'
    lists                       [1, 2, 3]  [head|tail]  "abc"
    tuples                      foo(bar, baz)  {x, y, z}
    variables                   Abc  _123  _
    ports
    modules
</pre>

<p>Print the numbers from 1 to 10</p>

<pre>
-initialization(main).
main :- loop(0).

loop(Iter) :- loop_body([], Iter).
loop_body(_, 10).
loop_body([], Iter) :-
	Iter =< 10 | print(Iter, Ok),
	Iter2 is Iter + 1,
	loop_body(Ok, Iter2).
print(X, Ok) :- writeln(X, Ok).
</pre>


<ul>
	<li><a href='http://www.call-with-current-continuation.org/fleng/fleng.html' target='_blank'>FLENG</a></li>
	<li><a href='http://www.call-with-current-continuation.org/articles/the-joy-of-concurrent-logic-programming.txt' target='_blank'>The Joy Of Concurrent Programming</a></li>
</ul>

