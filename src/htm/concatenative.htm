<h2>Expressions in a point-free language denote functions, and the
juxtaposition of expressions denotes function composition.</h2>

<p>The point-free programming paradigm is where function definitions do not
identify the arguments on which they operate. Instead the definitions merely
compose other functions, among which are combinators that manipulate the
arguments.</p>

<img src='../media/refs/rpn.png' width='40' class='nodark'/>

<ul>
	<li>All terms denote functions.</li>
	<li>All functions are unary functions from a stack, or queue.</li>
	<li>Juxtaposition denotes the composition of functions.</li>
</ul>

<h3>Properties of Concatenative Languages</h3>

<p>Most existing concatenative languages are stack-based; this is not a
requirement and other models have been proposed. The simple model provided in a
stack-oriented language allows expressions and programs to be interpreted
simply and theoretically evaluated much faster, since no syntax analysis need
be done, only lexical analysis.</p>

<ul>
	<li>Concatenative languages are necessarily point-free as allowing terms to
denote variables would violate the rule that all terms denote functions.</li>
	<li>The reduction of any expression is the simplification of one function to
another function; it is never necessary to deal with the application of
functions to objects. This property separates them from the otherwise similar
function-level languages of John Backus, which are <a href='applicative.html'>applicative</a>.</li>
	<li>Any subexpression can be replaced with a name that represents the same
subexpression. This is referred to in the concatenative community as factoring
and is used extensively to simplify programs into smaller parts.</li>
	<li>The syntax and semantics of concatenative languages form the algebraic
structure of a monoid.</li>
</ul>

<h3>Advantages</h3>

<ul>
	<li>Simplifies the handling of multiple return values.</li>
	<li>Postfix syntax is the most economic way to express
computations <i>syntactically</i>.</li>
	<li>No precedence rules.</li>
</ul>

<p>A concatenative language is completely associative: you can group words
within it anyhow you'd like, and maintain the same semantics. A pure
functional language is referentially transparent: if two complete
expressions have the same semantics, they can be interchanged without
changing the program semantics. The functional language, however,
requires "complete expressions"; the concatenative language doesn't.
</p>

<q>Truth be told, the amount of good research into concatenative
languages is nearly non-existent. </q>


