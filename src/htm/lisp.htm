<h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, operations use the <a href='notation.html'>prefix notation</a>.
<b>Function</b> names come after an open parenthesis followed by arguments, and
a closing parenthesis. <b>Atoms</b> are tokens in a list separated by spaces,
tabs or newlines. A pair of parentheses indicates one step of calculation.</p>

<pre>(function arg1 arg2 arg3)</pre>

<p>For the length of this page, I will use uppercase function names to indicate
built-in functions, and lowercase for user-defined functions. This page will
document a portable, lexically scoped, purely functional subset of Lisp,
sometimes called <i>Pure Lisp</i>, which does <b>not</b> allow for:</p>

<ul>
	<li>Unbound and global variables</li>
	<li>Destructive data operations.</li>
	<li>GOTOs, and side effects.</li>
	<li>Explicit pointers and dereferencing.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Data Types</h3>

<p>A <b>number</b> is a signed integer in a machine-specific finite range, and the
representation of a number is a sequence of decimal digits, optionally
preceded by a sign.</p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a finite sequence of characters, it is not
possible for the user to type symbols which begin as though they were numbers,
although digits may appear later in a symbol that begins with, say, a letter.
</p>

<pre>
Hello
Hello-world
x32 </pre>

<p>A <b>pair</b> consists of two component called the head and the tail. The
components of a pair may be any type of value, including pairs, so that pairing
may be used to construct arbitrarily large data structures. </p>

<pre>
( 45 . Hello )
( foo . bar )
( -12 . ( 34 . 56 ) )
</pre>

<p>A <b>function</b> is a value which may be applied to arguments, to yield a
value which depends only on the function and the arguments to which it is
applied. Given an expression, <b>quote</b> returns that expression as a value.</p>

<pre>
(QUOTE 12)
(REM (QUOTE 19) (QUOTE 24))
(MUL (QUOTE 2) (ADD (QUOTE 1) X))
</pre>

<h3>Prelude</h3>

<p>A <b>lambda</b> expression allows to name sub-expressions, given an argument
list and an expression, returns them as a function:</p>

<pre>
(LAMBDA (X Y) (ADD X Y))
</pre>

<p>Alternatively, the <b>let</b> expression can also associate a name to an
expression, given an expression with declarations (as named expressions visible
in the expression) returns its value:</p>

<pre>
(LET (QUOTE (aleph 1234)))
</pre>

<p>The following expression has value <b>True(T)</b> if the value of the
expression is an <b>atom</b>, a number or a symbol, or has value
<b>False(F)</b> otherwise. </p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<p>The <b>equality</b> of two atomic expressions may be tested by an expression
of the following form, and result in a value either T or F provided that the
values of the expressions being compared are both atoms, and either they are
both the same number, or they are both the same symbol:</p>

<pre>
(LAMBDA (X) (EQ (QUOTE foo) X))
</pre>

<p>Given three expressions <b>if</b> returns the value of the second if the value of the
first is True, otherwise returns the value of the third.</p>

<pre>
(IF (EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16)
)
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Program</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given an
expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry function. If the symbol
"Machiavelli" is used as argument, the program will evaluate to the following
pair:</p>

<pre>
(LAMBDA (<i>INPUT</i>)
	(CONS (QUOTE Hello) <i>INPUT</i>)
) <i>; ( Hello . Machiavelli )</i>
</pre>

<p>Typically, a program will have an entry function's name. For example, the
previous program could be given a the name <code>greeting</code>. The main
difference between LET and LETREC is that, with LETREC, the defined symbols are
also visible in the expressions from the list of cons pairs, not just from the
main expression.</p>

<pre>
(LETREC <b>factorial</b>
	(<b>factorial</b> LAMBDA (<i>INPUT</i>)
		(IF (EQ <i>INPUT</i> (QUOTE 0))
			(QUOTE 1)
			(MUL <i>INPUT</i> (<b>factorial</b> (SUB <i>INPUT</i> (QUOTE 1))))
		)
	)
)
</pre>

<p>Using everything we've seen so far, we can see a more elaborate program, in
which functions are organized as lambdas so they can be used in other parts of
the program as follows:</p>

<pre>
(LETREC <b>main</b>
	(<b>main</b> LAMBDA (<i>INPUT</i>)
		(<b>loop</b> (QUOTE 0) <i>INPUT</i>)
	)
	(<b>loop</b> LAMBDA (X Y)
		(IF (LEQ X Y)
			(<b>loop</b> (<b>incr</b> X) Y)
			(CONS X (CONS Y (QUOTE NIL))))
		)
	(<b>incr</b> LAMBDA (X)
		(ADD (QUOTE 1) X)
	)
)
</pre>

<img src='../media/refs/sicp.jpg' style='width:200px; float:right'/>

<q>Writing EVAL required inventing a notation representing Lisp functions as Lisp
data, and such a notation was devised for the purposes of the paper with no
thought that it would be used to express Lisp programs in practice. </q>

<h3>Library Functions</h3>

<h4>List processing junctions</h4>
<ul>
	<li><code>(append e1 e2)</code> Is the list obtained by concatenation of its two arguments.</li>
	<li><code>(member e l)</code> is T if the atom e is present in the list l.</li>
	<li><code>(equal e1 e2)</code> tests the equality of two non-function data structures.</li>
	<li><code>(null e)</code> is T if e is NIL, and is F otherwise.</li>
	<li><code>(length l)</code> is the number of components in the list l.</li>
	<li><code>(first n l)</code> returns a prefix of the first n components of the list l, or the whole list if shorter.</li>
	<li><code>(1ist e1 ... en)</code> returns a list of its arguments.</li>
	<li><code>(transpose m)</code> is the matrix transposition of a list of lists m.</li>
</ul>

<h4>Logical operators</h4>
<ul>
	<li><code>(not c)</code> is T if c is F, and is F if c is T.</li>
	<li><code>(or cl c2)</code> is T if either of the arguments is T, and is F if both are F.</li>
	<li><code>(and cl c2)</code> is T if both of the arguments are T, and is F if either is F.</li>
	<li><code>(unless cl c2)</code> is an abbreviation for <code>(and (not c1) c2)</code>.</li>
</ul>

<h4>Stream operations</h4>
<ul>
	<li><code>(until e l)</code> is the list of components of the stream l which precede the first occurrence of the atom e.</li>
	<li><code>(untilend I)</code> abbreviates <code>(until (quote end) 1)</code>.</li>
	<li><code>(alter e I)</code> is the stream of eomponcnls of I which follow the first occurrence of the atom e.</li>
	<li><code>(aherend I)</code> abbreviates <code>(aher (quote end) I)</code>.</li>
</ul>

<h4>Commonly used higher order functions</h4>
<ul>
	<li><code>(map f l)</code> is the list whose components are obtained from those of l by application of f.</li>
	<li><code>(reduce f l z)</code> Is the continued applicalion of f over the list l with zero z, that is <code>(I (head l) (l (head (tail l)) (l··· z)···))</code>.</li>
	<li><code>(filter p l)</code> Is the list of those components c of l for which (p c) is T.</li>
	<li><code>(close r l)</code> is  the first value x in the sequence <code>I, (r l). (r (r l))</code>, for which <code>(equal x (r x))</code>.</li>
</ul>

<h4>Misc</h4>
<ul>
	<li><code>(number x)</code> Is T if x is a numeric atom. and F otherwise.</li>
	<li><code>(load_code c)</code> is the value represented by the code object c.</li>
	<li><code>(apply f I)</code> applies the funcllon f to the argument list I 
	<li><code>newline</code> an atom which prints as a line break.</li>
	<li><code>space</code> an atom which prints as a blank space.</li>
</ul>

<ul>
	<li><a href='http://www.shido.info/lisp/idx_scm_e.html' target='_blank'>Scheme Tutorial</a></li>
	<li><a href='http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp' target='_blank'>Lisp Eval</a></li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

<img src='../media/refs/lmi.png' width='100'/>

