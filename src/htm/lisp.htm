<h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, operations use the <a href='notation.html'>prefix notation</a>.
<b>Function</b> names come after an open parenthesis followed by arguments, and
a closing parenthesis. <b>Atoms</b> are tokens in a list separated by spaces,
tabs or newlines. A pair of parentheses indicates one step of calculation.</p>

<pre>(<b>function</b> arg1 arg2 arg3)</pre>

<p>For the length of this page, I will use uppercase function names to indicate
built-in functions, and lowercase for user-defined functions. This page will
document a portable, lexically scoped, purely functional subset of Lisp,
sometimes called <a href='https://git.sr.ht/~rabbits/lispkit'
target='_blank'>Pure Lisp</a>, which does <b>not</b> allow for:</p>

<ul>
	<li>Unbound and global variables</li>
	<li>Destructive data operations.</li>
	<li>GOTOs, and side effects.</li>
	<li>Explicit pointers and dereferencing.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Atoms</h3>

<p>An <b>atom</b> is either a number or a symbol. A <b>number</b> is a signed
integer, its representation is a sequence of decimal digits, optionally
preceded by a sign. </p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a sequence of characters, it cannot begin
with a number or a sign, although these may appear later in a symbol. </p>

<pre>
Hello
Hello-world
x32 </pre>

<p>The <b>(ATOM exp)</b> procedure return True(<b>T</b>) if the value of the expression
is an atom or False(<b>F</b>) otherwise.</p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<h3>Pairs</h3>

<p>A <b>pair</b> joins two arbitrary values. The <b>(CONS a d)</b> procedure
constructs pairs, the <b>(CAR list)</b> procedure extracts the first elements of
the pair, and the <b>(CDR list)</b> procedure extracts the second.</p>

<pre>
(CONS (QUOTE foo) (QUOTE bar)) <i>; (foo.bar)</i>
(CDR (CONS (QUOTE foo) (QUOTE bar))) <i>; foo</i>
(CAR (CONS (QUOTE foo) (QUOTE bar))) <i>; bar</i>
</pre>

<p>A <b>list</b> is a chain of pair that are <i>cons-ed</i> onto one another, ending
with a <b>nil</b>. The <b>car</b>(head) of a cell is its value, the <b>cdr</b>(tail) is the
address of the following cell.</p>

<pre>
(CONS (QUOTE a)
	(CONS (QUOTE b)
		(CONS (QUOTE c) (' NIL)))) <i>; [a,b,c]</i>
</pre>

<h3>Procedures</h3>

<p>A <b>(LAMBDA args expr)</b> expression evaluates to a procedure. The
environment which is in effect when a lambda expression is evaluated is
enclosed in the newly created procedure, this is referred to as a closure.
Given an expression, the <b>(QUOTE exp)</b> procedure returns that expression
as a value.</p>

<pre>
(LAMBDA (X) (ADD X (QUOTE 2))) <i>; the procedure itself</i>
((LAMBDA (X) (ADD X (QUOTE 2))) (QUOTE 14)) <i>; 16</i>
</pre>

<p>The <b>(LET exp pairs..)</b>, and <b>(LETREC exp pairs..)</b>, expressions can
associate pairs of values to an expression, given an expression with
declarations returns its value. The main difference between let and letrec is
that letrec's definitions are also visible in the expression itself.</p>

<pre>
(LETREC expr
	(expr LAMBDA (X Y)
		(CONS a (CONS b (QUOTE NIL)))
	)
	(a QUOTE A)
	(b QUOTE B)
	<i>(value2 . exp)</i>
	<i>(value3 . exp)</i>
	<i>...</i>
)
</pre>

<p>The <b>(EQ a b)</b> procedure results in a value either <b>T</b> or <b>F</b>
provided that the values of the expressions being compared are both atoms, and
either they are both the same number, or they are both the same symbol:</p>

<pre>
(LAMBDA (X) (EQ (QUOTE word) X))
</pre>

<p>Given three expressions, the <b>(IF true then that)</b> returns the value of
the second if the value of the first is True, otherwise returns the value of
the third. </p>

<pre>
(IF (EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16)
)
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Programs</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given
an expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry procedure. I will use the 位
shorthand for LAMBDA, and single-quote for QUOTE, which are part of the <a
href='https://git.sr.ht/~rabbits/lispkit/tree/master/item/utils/lispkit.lisp'
target='_blank'>extended Lispkit compiler</a>.</p>

<p>The <b>(PRINT exp)</b> procedure sends the textual representation of an
expression to the terminal. When an expression is made of a series of atoms, it
is interpreted as a list of words, otherwise the entire expression is printed.
If the symbol "Machiavelli" is used as argument, the program will evaluate to
the following output:</p>

<pre>
(位 (<i>INPUT</i>)
	(PRINT
		(CONS (' Hello)
		(CONS <i>INPUT</i>
		(CONS (' #Newline)
		(' nil))))
	)
) <i>; "Hello Machiavelli"</i>
</pre>

<p>Using everything we've seen so far, we can see a more elaborate program, in
which functions are organized as lambdas so they can be used in other parts of
the program as follows:</p>

<pre>
(LETREC <b>main</b>
	(<b>main</b> 位 (X)
		(PRINT
			(CONS (<b>fib</b> X)
			(CONS <b>linebreak</b>
			(' nil))))
	)
	(<b>fib</b> 位 (N)
		(IF (EQ N (' 0)) (' 0)
		(IF (EQ N (' 1)) (' 1)
			(+
				(<b>fib</b> (- N (' 1)))
				(<b>fib</b> (- N (' 2))))))
	)
	(<b>linebreak</b> ' #Newline)
)
</pre>

<img src='../media/refs/sicp.jpg' style='width:200px; float:right'/>

<q>Writing EVAL required inventing a notation representing Lisp functions as Lisp
data, and such a notation was devised for the purposes of the paper with no
thought that it would be used to express Lisp programs in practice. </q>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/lispkit' target='_blank'>Pure Lisp</a>, SECD virtual machine in ANSI C.</li>
	<li><a href='http://www.shido.info/lisp/idx_scm_e.html' target='_blank'>Scheme Tutorial</a></li>
	<li><a href='http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp' target='_blank'>Lisp Eval</a></li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

