<h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, operations use the <a href='notation.html'>prefix notation</a>.
<b>Function</b> names come after an open parenthesis followed by arguments, and
a closing parenthesis. <b>Atoms</b> are tokens in a list separated by spaces,
tabs or newlines. A pair of parentheses indicates one step of calculation.</p>

<pre>(<b>function</b> arg1 arg2 arg3)</pre>

<p>For the length of this page, I will use uppercase function names to indicate
built-in functions, and lowercase for user-defined functions. This page will
document a portable, lexically scoped, purely functional subset of Lisp,
sometimes called <i>Pure Lisp</i>, which does <b>not</b> allow for:</p>

<ul>
	<li>Unbound and global variables</li>
	<li>Destructive data operations.</li>
	<li>GOTOs, and side effects.</li>
	<li>Explicit pointers and dereferencing.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Data Types</h3>

<p>A <b>number</b> is a signed integer in a machine-specific finite range, and the
representation of a number is a sequence of decimal digits, optionally
preceded by a sign.</p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a finite sequence of characters, it is not
possible for the user to type symbols which begin as though they were numbers,
although digits may appear later in a symbol that begins with, say, a letter.
</p>

<pre>
Hello
Hello-world
x32 </pre>

<p>A <b>pair</b> consists of two component called the head and the tail. The
components of a pair may be any type of value, including pairs, so that pairing
may be used to construct arbitrarily large data structures. </p>

<pre>
(45.Hello)
(foo.bar)
(-12.(34.56))
</pre>

<p>A <b>function</b> is a value which may be applied to arguments, to yield a
value which depends only on the function and the arguments to which it is
applied. Given an expression, <b>quote(')</b> returns that expression as a value.</p>

<pre>
(QUOTE 12)
(REM (QUOTE 19) (QUOTE 24))
(MUL (QUOTE 2) (ADD (QUOTE 1) X))
</pre>

<h3>Prelude</h3>

<p>A <b>lambda(λ)</b> expression allows to name sub-expressions, given an argument
list and an expression, returns them as a function:</p>

<pre>
(LAMBDA (X Y) (SUB (ADD X Y) (QUOTE 2))
</pre>

<p>A <b>LET</b>, or <b>LETREC</b>, expression can associate pairs of values to an
expression, given an expression with declarations returns its value. The main
difference between LET and LETREC is that LETREC's defined symbols are
also visible in the expression itself.</p>

<pre>
(LETREC <b>is-eight</b>
	(<b>is-eight</b> LAMBDA (<i>INPUT</i>) (EQ <i>INPUT</i> target))
	(target QUOTE 8)
	<i>(value2 . exp)</i>
	<i>(value3 . exp)</i>
	<i>...</i>
)
</pre>

<p>The following expression has value <b>True(T)</b> if the value of the
expression is an <b>atom</b>, a number or a symbol, or has value
<b>False(F)</b> otherwise. </p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<p>The <b>equality</b> of two atomic expressions may be tested by an expression
of the following form, and result in a value either T or F provided that the
values of the expressions being compared are both atoms, and either they are
both the same number, or they are both the same symbol:</p>

<pre>
(LAMBDA (X) (EQ (QUOTE word) X))
</pre>

<p>Given three expressions <b>if</b> returns the value of the second if the value
of the first is True, otherwise returns the value of the third. </p>

<pre>
(IF (EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16)
)
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Program</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given an
expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry function. If the symbol
"Machiavelli" is used as argument, the program will evaluate to the following
pair:</p>

<pre>
(λ (<i>INPUT</i>) (CONS (' Hello) <i>INPUT</i>)) <i>; (Hello.Machiavelli)</i>
</pre>

<p>Typically, a program will have an entry function's name. For example, the
following program is wrapped into the factorial symbol:</p>

<pre>
(LETREC <b>factorial</b> (<b>factorial</b> λ (<i>INPUT</i>)
	(IF (EQ <i>INPUT</i> (' 0))
		(' 1)
		(* <i>INPUT</i> (<b>factorial</b> (- <i>INPUT</i> (' 1))))
	)
))
</pre>

<p>Using everything we've seen so far, we can see a more elaborate program, in
which functions are organized as lambdas so they can be used in other parts of
the program as follows:</p>

<pre>
(LETREC <b>main</b> (<b>main</b> λ (<i>INPUT</i>)
	(<b>loop</b> (' 0) <i>INPUT</i>))
	(<b>loop</b> λ (X Y)
		(IF (≤ X Y)
			(<b>loop</b> (<b>incr</b> X) Y)
			(CONS X (CONS Y (' NIL))))
		)
	(<b>incr</b> λ (X)
		(+ (' 1) X)
	)
)
</pre>

<img src='../media/refs/sicp.jpg' style='width:200px; float:right'/>

<q>Writing EVAL required inventing a notation representing Lisp functions as Lisp
data, and such a notation was devised for the purposes of the paper with no
thought that it would be used to express Lisp programs in practice. </q>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/lispkit' target='_blank'>Pure Lisp</a>, SECD virtual machine in ANSI C.</li>
	<li><a href='http://www.shido.info/lisp/idx_scm_e.html' target='_blank'>Scheme Tutorial</a></li>
	<li><a href='http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp' target='_blank'>Lisp Eval</a></li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

