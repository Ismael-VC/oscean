<h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, operations use the <a href='notation.html'>prefix notation</a>.
<b>Function</b> names come after an open parenthesis followed by arguments, and
a closing parenthesis. <b>Atoms</b> are tokens in a list separated by spaces,
tabs or newlines. A pair of parentheses indicates one step of calculation.</p>

<pre>(function arg1 arg2 arg3)</pre>

<p>For the length of this page, I will use uppercase function names to indicate
prefabs, and lowercase for user-defined functions. This page will document a
portable, lexically scoped, purely functional subset of Lisp, sometimes called
<i>Pure Lisp</i>, which does <b>not</b> allow for:</p>

<ul>
	<li>Unbound and global variables</li>
	<li>Destructive data operations.</li>
	<li>GOTOs, and side effects.</li>
	<li>Explicit pointers and dereferencing.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Data Types</h3>

<p>A <b>number</b> is a signed integer in a machine-specific finite range, and the
representation of a number is a sequence of decimal digits, optionally
preceded by a sign.</p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a finite sequence of characters, it is not
possible for the user to type symbols which begin as though they were numbers,
although digits may appear later in a symbol that begins with, say, a letter.
</p>

<pre>
Hello
Hello-world
x32 </pre>

<p>A <b>pair</b> consists of two component called the head and the tail. The
components of a pair may be any type of value, including pairs, so that pairing
may be used to construct arbitrarily large data structures. </p>

<pre>
( 45 . Hello )
( foo . bar )
( -12 . ( 34 . 56 ) )
</pre>

<p>A <b>function</b> is a value which may be applied to arguments, to yield a
value which depends only on the function and the arguments to which it is
applied. Given an expression, <b>quote</b> returns that expression as a value.</p>

<pre>
(QUOTE 12)
(REM (QUOTE 19) (QUOTE 24))
(MUL (QUOTE 2) (ADD (QUOTE 1) X))
</pre>

<h3>Prelude</h3>

<p>A <b>lambda</b> expression allows to name sub-expressions, given an argument
list and an expression, returns them as a function:</p>

<pre>
(LAMBDA (X Y) (ADD X Y))
</pre>

<p>Alternatively, the <b>let</b> expression can also associate a name to an
expression, given an expression with declarations (as named expressions visible
in the expression) returns its value:</p>

<pre>
(LET (QUOTE (aleph 1234)))
</pre>

<p>The following expression has value <b>True(T)</b> if the value of the
expression is an <b>atom</b>, a number or a symbol, or has value
<b>False(F)</b> otherwise. </p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<p>The <b>equality</b> of two atomic expressions may be tested by an expression
of the following form, and result in a value either T or F provided that the
values of the expressions being compared are both atoms, and either they are
both the same number, or they are both the same symbol:</p>

<pre>
(LAMBDA (X) (EQ (QUOTE foo) X))
</pre>

<p>Given three expressions <b>if</b> returns the value of the second if the value of the
first is True, otherwise returns the value of the third.</p>

<pre>
(IF
	(EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16))
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Program</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given an
expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry function. If the symbol
"Machiavelli" is used as argument, the program will evaluate to the following
pair:</p>

<pre>
(LAMBDA (<i>INPUT</i>)
	(CONS (QUOTE Hello) <i>INPUT</i>)) <i>; ( Hello . Machiavelli )</i>
</pre>

<p>Typically, a program will have an entry function's name. For example, the
previous program could be given a the name <code>greeting</code>. The main
difference between LET and LETREC is that, with LETREC, the defined symbols are
also visible in the expressions from the list of cons pairs, not just from the
main expression.</p>

<pre>
(LETREC <b>greeting</b>
	(<b>greeting</b> LAMBDA (<i>INPUT</i>)
		(CONS (QUOTE Hello) <i>INPUT</i>)))
</pre>

<p>Using everything we've seen so far, we can see a more elaborate program, in
which functions are organized as lambdas so they can be used in other parts of
the program as follows:</p>

<pre>
(LETREC <b>main</b>
	(<b>main</b> LAMBDA (<i>INPUT</i>)
		(<b>loop</b> (QUOTE 0) <i>INPUT</i>))
	(<b>loop</b> LAMBDA (X Y)
		(IF
			(LEQ X Y)
			(<b>loop</b> (<b>incr</b> X) Y)
			(CONS X (CONS Y (QUOTE NIL)))))
	(<b>incr</b> LAMBDA (X)
		(ADD (QUOTE 1) X))
)
</pre>

<q>Writing eval required inventing a notation representing Lisp functions as
Lisp data, and such a notation was devised for the purposes of the paper with
no thought that it would be used to express Lisp programs in practice. </q>

<ul>
	<li><a href='http://www.shido.info/lisp/idx_scm_e.html' target='_blank'>Scheme Tutorial</a></li>
	<li><a href='http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp' target='_blank'>Lisp Eval</a></li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

<img src='../media/refs/lmi.png' width='100'/>

