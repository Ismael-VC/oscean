<h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, a pair of parentheses indicates one step of calculation, operations
use the <a href='notation.html'>prefix notation</a>. This page will document a
portable, lexically scoped, purely functional subset of Lisp
that compiles to a <a href='secd.html'>virtual machine</a>. I will use
uppercase function names to indicate built-in functions, and lowercase for
user-defined functions. </p>

<ul>
	<li>The <a href='https://git.sr.ht/~rabbits/lispkit/tree/master/item/utils/lispkit.lisp' target='_blank'>self-hosted compiler</a> source.</li>
	<li>The <a href='https://git.sr.ht/~rabbits/lispkit/tree/master/item/src/secd.c' target='_blank'>virtual machine</a> runtine.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Atoms</h3>

<p>An <b>atom</b> is either a number or a symbol. A <b>number</b> is a signed
integer, its representation is a sequence of decimal digits, optionally
preceded by a sign. </p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a sequence of characters, it cannot begin
with a number or a sign, although these may appear later in a symbol. </p>

<pre>
Hello
Hello-world
x32 </pre>

<p>The <b>(ATOM exp)</b> procedure return True(<b>T</b>) if the value of the expression
is an atom or False(<b>F</b>) otherwise.</p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<h3>Pairs</h3>

<p>A <b>pair</b> joins two arbitrary values. The <b>(CONS a d)</b> procedure
constructs pairs, the <b>(CAR list)</b> procedure extracts the first elements of
the pair, and the <b>(CDR list)</b> procedure extracts the second.</p>

<pre>
(CONS (QUOTE foo) (QUOTE bar)) <i>; (foo.bar)</i>
(CDR (CONS (QUOTE foo) (QUOTE bar))) <i>; foo</i>
(CAR (CONS (QUOTE foo) (QUOTE bar))) <i>; bar</i>
</pre>

<p>A <b>list</b> is a chain of pair that are <i>cons-ed</i> onto one another, ending
with a <b>nil</b>.</p>

<pre>
(CONS (QUOTE a)
	(CONS (QUOTE b)
		(CONS (QUOTE c) (' NIL)))) <i>; [a,b,c]</i>
</pre>

<h3>Procedures</h3>


<p>The <b>(EQ a b)</b> procedure results in a value either <b>T</b> or <b>F</b>
provided that the values of the expressions being compared are both atoms, and
either they are both the same number, or they are both the same symbol:</p>

<pre>
(LAMBDA (X) (EQ (QUOTE word) X))
</pre>

<p>Given three expressions, the <b>(IF true then that)</b> returns the value of
the second if the value of the first is True, otherwise returns the value of
the third. </p>

<pre>
(IF (EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16)
)
</pre>

<p>A <b>(LAMBDA args exp)</b> expression evaluates to a procedure. The
environment which is in effect when a lambda expression is evaluated is
enclosed in the newly created procedure, this is referred to as a closure.
Given an expression, the <b>(QUOTE exp)</b> procedure returns that expression
as a value.</p>

<pre>
(LAMBDA (X) (ADD X (QUOTE 2))) <i>; the procedure itself</i>
((LAMBDA (X) (ADD X (QUOTE 2))) (QUOTE 14)) <i>; 16</i>
</pre>

<p>The <b>(LET exp pairs..)</b>, and <b>(LETREC exp pairs..)</b>, expressions can
associate pairs of values to an expression, given an expression with
declarations returns its value. The main difference between let and letrec is
that letrec's definitions are also visible in the expression itself.</p>

<pre>
(LETREC exp
	(exp LAMBDA (X Y)
		(CONS a (CONS b (QUOTE NIL)))
	)
	(a QUOTE A)
	(b QUOTE B)
	<i>(value2 . exp)</i>
	<i>(value3 . exp)</i>
	<i>...</i>
)
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Programs</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given
an expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry procedure.</p>

<article>
	<p>From here forward, I will use the λ shorthand for LAMBDA, and single-quote
for QUOTE, which are part of the <a
href='https://git.sr.ht/~rabbits/lispkit/tree/master/item/utils/lispkit.lisp'
target='_blank'>extended Lispkit compiler</a>.</p>
</article>

<p>The <b>(WRITE exp)</b> procedure sends an expression to be <a
href='secd.html#devices'>dispatched to a device</a>, by default, it is printing
the expression in the console. If the symbol "Machiavelli" is used as argument,
the program will evaluate to the following output:</p>

<pre>
(λ (<i>INPUT</i>)
	(WRITE (CONS (' Hello) <i>INPUT</i>))
) <i>; "(Hello.Machiavelli)"</i>
</pre>

<p>Prefixing the <a href='secd.html#write'>WRITE</a> expression with the
<code>:cli</code> symbol routes the expression to the <i>Command Line
Interface</i>, which handles printing text. The <code>#\Newline</code> sybol
gets converted to a linebreak during printing.</p>

<pre>
(LETREC <b>main</b>
	(<b>main</b> λ (<i>INPUT</i>)
		(<b>print-line</b> (<b>fib</b> <i>INPUT</i>))
	)
	(<b>fib</b> λ (N)
		(IF (EQ N (' 0)) (' 0)
		(IF (EQ N (' 1)) (' 1)
			(+
				(<b>fib</b> (- N (' 1)))
				(<b>fib</b> (- N (' 2))))))
	)
	(<b>print-line</b> λ (text)
		(WRITE
			(CONS (' :cli)
			(CONS text
			(CONS (' #\Newline)
			(' NIL))))
		)
	)
)
</pre>

<img src='../media/refs/sicp.jpg' style='width:200px; float:right'/>

<q>Writing EVAL required inventing a notation representing Lisp functions as Lisp
data, and such a notation was devised for the purposes of the paper with no
thought that it would be used to express Lisp programs in practice. </q>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/lispkit' target='_blank'>Pure Lisp</a>, SECD virtual machine in ANSI C.</li>
	<li><a href='http://www.shido.info/lisp/idx_scm_e.html' target='_blank'>Scheme Tutorial</a></li>
	<li><a href='http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp' target='_blank'>Lisp Eval</a></li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

