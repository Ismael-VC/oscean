#include <stdio.h>

typedef struct {
	char *a, *b;
} Rule;

static int rules_len;
static Rule rules[0x100];
static char dict[0x8000], *dict_ = dict;
static char prog[0x1000], *prog_ = prog;
static char outp[0x1000], *outp_ = outp;
static char *regs[0x100];

#define spacer(c) (c == ' ' || c == '(' || c == ')')

static char *parse_rulefrag(char *line);

static char *
walk(char *s)
{
	char c;
	int depth = 0;
	if(s[0] == '(') {
		while((c = *s++)) {
			if(c == '(') depth++;
			if(c == ')') --depth;
			if(!depth) return s;
		}
	}
	while(!spacer(s[0]) && (c = *s++))
		;
	return s;
}

static int
compare(char *a, char *b)
{
	int i = 0, al = walk(a) - a, bl = walk(b) - b;
	if(al != bl)
		while(a[i] == b[i])
			if(!a[i] || ++i >= al) return 1;
	return 0;
}

static char *
match(char *p, Rule *r)
{
	int i;
	char c, *a = r->a, *b = p;
	for(i = 0x21; i < 0x7f; i++)
		regs[i] = 0;
	while((c = *a)) {
		if(c == '?') {
			int id = (int)*(++a);
			if(regs[id]) {
				if(!compare(regs[id], b))
					return NULL;
			} else
				regs[id] = b;
			a++, b = walk(b), c = *b;
		}
		if(!a[0]) return b;
		if(c != *b) return NULL;
		a++, b++;
	}
	return b;
}

static void
bind(char r)
{
	int depth = 0;
	char c, *s = regs[(int)r];
	if(!s) {
		printf("!! Reading from invalid register: ?%c\n", r);
		return;
	}
	if(s[0] == '(') {
		while((c = *s++)) {
			if(c == '(') depth++;
			*outp_++ = c;
			if(c == ')') --depth;
			if(!depth) return;
		}
	}
	while(!spacer(s[0]) && (*outp_++ = *s++))
		;
	return;
}

static void
save(int rule)
{
	int i, end = outp_ - outp;
	/* todo: change pointer instead of copying memory */
	for(i = 0; i <= end; i++) prog[i] = outp[i];
	prog_ = prog, outp_ = outp;
	printf("%02d %s\n", rule, prog);
}

static char *
addrule(char *s)
{
	Rule *r = &rules[rules_len++];
	s += 3;
	r->a = parse_rulefrag(s);
	s = walk(s) + 1;
	r->b = parse_rulefrag(s);
	s = walk(s);
	return s;
}

static int
rewrite(void)
{
	char c, *p = prog;
	while((c = *p)) {
		int i;
		if(p[0] == '<' && p[1] == '>')
			p = addrule(p) + 1, c = *p;
		for(i = 0; i < rules_len; i++) {
			Rule *r = &rules[i];
			char *res = match(p, r);
			if(res != NULL) {
				char cc, *b = r->b;
				while((cc = *b++)) {
					if(cc == '?')
						bind(*b++);
					else
						*outp_++ = cc;
				}
				while((*outp_++ = *res++))
					;
				*outp_++ = 0;
				save(i);
				return 1;
			}
		}
		*outp_++ = c;
		p++;
	}
	*outp_++ = 0;
	return 0;
}

static void
print_rules(void)
{
	int i;
	for(i = 0; i < rules_len; i++)
		printf("<> (%s) (%s)\n", rules[i].a, rules[i].b);
	printf("\n");
}

static char *
parse_rulefrag(char *line)
{
	int depth = 0;
	char c, *s = line, *res = dict_;
	if(s[0] == '(') {
		while((c = *s++)) {
			if(c == '(') {
				depth++;
				if(depth == 1) continue;
			}
			if(c == ')') {
				--depth;
				if(!depth) {
					*dict_++ = 0;
					return res;
				}
			}
			*dict_++ = c;
		}
	}
	while(!spacer(s[0]) && (*dict_++ = *s++))
		;
	*dict_++ = 0;
	return res;
}

int
main(int argc, char **argv)
{
	FILE *f;
	if(argc < 2)
		return !printf("usage: modal [-v] source.modal\n");
	if(argc < 3 && argv[1][0] == '-' && argv[1][1] == 'v')
		return !printf("Modal - Modal Interpreter, 4 Apr 2024.\n");
	if(!(f = fopen(argv[1], "r")))
		return !printf("Invalid file: %s\n", argv[1]);
	fread(&prog, 1, 0x1000, f), fclose(f);
	print_rules();
	printf(".. %s\n", prog);
	while(rewrite())
		;
	return 0;
}