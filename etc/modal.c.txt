#include <stdio.h>

typedef struct {
	char *a, *b;
} Rule;

static int rules_len, direction = 0;
static Rule rules[0x100];
static char dict[0x8000], *dict_ = dict;
static char bank_a[0x1000], *prog_ = bank_a;
static char bank_b[0x1000], *outp_ = bank_b;
static char *regs[0x100];

#define spacer(c) (c == ' ' || c == '(' || c == ')' || c == 0)

static char *parse_rulefrag(char *line);

static char *
walk(char *s)
{
	char c;
	int depth = 0;
	if(s[0] == '(') {
		while((c = *s++)) {
			if(c == '(') depth++;
			if(c == ')') --depth;
			if(!depth) return s;
		}
	}
	while(!spacer(s[0]) && (c = *s++))
		;
	return s;
}

static int
compare(char *a, char *b)
{
	int i = 0, al = walk(a) - a, bl = walk(b) - b;
	if(al != bl) return 0;
	while(a[i] == b[i])
		if(!a[i] || ++i >= al) return 1;
	return 0;
}

static char *
match(char *p, Rule *r)
{
	int i;
	char c, *a = r->a, *b = p;
	for(i = 0x21; i < 0x7f; i++)
		regs[i] = 0;
	while((c = *a)) {
		if(c == '?') {
			int id = (int)*(++a);
			if(regs[id]) {
				if(!compare(regs[id], b))
					return NULL;
			} else
				regs[id] = b;
			a++, b = walk(b), c = *b;
		}
		if(!*a && spacer(*b)) return b;
		if(c != *b) return NULL;
		a++, b++;
	}
	return spacer(*b) ? b : NULL;
}

static int
bind(char r)
{
	int depth = 0;
	char c, *s = regs[(int)r];
	if(!s)
		return !printf("!! Reading from invalid register: ?%c\n", r);
	if(s[0] == '(') {
		while((c = *s++)) {
			if(c == '(') depth++;
			*outp_++ = c;
			if(c == ')') --depth;
			if(!depth) return 1;
		}
	}
	while(!spacer(s[0]) && (*outp_++ = *s++))
		;
	return 1;
}

static void
save(int rule)
{
	if((direction = !direction))
		prog_ = bank_b, outp_ = bank_a;
	else
		prog_ = bank_a, outp_ = bank_b;
	printf("%02d %s\n", rule, direction ? bank_b : bank_a);
}

static char *
parse_rulefrag(char *line)
{
	int depth = 0;
	char c, *s = line, *res = dict_;
	if(s[0] == '(') {
		while((c = *s++)) {
			if(c == '(') {
				depth++;
				if(depth == 1) continue;
			}
			if(c == ')') {
				--depth;
				if(!depth) {
					*dict_++ = 0;
					return res;
				}
			}
			*dict_++ = c;
		}
	}
	while(!spacer(s[0]) && (*dict_++ = *s++))
		;
	*dict_++ = 0;
	return res;
}

static char *
addrule(char *s)
{
	Rule *r = &rules[rules_len++];
	s += 3;
	r->a = parse_rulefrag(s);
	s = walk(s) + 1;
	r->b = parse_rulefrag(s);
	s = walk(s);
	return s;
}

static int
rewrite(void)
{
	char c, *p = direction ? bank_b : bank_a;
	while((c = *p)) {
		int i;
		if(p[0] == '<' && p[1] == '>')
			p = addrule(p) + 1, c = *p;
		if(p == bank_a || p == bank_b || spacer(*(p - 1))) {
			for(i = 0; i < rules_len; i++) {
				Rule *r = &rules[i];
				char *res = match(p, r);
				if(res != NULL) {
					char cc, *b = r->b;
					while((cc = *b++)) {
						if(cc == '?')
							bind(*b++);
						else
							*outp_++ = cc;
					}
					while((*outp_++ = *res++))
						;
					*outp_++ = 0;
					save(i);
					return 1;
				}
			}
		}
		*outp_++ = c;
		p++;
	}
	*outp_++ = 0;
	return 0;
}

static void
print_rules(void)
{
	int i;
	for(i = 0; i < rules_len; i++)
		printf("<> (%s) (%s)\n", rules[i].a, rules[i].b);
	printf("\n");
}

static int
parse_line(char *line)
{
	char c;
	if(line[0] == 0) return 1;
	if(line[0] == '<' && line[1] == '>')
		return !!addrule(line);
	while((c = *line++))
		*prog_++ = c;
	return 1;
}

static int
parse(char *path)
{
	FILE *f;
	char c, line[0x400], *line_ = line;
	if(!(f = fopen(path, "r")))
		return 0;
	while(f && fread(&c, 1, 1, f)) {
		if(c == 0xa)
			*line_++ = 0x00, parse_line(line), line_ = line;
		else if(line_ - line < 0x400)
			*line_++ = c;
	}
	*line_++ = 0x00, parse_line(line), line_ = line;
	fclose(f);
	return 1;
}

int
main(int argc, char **argv)
{
	if(argc < 2)
		return !printf("usage: modal [-v] source.modal\n");
	if(argc < 3 && argv[1][0] == '-' && argv[1][1] == 'v')
		return !printf("Modal - Modal Interpreter, 4 Apr 2024.\n");
	if(!parse(argv[1]))
		return !printf("Invalid Modal file: %s.\n", argv[1]);
	print_rules();
	printf(".. %s\n", bank_a);
	while(rewrite())
		;
	return 0;
}