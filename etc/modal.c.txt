#include <stdio.h>

typedef struct {
	unsigned int id, refs, ptr;
	char *a, *b, reg[8];
} Rule;

static int flip, quiet, cycles = 0x10000;
static Rule rules[0x1000], *rules_ = rules, lambda;
static char dict[0x8000], *dict_ = dict, empty;
static char bank_a[0x4000], *src_ = bank_a;
static char bank_b[0x4000], *dst_ = bank_b;

#define spacer(c) (c <= ' ' || c == '(' || c == ')')

static char *
walk(char *s)
{
	char c;
	int depth = 0;
	if(*s == '(') {
		while((c = *s++)) {
			if(c == '(') depth++;
			if(c == ')') --depth;
			if(!depth) return s;
		}
	}
	while((c = *s) && !spacer(c)) s++;
	return s;
}

static void
write_reg(char r, char *reg)
{
	char c, *cap = walk(reg);
	switch(r) {
	case ':': /* op: output */
		if(*reg == '(') reg++, --cap;
		while(reg < cap) {
			c = *reg++;
			if(c == '\\') {
				switch(*reg++) {
				case 't': putc(0x09, stdout); break;
				case 'n': putc(0x0a, stdout); break;
				case 's': putc(0x20, stdout); break;
				}
			} else
				putc(c, stdout);
		}
		return;
	case '~': { /* op: input */
		while(fread(&c, 1, 1, stdin) && c >= ' ')
			*dst_++ = c;
		if(feof(stdin))
			*dst_++ = 'E', *dst_++ = 'O', *dst_++ = 'F';
		return;
	}
	case '^': /* op: join */
		if(*reg == '(') reg++, --cap;
		while(reg < cap && (c = *reg++))
			if(!spacer(c)) *dst_++ = c;
		return;
	case '.': /* op: unwrap */
		if(*reg == '(') reg++, --cap;
		while(reg < cap) *dst_++ = *reg++;
		return;
	case '*': { /* op: explode */
		int i, depth = 0;
		if(*reg == '(' && reg[1] != ')') { /* tuple */
			reg++;
			while(reg < cap) {
				while((c = *reg) && !spacer(c))
					*dst_++ = c, reg++;
				*dst_++ = ' ';
				*dst_++ = '(', reg++, depth++;
			}
		} else /* token */
			while((c = *reg++) && !spacer(c))
				*dst_++ = c, *dst_++ = ' ', *dst_++ = '(', depth++;
		for(i = 0; i < depth; i++) *dst_++ = ')';
		return;
	}
	default:
		while(reg < cap) *dst_++ = *reg++;
		return;
	}
}

static int
write_tail(char *s)
{
	while((*dst_++ = *s++))
		;
	*dst_ = 0;
	if((flip = !flip))
		src_ = bank_b, dst_ = bank_a;
	else
		src_ = bank_a, dst_ = bank_b;
	return 1;
}

static int
apply_rule(Rule *r, char *s)
{
	unsigned int i, rid;
	char c, *a = r->a, *b = r->b, *origin = dst_, *reg, *regs[8];
	/* phase: clean regs */
	for(i = 0; i < r->ptr; i++)
		regs[i] = NULL;
	/* phase: match rule */
	while((c = *a++)) {
		if(c == '?') {
			char *pcap = walk(s);
			rid = *a++ - '0';
			if((reg = regs[rid])) { /* reg cmp */
				char *rcap = walk(reg), *pp = s;
				while(reg < rcap || pp < pcap)
					if(*reg++ != *pp++) return 0;
			} else /* reg set */
				regs[rid] = s;
			s = pcap;
		} else if(c != *s++)
			return 0;
	}
	c = *s;
	if(!spacer(c)) return 0;
	/* phase: write rule */
	while((c = *b++)) {
		if(c == '?') {
			rid = *b - '0';
			if(rid < 9 && (reg = regs[rid]))
				b++, write_reg(r->reg[rid], reg);
			else
				*dst_++ = c;
		} else
			*dst_++ = c;
	}
	if(dst_ == origin) {
		while(*s == ' ') s++;
		if(*s == ')' && *(dst_ - 1) == ' ') dst_--;
	}
	if(!quiet && r) printf("%02d %s\n", r->id, src_), ++r->refs;
	return write_tail(s);
}

static int
find_reg(Rule *r, char reg)
{
	int rid;
	for(rid = 0; rid < (int)r->ptr; rid++)
		if(r->reg[rid] == reg) return rid;
	return -1;
}

static char *
compile_rule(Rule *r, int id, char *src)
{
	char c, *cap;
	int wrapped, reg;
	r->id = id, r->ptr = 0, r->a = &empty, r->b = &empty;
	/* phase: compile left */
	while((c = *src) && c == ' ') src++;
	if(c == ')' || (c == '<' && src[1] == '>')) return src;
	r->a = dict_, cap = walk(src), wrapped = c == '(';
	if(wrapped) src++, cap--;
	while(src < cap) {
		c = *src, *dict_++ = *src++;
		if(c == '?') {
			c = *src++, reg = find_reg(r, c);
			if(reg == -1 && c != '(')
				r->reg[r->ptr] = c, reg = r->ptr++;
			*dict_++ = '0' + reg;
		}
	}
	src += wrapped, *dict_++ = 0;
	/* phase: compile right */
	while((c = *src) && c == ' ') src++;
	if(c == ')' || (c == '<' && src[1] == '>')) return src;
	r->b = dict_, cap = walk(src), wrapped = c == '(';
	if(wrapped) src++, cap--;
	while(src < cap) {
		c = *src, *dict_++ = *src++;
		if(c == '?') {
			c = *src++, reg = find_reg(r, c);
			*dict_++ = reg != -1 ? '0' + reg : c;
		}
	}
	src += wrapped, *dict_++ = 0;
	return src;
}

static Rule *
find_rule(char *s, char *cap)
{
	Rule *r = rules;
	if(*s == '(') s++, cap--;
	while(r < rules_) {
		char *ss = s, *a = r->a;
		while(*ss++ == *a++)
			if(!*a && ss == cap) return r;
		r++;
	}
	return r;
}

static void
echo_rule(Rule *r, char *s)
{
	char c;
	putc('(', stdout);
	while((c = *s++)) {
		unsigned int rid;
		putc(c, stdout);
		if(c == '?')
			c = *s++, rid = c - '0', putc(rid < 9 ? r->reg[rid] : c, stdout);
	}
	putc(')', stdout), putc(' ', stdout);
}

static int
rewrite(void)
{
	char c, last = 0, *cap, *s = src_;
	while(*s == ' ') s++;
	while((c = *s)) {
		if(c == '(' || spacer(last)) {
			Rule *r = NULL;
			/* phase: define */
			if(c == '<' && s[1] == '>') {
				r = rules_++;
				s = compile_rule(r, rules_ - rules - 1, s + 2);
				if(!quiet && r->a)
					printf("<> "), echo_rule(r, r->a), echo_rule(r, r->b), putc('\n', stdout);
				while(*s == ' ') s++;
				return write_tail(s);
			}
			/* phase: undefine */
			if(c == '>' && s[1] == '<') {
				s += 2;
				while(*s == ' ') s++;
				cap = walk(s), r = find_rule(s, cap);
				if(!quiet && r->a)
					printf(">< "), echo_rule(r, r->a), echo_rule(r, r->b), putc('\n', stdout);
				r->a = 0;
				while(*cap == ' ') cap++;
				return write_tail(cap);
			}
			/* phase: lambda */
			if(c == '?' && s[1] == '(') {
				cap = walk(s + 1), compile_rule(&lambda, -1, s + 2), s = cap;
				while(*s == ' ') s++;
				if(!apply_rule(&lambda, s)) write_tail(s);
				return 1;
			}
			/* phase: match */
			for(r = rules; r < rules_; r++)
				if(r->a && apply_rule(r, s)) return 1;
		}
		*dst_++ = last = c;
		s++;
	}
	*dst_++ = 0;
	return 0;
}

int
main(int argc, char **argv)
{
	FILE *f;
	int i, pl = 0, pr = 0, rw = 0;
	char c, last = 0, *w = bank_a;
	if(argc < 2)
		return !printf("usage: modal [-vqn] source.modal\n");
	for(i = 1; i < argc && *argv[i] == '-'; i++) {
		switch(argv[i][1]) {
		case 'v': /* version */ return !printf("Modal Interpreter, 27 Apr 2024.\n");
		case 'q': /* quiet */ quiet = 1; break;
		case 'n': /* infinite */ cycles = 0xffffffff; break;
		}
	}
	if(!(f = fopen(argv[i], "r")))
		return !printf("Modal file invalid: %s.\n", argv[i]);
	while(fread(&c, 1, 1, f)) {
		c = c <= 0x20 ? 0x20 : c;
		if(c == ' ' && last == '(') continue;
		if(c == ')' && last == ' ') w--;
		if(c == ' ' && last == ' ') w--;
		if(c == '(') pl++;
		if(c == ')') pr++;
		if(c == '(' && last != '?' && !spacer(last)) *w++ = ' ';
		if(last == ')' && !spacer(c)) *w++ = ' ';
		*w++ = last = c;
	}
	while(*(--w) <= ' ') *w = 0;
	fclose(f);
	if(pr != pl)
		return !printf("Modal program imbalanced.\n");
	while(rewrite() && ++rw)
		if(!cycles--) return !printf("Modal rewrites exceeded.\n");
	if(!quiet) {
		while(rules_-- > rules)
			if(!rules_->refs && rules_->a)
				printf("-- Unused rule: %d <> (%s) (%s)\n", rules_->refs, rules_->a, rules_->b);
		printf(".. %s\nCompleted in %d rewrites.\n", src_, rw);
	}
	return 0;
}