<!DOCTYPE html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../links/main.css" type="text/css" rel="stylesheet"><link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<title>XXIIVV &mdash; lisp</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>

<nav><ul><li><a href="programming_languages.html" class="parent">programming languages</a></li><li><a href="operating_systems.html">operating systems</a></li><li><a href="graphical_input.html">graphical input</a></li><li><a href="file_formats.html">file formats</a></li><li><a href="data_encoding.html">data encoding</a></li><li><a href="type_systems.html">type systems</a></li></ul><ul><li><a href="assembly.html">assembly</a></li><li><a href="forth.html">forth</a></li><li><a href="lisp.html" class="self">lisp</a></li><li><a href="basic.html">basic</a></li><li><a href="pascal.html">pascal</a></li><li><a href="ansi_c.html">ansi c</a></li><li><a href="postscript.html">postscript</a></li><li><a href="hypertalk.html">hypertalk</a></li></ul><ul><li><a href="secd.html">secd</a></li></ul></nav>
<main><h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, operations use the <a href='notation.html'>prefix notation</a>.
<b>Function</b> names come after an open parenthesis followed by arguments, and
a closing parenthesis. <b>Atoms</b> are tokens in a list separated by spaces,
tabs or newlines. A pair of parentheses indicates one step of calculation.</p>

<pre>(function arg1 arg2 arg3)</pre>

<p>For the length of this page, I will use uppercase function names to indicate
built-in functions, and lowercase for user-defined functions. This page will
document a portable, lexically scoped, purely functional subset of Lisp,
sometimes called <i>Pure Lisp</i>, which does <b>not</b> allow for:</p>

<ul>
	<li>Unbound and global variables</li>
	<li>Destructive data operations.</li>
	<li>GOTOs, and side effects.</li>
	<li>Explicit pointers and dereferencing.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Data Types</h3>

<p>A <b>number</b> is a signed integer in a machine-specific finite range, and the
representation of a number is a sequence of decimal digits, optionally
preceded by a sign.</p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a finite sequence of characters, it is not
possible for the user to type symbols which begin as though they were numbers,
although digits may appear later in a symbol that begins with, say, a letter.
</p>

<pre>
Hello
Hello-world
x32 </pre>

<p>A <b>pair</b> consists of two component called the head and the tail. The
components of a pair may be any type of value, including pairs, so that pairing
may be used to construct arbitrarily large data structures. </p>

<pre>
( 45 . Hello )
( foo . bar )
( -12 . ( 34 . 56 ) )
</pre>

<p>A <b>function</b> is a value which may be applied to arguments, to yield a
value which depends only on the function and the arguments to which it is
applied. Given an expression, <b>quote</b> returns that expression as a value.</p>

<pre>
(QUOTE 12)
(REM (QUOTE 19) (QUOTE 24))
(MUL (QUOTE 2) (ADD (QUOTE 1) X))
</pre>

<h3>Prelude</h3>

<p>A <b>lambda</b> expression allows to name sub-expressions, given an argument
list and an expression, returns them as a function:</p>

<pre>
(LAMBDA (X Y) (ADD X Y))
</pre>

<p>Alternatively, the <b>let</b> expression can also associate a name to an
expression, given an expression with declarations (as named expressions visible
in the expression) returns its value:</p>

<pre>
(LET (QUOTE (aleph 1234)))
</pre>

<p>The following expression has value <b>True(T)</b> if the value of the
expression is an <b>atom</b>, a number or a symbol, or has value
<b>False(F)</b> otherwise. </p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<p>The <b>equality</b> of two atomic expressions may be tested by an expression
of the following form, and result in a value either T or F provided that the
values of the expressions being compared are both atoms, and either they are
both the same number, or they are both the same symbol:</p>

<pre>
(LAMBDA (X) (EQ (QUOTE foo) X))
</pre>

<p>Given three expressions <b>if</b> returns the value of the second if the value of the
first is True, otherwise returns the value of the third.</p>

<pre>
(IF (EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16)
)
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Program</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given an
expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry function. If the symbol
"Machiavelli" is used as argument, the program will evaluate to the following
pair:</p>

<pre>
(LAMBDA (<i>INPUT</i>)
	(CONS (QUOTE Hello) <i>INPUT</i>)
) <i>; ( Hello . Machiavelli )</i>
</pre>

<p>Typically, a program will have an entry function's name. For example, the
previous program could be given a the name <code>greeting</code>. The main
difference between LET and LETREC is that, with LETREC, the defined symbols are
also visible in the expressions from the list of cons pairs, not just from the
main expression.</p>

<pre>
(LETREC <b>factorial</b>
	(<b>factorial</b> LAMBDA (<i>INPUT</i>)
		(IF (EQ <i>INPUT</i> (QUOTE 0))
			(QUOTE 1)
			(MUL <i>INPUT</i> (<b>factorial</b> (SUB <i>INPUT</i> (QUOTE 1))))
		)
	)
)
</pre>

<p>Using everything we've seen so far, we can see a more elaborate program, in
which functions are organized as lambdas so they can be used in other parts of
the program as follows:</p>

<pre>
(LETREC <b>main</b>
	(<b>main</b> LAMBDA (<i>INPUT</i>)
		(<b>loop</b> (QUOTE 0) <i>INPUT</i>)
	)
	(<b>loop</b> LAMBDA (X Y)
		(IF (LEQ X Y)
			(<b>loop</b> (<b>incr</b> X) Y)
			(CONS X (CONS Y (QUOTE NIL))))
		)
	(<b>incr</b> LAMBDA (X)
		(ADD (QUOTE 1) X)
	)
)
</pre>

<img src='../media/refs/sicp.jpg' style='width:200px; float:right'/>

<q>Writing EVAL required inventing a notation representing Lisp functions as Lisp
data, and such a notation was devised for the purposes of the paper with no
thought that it would be used to express Lisp programs in practice. </q>

<h3>Library Functions</h3>

<h4>List processing junctions</h4>
<ul>
	<li><code>(append e1 e2)</code> Is the list obtained by concatenation of its two arguments.</li>
	<li><code>(member e l)</code> is T if the atom e is present in the list l.</li>
	<li><code>(equal e1 e2)</code> tests the equality of two non-function data structures.</li>
	<li><code>(null e)</code> is T if e is NIL, and is F otherwise.</li>
	<li><code>(length l)</code> is the number of components in the list l.</li>
	<li><code>(first n l)</code> returns a prefix of the first n components of the list l, or the whole list if shorter.</li>
	<li><code>(1ist e1 ... en)</code> returns a list of its arguments.</li>
	<li><code>(transpose m)</code> is the matrix transposition of a list of lists m.</li>
</ul>

<h4>Logical operators</h4>
<ul>
	<li><code>(not c)</code> is T if c is F, and is F if c is T.</li>
	<li><code>(or cl c2)</code> is T if either of the arguments is T, and is F if both are F.</li>
	<li><code>(and cl c2)</code> is T if both of the arguments are T, and is F if either is F.</li>
	<li><code>(unless cl c2)</code> is an abbreviation for <code>(and (not c1) c2)</code>.</li>
</ul>

<h4>Stream operations</h4>
<ul>
	<li><code>(until e l)</code> is the list of components of the stream l which precede the first occurrence of the atom e.</li>
	<li><code>(untilend I)</code> abbreviates <code>(until (quote end) 1)</code>.</li>
	<li><code>(alter e I)</code> is the stream of eomponcnls of I which follow the first occurrence of the atom e.</li>
	<li><code>(aherend I)</code> abbreviates <code>(aher (quote end) I)</code>.</li>
</ul>

<h4>Commonly used higher order functions</h4>
<ul>
	<li><code>(map f l)</code> is the list whose components are obtained from those of l by application of f.</li>
	<li><code>(reduce f l z)</code> Is the continued applicalion of f over the list l with zero z, that is <code>(I (head l) (l (head (tail l)) (l··· z)···))</code>.</li>
	<li><code>(filter p l)</code> Is the list of those components c of l for which (p c) is T.</li>
	<li><code>(close r l)</code> is  the first value x in the sequence <code>I, (r l). (r (r l))</code>, for which <code>(equal x (r x))</code>.</li>
</ul>

<h4>Misc</h4>
<ul>
	<li><code>(number x)</code> Is T if x is a numeric atom. and F otherwise.</li>
	<li><code>(load_code c)</code> is the value represented by the code object c.</li>
	<li><code>(apply f I)</code> applies the funcllon f to the argument list I 
	<li><code>newline</code> an atom which prints as a line break.</li>
	<li><code>space</code> an atom which prints as a blank space.</li>
</ul>

<ul>
	<li><a href='http://www.shido.info/lisp/idx_scm_e.html' target='_blank'>Scheme Tutorial</a></li>
	<li><a href='http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp' target='_blank'>Lisp Eval</a></li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

<img src='../media/refs/lmi.png' width='100'/>

<h2>An abstract machine intended as a target for functional programming language
compilers.</h2>

<p>The SECD is a stack-based runtime with a core of 10 opcodes defined with a set
of transitions between its four components. Functions take their arguments from
the stack. The arguments to built-in instructions are encoded immediately after
them in the instruction stream. If <kbd>C</kbd> and <kbd>D</kbd> are both
empty, overall evaluation has completed with the result on <kbd>S</kbd>. </p>

<ul>
	<li><b>Stack</b> <kbd>S</kbd> register points to a list of intermediate results.</li>
	<li><b>Environment</b> <kbd>E</kbd> register points to the current environment.</li>
	<li><b>Control</b> <kbd>C</kbd> register points a location in the program.</li>
	<li><b>Dump</b> <kbd>D</kbd> register points to a list of triples. Each triple contains snapshots of the stack, environment, and control registers.</li>
</ul>

<p>The <code>.secd</code> representation of a program encodes the various parts
of a functional programming language into the abstract machine code, where each
opcode is represented as a number. For example, if we compile the <a
href='lisp.html'>Pure Lisp</a> program below:</p>

<pre>
<i>Pure Lisp:</i>       (LAMBDA (X) (ADD (QUOTE 1) X))
<i>SECD(opcodes):</i>   ( 3 ( 2 1 1 ( 0 . 0 ) 15 5 ) 4 21 )
<i>SECD(mnemonics):</i> ( LDF ( LDC 1 LD ( 0 . X ) ADD RTN ) AP BRK )</i>
</pre>

<table border='1'>
	<tr><th colspan='5'>Basic Instructions</th></tr>
	<tr><th rowspan='2'>0</th><th rowspan='2'>NIL</th><td>Creates an empty list on the top of the stack register.</td></tr>
	<tr><td>A nil is compiled to ( NIL ).</td></tr>
	<tr><th rowspan='2'>1</th><th rowspan='2'>LD</th><td>Pushes the value of a variable onto the stack. The variable is indicated by the argument, a pair.</td></tr>
	<tr><td>An identifier is compiled to ( LD ( i . j ) ). where ( i . j ) is an index the jth element of the ith sublist in the Environment stack.</td></tr>
	<tr><th rowspan='2'>2</th><th rowspan='2'>LDC</th><td>Loads a constant on the stack.</td></tr>
	<tr><td>A number, or a constant, x is compiled to ( LDC x ).</td></tr>
</table>

<p>Here are a few compilation examples: </p>

<pre>
(QUOTE A) <i>; (LDC A AP STOP)</i>
(LAMBDA (X) X) <i>; (LDF (LD (0.0) RTN) AP STOP)</i>
</pre>

<table border='1'>
	<tr><th colspan='5'>Stack Instructions</th></tr>
	<tr><th>3</th><th>LDF</th><td>Takes one list argument representing a function. It constructs a closure (a pair containing the function and the current environment) and pushes that onto the stack.</td></tr>
	<tr><th>4</th><th>AP</th><td>Pops a closure and a list of parameter values from the stack. The closure is applied to the parameters by installing its environment as the current one, pushing the parameter list in front of that, clearing the stack, and setting C to the closure's function pointer. The previous values of S, E, and the next value of C are saved on the dump.</td></tr>
	<tr><th>5</th><th>RTN</th><td>Pops one return value from the stack, restores S, E, and C from the dump, and pushes the return value onto the now-current stack.</td></tr>
</table>

<pre>
((lambda (x y) (+ x y)) 2 3) <i>; (NIL LDC 3 CONS LDC 2 CONS LDF (LD (1.2) LD (1.1) + RTN) AP)</i>
</pre>

<table border='1'>
	<tr><th colspan='5'>Recursive function instructions</th></tr>
	<tr><th>7</th><th>RAP</th><td>Works like a p ap, only that it replaces an occurrence of a dummy environment with the current one, thus making recursive functions possible</td></tr>
	<tr><th>6</th><th>DUM</th><td>Pushes a "dummy", an empty list, in front of the environment list.</td></tr>
	<tr><th colspan='5'>Branching instructions</th></tr>
	<tr><th>8</th><th>SEL</th><td>Expects two list arguments, and pops a value from the stack. The first list is executed if the popped value was non-nil, the second list otherwise. Before one of these list pointers is made the new C, a pointer to the instruction following s e l sel is saved on the dump.</td></tr>
	<tr><th>9</th><th>JOIN</th><td>Pops a list reference from the dump and makes this the new value of C. This instruction occurs at the end of both alternatives of a sel.</td></tr>
</table>

<pre>
(if (atom 5) 9 7) <i>; (LDC 5 ATOM SEL (LDC 9 JOIN) (LDC 7 JOIN))</i>
(lambda (x y) (+ x y)) <i>; (LDF (LD (1.2) LD (1.1) + RTN))</i>
</pre>

<table border='1'>
	<tr><th colspan='5'>Builtin Extensions</th></tr>
	<tr><th>10</th><th>CAR</th><td>Returns a pair's first value.</td></tr>
	<tr><th>11</th><th>CDR</th><td>Returns a pair's second value.</td></tr>
	<tr><th>12</th><th>ATOM</th><td>Returns T if its value is atomic.</td></tr>
	<tr><th>13</th><th>CONS</th><td>Returns a value pair consisting of two expressions.</td></tr>
	<tr><th colspan='5'>Builtin Arithmetic</th></tr>
	<tr><th>14</th><th>EQ</th><td>Returns T if two expressions are equal.</td></tr>
	<tr><th>15</th><th>ADD</th><td>Returns the sum of two numeric values.</td></tr>
	<tr><th>16</th><th>SUB</th><td>Returns the difference of two numeric values.</td></tr>
	<tr><th>17</th><th>MUL</th><td>Returns the product of two numeric values.</td></tr>
	<tr><th>18</th><th>DIV</th><td>Returns the quotient of two numeric values.</td></tr>
	<tr><th>19</th><th>REM</th><td>Returns the remainder of two numeric values.</td></tr>
	<tr><th>20</th><th>LEQ</th><td>Returns T if the first value is less or equal to the second.</td></tr>
</table>

<p>The compilation notation for builtins is reverse polish notation. To perform
an operation is to pop up the front element(s) from <kbd>s</kbd>, perform the
operation, and put the result back to <kbd>s</kbd>.</p>

<pre>
(ADD (QUOTE 123) (QUOTE 456)) <i>; ( LDC 123 LDC 456 ADD AP STOP )</i>
(MUL (ADD (QUOTE 12) (QUOTE 34)) (QUOTE 56)) <i>; ( LDC 12 LDC 34 ADD LDC 56 MUL AP STOP )</i>
</pre>

<p>Like all internal data-structures, the stack is a list, with the <kbd>S</kbd>
register pointing at the list's head. Due to the list structure, the stack need
not be a continuous block of memory, so stack space is available as long as
there is a single free memory cell. Even when all cells have been used, garbage
collection may yield additional free memory. </p>

<p>The current variable environment is managed by the <kbd>E</kbd> register, which
points at a list of lists. Each individual list represents one environment
level: the parameters of the current function are in the head of the list,
variables that are free in the current function, but bound by a surrounding
function, are in other elements of E.</p>

<p>The <kbd>C</kbd> register points at the head of the instruction list that will
be evaluated. Once the instruction there has been executed, the pointer is pointed at
the next instruction in the list. It is similar to an instruction pointer (or
program counter) in conventional machines, except that subsequent instructions
are always specified during execution and are not by default contained in
subsequent memory locations, as is the case with the conventional machines.</p>

<p>The <kbd>D</kbd> register, at whose head the register points, is used as
temporary storage for values of the other registers, for example during
function calls. It can be likened to the return stack of other machines. </p>

<table border='1'>
	<tr><th colspan='5'>Special Lispkit Opcodes</th></tr>
	<tr><th>21</th><th>STOP</th><td></td></tr>
	<tr><th colspan='5'>Deprecated Opcodes</th></tr>
	<tr><th>22</th><th>LDE</th><td></td></tr>
	<tr><th>23</th><th>UPD</th><td>(v) e' (UPD) (5 e c.d) -> rplaca(s,v) e c d</td></tr>
	<tr><th>24</th><th>AP0</th><td>s e (READ.c) d -> (x.s) e c d</td></tr>
	<tr><th>25</th><th>READ</th><td>s e (READ.c) d -> (x.s) e c d</td></tr>
	<tr><th>26</th><th>PRINT</th><td>(\I.s) e (PRINT.c) d -> sec d</td></tr>
	<tr><th>27</th><th>IMPLODE/CHR</th><td>(n.s) e (CHR.c) d -> (an.s) e cd</td></tr>
	<tr><th>28</th><th>EXPLODE</th><td></td></tr>
	<tr><th>31</th><th>OR</th><td></td></tr>
	<tr><th>32</th><th>NONE</th><td></td></tr>
	<tr><th>33</th><th>DELAY</th><td></td></tr>
	<tr><th>34</th><th>DELAY(2)</th><td></td></tr>
	<tr><th>35</th><th>FORCE</th><td></td></tr>
	<tr><th>41</th><th>RPLACA</th><td></td></tr>
	<tr><th>42</th><th>RPLACD</th><td></td></tr>
	<tr><th>51</th><th>PRINT</th><td></td></tr>
</table>


<p>This is a work in progress.</p>


<ul></ul><p class="incoming"><b>incoming</b> <a href="ronin.html">ronin</a> <a href="lain.html">lain</a> <a href="secd.html">secd</a> </p></main>
<footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a> <a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a> <a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a> <a href="ethics.html"><img src="../media/icon/dreipfeile.svg" alt="NoNazis!"/></a> <a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a> <span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2023 &mdash; <a href="about.html#license">BY-NC-SA 4.0</a></span></footer>
</body></html>