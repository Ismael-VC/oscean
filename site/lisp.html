<!DOCTYPE html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../links/main.css" type="text/css" rel="stylesheet"><link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<title>XXIIVV &mdash; lisp</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>

<nav><ul><li><a href="programming_languages.html" class="parent">programming languages</a></li><li><a href="operating_systems.html">operating systems</a></li><li><a href="graphical_input.html">graphical input</a></li><li><a href="file_formats.html">file formats</a></li><li><a href="data_encoding.html">data encoding</a></li><li><a href="type_systems.html">type systems</a></li></ul><ul><li><a href="assembly.html">assembly</a></li><li><a href="forth.html">forth</a></li><li><a href="lisp.html" class="self">lisp</a></li><li><a href="basic.html">basic</a></li><li><a href="pascal.html">pascal</a></li><li><a href="ansi_c.html">ansi c</a></li><li><a href="postscript.html">postscript</a></li><li><a href="hypertalk.html">hypertalk</a></li></ul><ul><li><a href="lisp_library.html">lisp library</a></li><li><a href="church_encoding.html">church encoding</a></li></ul></nav>
<main><h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, a pair of parentheses indicates one step of calculation, operations
use the <a href='notation.html'>prefix notation</a>. This page will document a
portable, lexically scoped, purely functional subset of Lisp
that compiles to a <a href='secd.html'>virtual machine</a>. I will use
uppercase function names to indicate built-in functions, and lowercase for
user-defined functions. </p>

<ul>
	<li>The <a href='https://git.sr.ht/~rabbits/lispkit/tree/master/item/utils/lispkit.lisp' target='_blank'>self-hosted compiler</a> source.</li>
	<li>The <a href='https://git.sr.ht/~rabbits/lispkit/tree/master/item/src/secd.c' target='_blank'>virtual machine</a> runtine.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Atoms</h3>

<p>An <b>atom</b> is either a number or a symbol. A <b>number</b> is a signed
integer, its representation is a sequence of decimal digits, optionally
preceded by a sign. </p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a sequence of characters, it cannot begin
with a number or a sign, although these may appear later in a symbol. </p>

<pre>
Hello
Hello-world
x32 </pre>

<p>The <kbd>(ATOM exp)</kbd> procedure return True(<b>T</b>) if the value of the expression
is an atom or False(<b>F</b>) otherwise.</p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<h3>Pairs</h3>

<p>A <b>pair</b> joins two arbitrary values. The <kbd>(CONS a d)</kbd> procedure
constructs pairs, the <kbd>(CAR list)</kbd> procedure extracts the first elements of
the pair, and the <kbd>(CDR list)</kbd> procedure extracts the second.</p>

<pre>
(CONS (QUOTE foo) (QUOTE bar)) <i>; (foo.bar)</i>
(CAR (CONS (QUOTE foo) (QUOTE bar))) <i>; foo</i>
(CDR (CONS (QUOTE foo) (QUOTE bar))) <i>; bar</i>
</pre>

<p>A <b>list</b> is a chain of pair that are <i>cons-ed</i> onto one another, ending
with a <b>nil</b>.</p>

<pre>
(CONS (QUOTE a)
	(CONS (QUOTE b)
		(CONS (QUOTE c) (' NIL)))) <i>; (a b c.NIL)</i>
</pre>

<h3>True & False</h3>

<p>The <kbd>(EQ a b)</kbd> procedure results in a value either T or F provided
that the values of the expressions being compared are both atoms, and either
they are both the same number, or they are both the same symbol:</p>

<pre>
(EQ (QUOTE (a)) (QUOTE (a))) <i>; F</i>
(EQ (QUOTE 42) (QUOTE foo)) <i>; F</i>
(EQ (QUOTE 42) (QUOTE 42)) <i>; T</i>
(EQ (QUOTE foo) (QUOTE foo)) <i>; T</i>
</pre>

<p>Given three expressions, the <kbd>(IF test exp2 exp3)</kbd> returns the value
of the second if the value of the expression test is T, otherwise returns the
value of the third. </p>

<pre>
(IF (EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16)
)
</pre>

<h3>Procedures</h3>

<p>A <kbd>(LAMBDA args exp)</kbd> expression evaluates to a procedure. The
environment which is in effect when a lambda expression is evaluated is
enclosed in the newly created procedure, this is referred to as a closure.
Given an expression, the <kbd>(QUOTE exp)</kbd> procedure returns that
expression as a value.</p>

<pre>
(LAMBDA (X) (ADD X (QUOTE 2))) <i>; the procedure itself</i>
((LAMBDA (X) (ADD X (QUOTE 2))) (QUOTE 14)) <i>; 16</i>
</pre>

<p>The <kbd>(LET exp [pairs])</kbd>, and <kbd>(LETREC exp [pairs])</kbd>,
expressions can associate pairs of values to an expression, given an expression
with declarations returns its value. The main difference between let and letrec
is that letrec's definitions are also visible in the expression itself.</p>

<pre>
(LETREC name
	(name LAMBDA (X Y)
		(ADD value1 value2)
	)
	(value1 QUOTE 123)
	(value2 QUOTE 456)
	<i>...</i>
)
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Programs</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given
an expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry procedure.</p>

<article>
	<p>From here forward, I will use the λ shorthand for LAMBDA, and single-quote
for QUOTE, which are part of the <a
href='https://git.sr.ht/~rabbits/lispkit/tree/master/item/utils/lispkit.lisp'
target='_blank'>extended Lispkit compiler</a>.</p>
</article>

<p>The <kbd>(WRITE exp)</kbd> procedure sends an expression to be <a
href='secd.html#devices'>dispatched to a device</a>, by default, it is printing
the expression in the console. If the symbol "Machiavelli" is used as argument,
the program will evaluate to the following output:</p>

<pre>
(λ (<i>INPUT</i>)
	(WRITE (CONS (' Hello) <i>INPUT</i>))
) <i>; "(Hello.Machiavelli)"</i>
</pre>

<p>Prefixing the <a href='secd.html#write'>WRITE</a> expression with the
<code>:cli</code> symbol routes the expression to the <i>Command Line
Interface</i>, which handles printing text. The <code>#\Newline</code> sybol
gets converted to a linebreak during printing.</p>

<pre>
(LETREC <b>main</b>
	(<b>main</b> λ (<i>INPUT</i>)
		(<b>print-line</b> (<b>fib</b> <i>INPUT</i>))
	)
	(<b>fib</b> λ (N)
		(IF (EQ N (' 0)) (' 0)
		(IF (EQ N (' 1)) (' 1)
			(+
				(<b>fib</b> (- N (' 1)))
				(<b>fib</b> (- N (' 2))))))
	)
	(<b>print-line</b> λ (text)
		(WRITE
			(CONS (' :cli)
			(CONS text
			(CONS (' #\Newline)
			(' NIL))))
		)
	)
)
</pre>

<h3>Summary</h3>

<ul>
	<li><kbd>(LAMBDA args exp)</kbd> Result exp with args bindings.</li>
	<li><kbd>(LET exp [pairs])</kbd> Result of exp with pairs bindings.</li>
	<li><kbd>(LETREC exp [pairs])</kbd> Result of exp with rec. with pairs bindings.</li>
	<li><kbd>(IF test exp2 exp3)</kbd> Result of exp2 if test is T, else exp3.</li>
	<li><kbd>(ATOM exp)</kbd> Returns T when exp is atom, else F.</li>
	<li><kbd>(QUOTE exp)</kbd> Returns the exp as a value.</li>
	<li><kbd>(CAR exp)</kbd> Returns a pair's first value.</li>
	<li><kbd>(CDR exp)</kbd> Returns a pair's second value.</li>
	<li><kbd>(CONS exp1 exp2)</kbd> Returns a pair of exp1 consed on exp2.</li>
	<li><kbd>(EQ atom atom)</kbd> Returns T if two expressions are equal.</li>
	<li><kbd>(ADD num num)</kbd> Returns the sum of two numeric values.</li>
	<li><kbd>(SUB num num)</kbd> Returns the difference of two numeric values.</li>
	<li><kbd>(MUL num num)</kbd> Returns the product of two numeric values.</li>
	<li><kbd>(DIV num num)</kbd> Returns the quotient of two numeric values.</li>
	<li><kbd>(REM num num)</kbd> Returns the remainder of two numeric values.</li>
	<li><kbd>(LEQ num num)</kbd> Returns T if the first is less or equal to the second.</li>
	<li><kbd>(WRITE exp)</kbd> Sends expression to a device, returns expression.</li>
	<li><kbd>(IMPLODE exp)</kbd> Returns a symbol from a symbol.</li>
	<li><kbd>(EXPLODE exp)</kbd> Returns a list from a symbol.</li>
</ul>

<img src='../media/refs/sicp.jpg' style='width:200px; float:right'/>

<q>Writing EVAL required inventing a notation representing Lisp functions as Lisp
data, and such a notation was devised for the purposes of the paper with no
thought that it would be used to express Lisp programs in practice. </q>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/lispkit' target='_blank'>Lispkit</a>, SECD virtual machine in ANSI C.</li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

<h2>Standard Functions</h2>

<p>The following is a collection of implementations for standard functions in <a
href='lisp.html'>Pure Lisp</a>. Predicate functions suffixed with
<code>?</code> are expressions that return either T or F.</p>

<ul>
	<li><code>(null? x)</code> is T if x is NIL, and is F otherwise.</li>
	<li><code>(not? x)</code>, T if x is F, else T.</li>
	<li><code>(or? x y)</code>, T if either arguments are T, else F.</li>
	<li><code>(and? x y)</code>, T if both arguments are T, else F.</li>
</ul>

<pre>
(<b>null?</b> λ (X) (EQ X (' NIL)))
(<b>true?</b> λ (X) (IF X (' T) (' F)))
(<b>not?</b> λ (X) (IF X (' F) (' T)))
(<b>or?</b> λ (X Y) (IF X (' T) (true? Y)))
(<b>and?</b> λ (X Y) (IF X (true? Y) (' F)))
</pre>

<h3>List Processing Functions</h3>

<p><b>Length</b> is the number of components in the list <code>l</code>.</p>

<pre>
(<b>length</b> λ (L)
	(IF (ATOM L)
		(' 1)
		(+ (' 1) (<b>length</b> (CDR L)))
	)
)
</pre>

<ul>
	<li><code>(append e1 e2)</code> Is the list obtained by concatenation of its two arguments.</li>
	<li><code>(member e l)</code> is T if the atom e is present in the list l.</li>
	<li><code>(equal e1 e2)</code> tests the equality of two non-function data structures.</li>
	<li><code>(first n l)</code> returns a prefix of the first n components of the list l, or the whole list if shorter.</li>
	<li><code>(list e1 ... en)</code> returns a list of its arguments.</li>
	<li><code>(transpose m)</code> is the matrix transposition of a list of lists m.</li>
</ul>

<h3>Common Higher-order Functions</h3>

<p><b>Map</b> is the list whose components are obtained from those of <code>l</code> by application of <code>fn</code>.</p>
<pre>
(<b>map</b> λ (Fn L)
	(IF (ATOM L)
		(' NIL)
		(CONS (Fn (CAR L)) (<b>map</b> Fn (CDR L)))
	)
)
</pre>

<p><b>Filter</b> is the list of those components for which the application of <code>fn</code> is T.</p>
<pre>
(<b>filter</b> λ (Fn L)
	(IF (ATOM L)
		(' NIL)
		(IF (Fn (CAR L))
			(CONS (CAR L) (<b>filter</b> Fn (CDR L)))
			(<b>filter</b> Fn (CDR L))
		)
	)
)
</pre>

<ul>
	<li><code>(reduce f l z)</code> Is the continued applicalion of f over the list l with zero z, that is <code>(I (head l) (l (head (tail l)) (l··· z)···))</code>.</li>
	<li><code>(close r l)</code> is the first value x in the sequence <code>I, (r l). (r (r l))</code>, for which <code>(equal x (r x))</code>.</li>
</ul>

<img src='../media/refs/chine_nual.png' width='120'/>

<h2>Church Numerals are a representation of the natural numbers using lambda
notation.</h2>

<p>A kind of <i>base1 arithmetic</i>, in which numbers are represented by
function nesting over an empty list, can be constructed in <a
href='lisp.html'>Pure Lisp</a> using only very few primtives. This document
will present Church Numerals through the lens of Lisp, alternatively one might
prefer to read it coming from the <a href='ornithomicon.html'>Avian
Numerals</a> tutorial.</p>

<p>The following file contains the basic building blocks as an example:</p>

<pre>
(LETREC church
	(church LAMBDA (INPUT)
		(greater?
			(incr (incr (incr (incr nil))))
			(incr (incr (incr nil))))
	)
	(nil QUOTE NULL)
	(#f QUOTE F)
	(#t QUOTE T)
	(incr LAMBDA (x)
		(CONS nil x))
	(decr LAMBDA (x)
		(CDR x))
	(zero? LAMBDA (x)
		(EQ x nil))
	(not LAMBDA (x)
		(IF x #f #t))
	(plus LAMBDA (x y)
		(IF (zero? x) y
			(plus (decr x) (incr y))))
	(minus LAMBDA (x y)
		(IF (zero? y) x
			(minus (decr x) (decr y))))
	(multiply LAMBDA (x y)
		(IF (zero? x) nil
			(plus y (multiply (decr x) y))))
	(equal? LAMBDA (x y)
		(IF (zero? x) (zero? y)
			(IF (zero? y) #f
				(equal? (decr x) (decr y)))))
	(greater? LAMBDA (x y)
		(IF (zero? x) #f
			(IF (zero? y) (not (zero? x))
				(greater? (decr x) (decr y)))))
	(lesser? LAMBDA (x y)
		(greater? y x))
)
</pre>

<ul></ul><p class="incoming"><b>incoming</b> <a href="ronin.html">ronin</a> <a href="lain.html">lain</a> <a href="lisp_library.html">lisp library</a> <a href="church_encoding.html">church encoding</a> <a href="secd.html">secd</a> </p></main>
<footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a> <a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a> <a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a> <a href="ethics.html"><img src="../media/icon/dreipfeile.svg" alt="NoNazis!"/></a> <a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a> <span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2023 &mdash; <a href="about.html#license">BY-NC-SA 4.0</a></span></footer>
</body></html>