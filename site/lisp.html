<!DOCTYPE html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../links/main.css" type="text/css" rel="stylesheet"><link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<title>XXIIVV &mdash; lisp</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>

<nav><ul><li><a href="programming_languages.html" class="parent">programming languages</a></li><li><a href="operating_systems.html">operating systems</a></li><li><a href="graphical_input.html">graphical input</a></li><li><a href="file_formats.html">file formats</a></li><li><a href="data_encoding.html">data encoding</a></li><li><a href="type_systems.html">type systems</a></li></ul><ul><li><a href="assembly.html">assembly</a></li><li><a href="forth.html">forth</a></li><li><a href="lisp.html" class="self">lisp</a></li><li><a href="basic.html">basic</a></li><li><a href="pascal.html">pascal</a></li><li><a href="ansi_c.html">ansi c</a></li><li><a href="postscript.html">postscript</a></li><li><a href="hypertalk.html">hypertalk</a></li></ul><ul><li><a href="lisp_library.html">lisp library</a></li><li><a href="church_encoding.html">church encoding</a></li></ul></nav>
<main><h2>A common trait of all dialects of LISP is the S-expression.</h2>

<p>In Lisp, operations use the <a href='notation.html'>prefix notation</a>.
<b>Function</b> names come after an open parenthesis followed by arguments, and
a closing parenthesis. <b>Atoms</b> are tokens in a list separated by spaces,
tabs or newlines. A pair of parentheses indicates one step of calculation.</p>

<pre>(<b>function</b> arg1 arg2 arg3)</pre>

<p>For the length of this page, I will use uppercase function names to indicate
built-in functions, and lowercase for user-defined functions. This page will
document a portable, lexically scoped, purely functional subset of Lisp,
sometimes called <i>Pure Lisp</i>, which does <b>not</b> allow for:</p>

<ul>
	<li>Unbound and global variables</li>
	<li>Destructive data operations.</li>
	<li>GOTOs, and side effects.</li>
	<li>Explicit pointers and dereferencing.</li>
</ul>

<figure>
	<img src='../media/refs/vogue-lisp.jpg' width='300'/>
	<figcaption>&mdash; Typical Lisp Programmer</figcaption>
</figure>

<h3>Data Types</h3>

<p>A <b>number</b> is a signed integer in a machine-specific finite range, and the
representation of a number is a sequence of decimal digits, optionally
preceded by a sign.</p>

<pre>
45
+137
-27</pre>

<p>A <b>symbol</b> is represented by a finite sequence of characters, it is not
possible for the user to type symbols which begin as though they were numbers,
although digits may appear later in a symbol that begins with, say, a letter.
</p>

<pre>
Hello
Hello-world
x32 </pre>

<p>A <b>pair</b> consists of two component called the head and the tail. The
components of a pair may be any type of value, including pairs, so that pairing
may be used to construct arbitrarily large data structures. </p>

<pre>
(45.Hello)
(foo.bar)
(-12.(34.56))
</pre>

<p>A <b>function</b> is a value which may be applied to arguments, to yield a
value which depends only on the function and the arguments to which it is
applied. Given an expression, <b>quote(')</b> returns that expression as a value.</p>

<pre>
(QUOTE 12)
(REM (QUOTE 19) (QUOTE 24))
(MUL (QUOTE 2) (ADD (QUOTE 1) X))
</pre>

<h3>Prelude</h3>

<p>A <b>lambda(λ)</b> expression allows to name sub-expressions, given an argument
list and an expression, returns them as a function:</p>

<pre>
(LAMBDA (X Y) (SUB (ADD X Y) (QUOTE 2))
</pre>

<p>A <b>LET</b>, or <b>LETREC</b>, expression can associate pairs of values to an
expression, given an expression with declarations returns its value. The main
difference between LET and LETREC is that LETREC's defined symbols are
also visible in the expression itself.</p>

<pre>
(LETREC <b>is-eight</b>
	(<b>is-eight</b> LAMBDA (<i>INPUT</i>) (EQ <i>INPUT</i> target))
	(target QUOTE 8)
	<i>(value2 . exp)</i>
	<i>(value3 . exp)</i>
	<i>...</i>
)
</pre>

<p>The following expression has value <b>True(T)</b> if the value of the
expression is an <b>atom</b>, a number or a symbol, or has value
<b>False(F)</b> otherwise. </p>

<pre>
(ATOM (QUOTE 12)) <i>; T</i>
(ATOM (CONS (QUOTE 12) (QUOTE 34))) <i>; F</i>
</pre>

<p>The <b>equality</b> of two atomic expressions may be tested by an expression
of the following form, and result in a value either T or F provided that the
values of the expressions being compared are both atoms, and either they are
both the same number, or they are both the same symbol:</p>

<pre>
(LAMBDA (X) (EQ (QUOTE word) X))
</pre>

<p>Given three expressions <b>if</b> returns the value of the second if the value
of the first is True, otherwise returns the value of the third. </p>

<pre>
(IF (EQ (QUOTE 16) X)
	(QUOTE EQUAL16)
	(QUOTE NOT-EQUAL16)
)
</pre>

<img src='../media/refs/sexp.png'/>

<h3>Program</h3>

<p>A program is either a LET, LETREC or LAMBDA expression. The program is given an
expression from the <i>outside world</i>, that we will call <i>INPUT</i> to
make explicit that this is our program entry function. If the symbol
"Machiavelli" is used as argument, the program will evaluate to the following
pair:</p>

<pre>
(λ (<i>INPUT</i>) (CONS (' Hello) <i>INPUT</i>)) <i>; (Hello.Machiavelli)</i>
</pre>

<p>Typically, a program will have an entry function's name. For example, the
following program is wrapped into the factorial symbol:</p>

<pre>
(LETREC <b>factorial</b> (<b>factorial</b> λ (<i>INPUT</i>)
	(IF (EQ <i>INPUT</i> (' 0))
		(' 1)
		(* <i>INPUT</i> (<b>factorial</b> (- <i>INPUT</i> (' 1))))
	)
))
</pre>

<p>Using everything we've seen so far, we can see a more elaborate program, in
which functions are organized as lambdas so they can be used in other parts of
the program as follows:</p>

<pre>
(LETREC <b>main</b> (<b>main</b> λ (<i>INPUT</i>)
	(<b>loop</b> (' 0) <i>INPUT</i>))
	(<b>loop</b> λ (X Y)
		(IF (≤ X Y)
			(<b>loop</b> (<b>incr</b> X) Y)
			(CONS X (CONS Y (' NIL))))
		)
	(<b>incr</b> λ (X)
		(+ (' 1) X)
	)
)
</pre>

<img src='../media/refs/sicp.jpg' style='width:200px; float:right'/>

<q>Writing EVAL required inventing a notation representing Lisp functions as Lisp
data, and such a notation was devised for the purposes of the paper with no
thought that it would be used to express Lisp programs in practice. </q>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/lispkit' target='_blank'>Pure Lisp</a>, SECD virtual machine in ANSI C.</li>
	<li><a href='http://www.shido.info/lisp/idx_scm_e.html' target='_blank'>Scheme Tutorial</a></li>
	<li><a href='http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp' target='_blank'>Lisp Eval</a></li>
	<li><a href='http://www.cb1.com/~john/thesis/thesis.html' target='_blank'>A Lisp through the Looking Glass</a></li>
</ul>

<h2>Standard Functions</h2>

<p>The following is a collection of implementations for standard functions in <a
href='lisp.html'>Pure Lisp</a>. Predicate functions are expressions that
return either true or false, they will be suffixed with <code>?</code>.</p>

<ul>
	<li><code>(null? x)</code> is T if x is NIL, and is F otherwise.</li>
	<li><code>(not? x)</code>, T if x is F, else T.</li>
	<li><code>(or? x y)</code>, T if either arguments are T, else F.</li>
	<li><code>(and? x y)</code>, T if both arguments are T, else F.</li>
	<li><code>(unless? x y)</code>, abbreviation for <code>(and (not x) y)</code>.</li>
</ul>

<pre>
(<b>null?</b> λ (X) (EQ X (' NIL)))
(<b>not?</b> λ (X) (IF X (' F) (' T)))
(<b>or?</b> λ (X Y) (IF X (' T) Y))
(<b>and?</b> λ (X Y) (IF X Y (' F)))
(<b>unless?</b> λ (X Y) (IF X (' F) Y))
</pre>

<h3>List Processing Functions</h3>
<p><b>Length</b> is the number of components in the list <code>l</code>.</p>
<pre>
(<b>length</b> λ (L)
	(IF (ATOM L)
		(' 1)
		(+ (' 1) (<b>length</b> (CDR L)))
	)
)
</pre>

<ul>
	<li><code>(append e1 e2)</code> Is the list obtained by concatenation of its two arguments.</li>
	<li><code>(member e l)</code> is T if the atom e is present in the list l.</li>
	<li><code>(equal e1 e2)</code> tests the equality of two non-function data structures.</li>
	<li><code>(first n l)</code> returns a prefix of the first n components of the list l, or the whole list if shorter.</li>
	<li><code>(1ist e1 ... en)</code> returns a list of its arguments.</li>
	<li><code>(transpose m)</code> is the matrix transposition of a list of lists m.</li>
</ul>

<h3>Common Higher-order Functions</h3>

<p><b>Map</b> is the list whose components are obtained from those of <code>l</code> by application of <code>fn</code>.</p>
<pre>
(<b>map</b> λ (Fn L)
	(IF (ATOM L)
		(' NIL)
		(CONS (Fn (CAR L)) (<b>map</b> Fn (CDR L)))
	)
)
</pre>

<p><b>Filter</b> is the list of those components for which the application of <code>fn</code> is T.</p>
<pre>
(<b>filter</b> λ (Fn L)
	(IF (ATOM L)
		(' NIL)
		(IF (Fn (CAR L))
			(CONS (CAR L) (<b>filter</b> Fn (CDR L)))
			(<b>filter</b> Fn (CDR L))
		)
	)
)
</pre>

<ul>
	<li><code>(reduce f l z)</code> Is the continued applicalion of f over the list l with zero z, that is <code>(I (head l) (l (head (tail l)) (l··· z)···))</code>.</li>
	<li><code>(close r l)</code> is the first value x in the sequence <code>I, (r l). (r (r l))</code>, for which <code>(equal x (r x))</code>.</li>
</ul>

<img src='../media/refs/chine_nual.png' width='120'/>

<h2>Church Numerals are a representation of the natural numbers using lambda
notation.</h2>

<p>A kind of <i>base1 arithmetic</i>, in which numbers are represented by
function nesting over an empty list, can be constructed in <a
href='lisp.html'>Pure Lisp</a> using only very few primtives. This document
will present Church Numerals through the lens of Lisp, alternatively one might
prefer to read it coming from the <a href='ornithomicon.html'>Avian
Numerals</a> tutorial.</p>

<p>The following file contains the basic building blocks as an example:</p>

<pre>
(LETREC church
	(church LAMBDA (INPUT)
		(greater?
			(incr (incr (incr (incr nil))))
			(incr (incr (incr nil))))
	)
	(nil QUOTE NULL)
	(#f QUOTE F)
	(#t QUOTE T)
	(incr LAMBDA (x)
		(CONS nil x))
	(decr LAMBDA (x)
		(CDR x))
	(zero? LAMBDA (x)
		(EQ x nil))
	(not LAMBDA (x)
		(IF x #f #t))
	(plus LAMBDA (x y)
		(IF (zero? x) y
			(plus (decr x) (incr y))))
	(minus LAMBDA (x y)
		(IF (zero? y) x
			(minus (decr x) (decr y))))
	(multiply LAMBDA (x y)
		(IF (zero? x) nil
			(plus y (multiply (decr x) y))))
	(equal? LAMBDA (x y)
		(IF (zero? x) (zero? y)
			(IF (zero? y) #f
				(equal? (decr x) (decr y)))))
	(greater? LAMBDA (x y)
		(IF (zero? x) #f
			(IF (zero? y) (not (zero? x))
				(greater? (decr x) (decr y)))))
	(lesser? LAMBDA (x y)
		(greater? y x))
)
</pre>

<ul></ul><p class="incoming"><b>incoming</b> <a href="ronin.html">ronin</a> <a href="lain.html">lain</a> <a href="lisp_library.html">lisp library</a> <a href="church_encoding.html">church encoding</a> <a href="secd.html">secd</a> </p></main>
<footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a> <a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a> <a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a> <a href="ethics.html"><img src="../media/icon/dreipfeile.svg" alt="NoNazis!"/></a> <a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a> <span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2023 &mdash; <a href="about.html#license">BY-NC-SA 4.0</a></span></footer>
</body></html>