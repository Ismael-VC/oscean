<!DOCTYPE html><html><head><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/><title>XXIIVV &mdash; lin6</title></head><body><header><a href="home.html"><img src="../media/icon/logo.svg" alt="XXIIVV"/></a></header><nav><ul><li><a href="../site/raspberry.html">raspberry</a></li><li><a href="../site/microbit.html">microbit</a></li><li><a href="../site/reform.html">reform</a></li><li><a href="../site/playground.html">playground</a></li><li><a href="../site/norns.html">norns</a></li><li><a href="../site/monome.html">monome</a></li><li><a href="../site/macintosh.html">macintosh</a></li><li><a href="../site/famicom.html">famicom</a></li><li><a href="../site/playdate.html">playdate</a></li></ul><ul><li>lin6/</li></ul><ul></ul></nav><main><p>Lin6 is a linter for 6502 assembly code.</p>

<p>The linter is a utility to format assembly code to be used with the asm6 assembler. Lin6 was used in the creation of <a href='donsol_famicom.html'>Donsol</a>, <a href='spacetime_6502.html'>Spacetime</a> and <a href='nespaint.html'>NesPaint</a>.</p>
<h3>Styleguide</h3>
<article>;; Variables<br /><br />	.enum $0000                        ; Directive comment<br />	pos_x                   .dsb 1     ; Variable comment<br />	pos_y                   .dsb 1     <br />	.ende  <br /><br />;; Constants<br /><br />	SPRITE_Y                .equ $0200 ; Constant comment<br />	SPRITE_XY               .equ $0203 <br /><br />RESET: <br />	NOP <br /><br />Forever: <br />	JMP Forever<br /><br />NMI: <br />	RTI <br /><br />;; Routines<br /><br />CheckCollision: ; Routine comment<br />	LDA pos_y<br />	CMP #$88                           ; Opcode comment<br />	BCC @done<br />	; Inline comment<br />	LDA #$88<br />	STA pos_y<br />@done: <br />	RTS <br /><br />;; Tables<br /><br />Table: <br />	.db $40,$46,$4c,$52,$58,$5e,$63,$68 <br /><br />;; Vectors<br /><br />	.pad $FFFA <br />	.dw NMI <br />	.dw RESET <br />	.dw 0 <br />	.incbin "src/sprite.chr" <br /></article>
<h3>Source</h3>
<pre>/* <br />  Lin6<br />  Version 1.3<br />  https://wiki.xxiivv.com/lin6<br /><br />  Variable names must always be lowercase.<br />  Variable names are always padded to tab1.<br />  Variable length are always padded to col25.<br />  Variable comments are always padded to col32.<br />  Constant names must always be uppercase.<br />  Constant names are always padded to tab1.<br />  Constant length are always padded to col21.<br />  Constant comments are always padded to col32.<br />  Label names must always be capitalized.<br />  Label names always end with :.<br />  Label names are always preceeded with a linebreak.<br />  Label comments are never padded.<br />  Directive names are always padded to tab1.<br />  Directive names are always lowercase.<br />  Directive comments are never padded.<br />  Opcode names are always uppercase.<br />  Opcode names are always padded to tab1.<br />  Opcode comments are always padded to col32.<br />  Inline comments are always padded to tab1.<br />  Spacing comments are always preceeded and followed with a linebreak.<br />*/<br /><br />#include &lt;stdio.h&gt;<br /><br />#define VERSION "1.3"<br />#define BUFLEN 512<br /><br />char* OPCODES[] = {"ADC", "AND", "ASL", "BCC", "BCS", "BEQ", "BIT", "BMI",<br />				   "BNE", "BPL", "BRK", "BVC", "BVS", "CLC", "CLD", "CLI",<br />				   "CLV", "CMP", "CPX", "CPY", "DEC", "DEX", "DEY", "EOR",<br />				   "INC", "INX", "INY", "JMP", "JSR", "LDA", "LDX", "LDY",<br />				   "LSR", "NOP", "ORA", "PHA", "PHP", "PLA", "PLP", "ROL",<br />				   "ROR", "RTI", "RTS", "SBC", "SEC", "SED", "SEI", "STA",<br />				   "STX", "STY", "TAX", "TAY", "TSX", "TXA", "TXS", "TYA"};<br /><br />int skipped = 0;<br /><br />int<br />cisp(char c)<br />{<br />	return c == ' ' || c == '\t' || c == '\n' || c == '\r';<br />}<br /><br />int<br />clca(int c)<br />{<br />	return c &gt;= 'A' &amp;&amp; c &lt;= 'Z' ? c + ('a' - 'A') : c;<br />}<br /><br />int<br />cuca(char c)<br />{<br />	return c &gt;= 'a' &amp;&amp; c &lt;= 'z' ? c - ('a' - 'A') : c;<br />}<br /><br />int<br />ciuc(char c)<br />{<br />	return c == cuca(c);<br />}<br /><br />int<br />cilc(char c)<br />{<br />	return c == clca(c);<br />}<br /><br />char*<br />sstr(char* src, char* dest, int from, int to)<br />{<br />	int i;<br />	char *a = (char*)src + from, *b = (char*)dest;<br />	for(i = 0; i &lt; to; i++)<br />		b[i] = a[i];<br />	dest[to] = '\0';<br />	return dest;<br />}<br /><br />int<br />slen(char* s)<br />{<br />	int n = 0;<br />	while(s[n] != '\0' &amp;&amp; s[++n])<br />		;<br />	return n;<br />}<br /><br />int<br />silc(char* s)<br />{<br />	int i;<br />	for(i = 0; i &lt; slen(s); i++)<br />		if(!cilc(s[i]))<br />			return 0;<br />	return 1;<br />}<br /><br />int<br />siuc(char* s)<br />{<br />	int i;<br />	for(i = 0; i &lt; slen(s); i++)<br />		if(!ciuc(s[i]))<br />			return 0;<br />	return 1;<br />}<br /><br />int<br />cpos(char* s, char c)<br />{<br />	int i;<br />	for(i = 0; i &lt; slen(s); i++)<br />		if(s[i] == c)<br />			return i;<br />	return -1;<br />}<br /><br />char*<br />scat(char* dest, const char* src)<br />{<br />	char* ptr = dest + slen(dest);<br />	while(*src != '\0')<br />		*ptr++ = *src++;<br />	*ptr = '\0';<br />	return dest;<br />}<br /><br />int<br />scmp(char* a, char* b)<br />{<br />	int i, l = slen(a);<br />	if(l != slen(b))<br />		return 0;<br />	for(i = 0; i &lt; l; ++i)<br />		if(a[i] != b[i])<br />			return 0;<br />	return 1;<br />}<br /><br />char*<br />suca(char* s)<br />{<br />	int i;<br />	for(i = 0; i &lt; slen(s); i++)<br />		s[i] = cuca(s[i]);<br />	return s;<br />}<br /><br />char*<br />slca(char* s)<br />{<br />	int i;<br />	for(i = 0; i &lt; slen(s); i++)<br />		s[i] = clca(s[i]);<br />	return s;<br />}<br /><br />char*<br />strm(char* s)<br />{<br />	char* end;<br />	while(cisp(*s))<br />		s++;<br />	if(*s == 0)<br />		return s;<br />	end = s + slen(s) - 1;<br />	while(end &gt; s &amp;&amp; cisp(*end))<br />		end--;<br />	end[1] = '\0';<br />	return s;<br />}<br /><br />int<br />spos(char* a, char* b)<br />{<br />	int i, j, alen = slen(a), blen = slen(b);<br />	for(i = 0; i &lt; alen; i++) {<br />		for(j = 0; j &lt; blen; j++) {<br />			if(a[i + j] == '\0')<br />				return -1;<br />			if(a[i + j] != b[j])<br />				break;<br />			if(j == blen - 1)<br />				return i;<br />		}<br />	}<br />	return -1;<br />}<br /><br />char*<br />scpy(char* src, char* dest)<br />{<br />	int i = 0;<br />	while((dest[i] = src[i]) != '\0')<br />		i++;<br />	return dest;<br />}<br /><br />void<br />setkey(char* src, char* dst)<br />{<br />	sstr(src, dst, 0, cpos(src, ' ') &gt; 0 ? cpos(src, ' ') : slen(src));<br />}<br /><br />void<br />setval(char* src, char* dst)<br />{<br />	int step = 0, i, comment = cpos(src, ';'), len = slen(src);<br />	if(comment &gt; -1)<br />		len = comment;<br />	for(i = 0; i &lt; len; i++) {<br />		if(src[i] != ' ' &amp;&amp; step == 1)<br />			break;<br />		else if(src[i] == ' ')<br />			step = 1;<br />	}<br />	sstr(src, dst, i, len - i);<br />	scpy(strm(dst), dst);<br />}<br /><br />void<br />setcmt(char* src, char* dst)<br />{<br />	if(cpos(src, ';') &gt; 0)<br />		sstr(src, dst, cpos(src, ';'), slen(src) - cpos(src, ';'));<br />	else<br />		scpy("", dst);<br />	scpy(strm(dst), dst);<br />}<br /><br />int<br />islabel(char* line)<br />{<br />	int i;<br />	for(i = 0; i &lt; slen(line); i++) {<br />		if(line[i] == ' ' || line[i] == ';')<br />			return 0;<br />		if(line[i] == ':')<br />			return 1;<br />	}<br />	return 0;<br />}<br /><br />int<br />isopcode(char* line)<br />{<br />	int i;<br />	char opcode[4];<br />	suca(sstr(line, opcode, 0, 3));<br />	for(i = 0; i &lt; 56; i++)<br />		if(scmp(OPCODES[i], opcode))<br />			return 1;<br />	return 0;<br />}<br /><br />int<br />iscomment(char* line)<br />{<br />	return line[0] == ';';<br />}<br /><br />int<br />isdirective(char* line)<br />{<br />	return line[0] == '.';<br />}<br /><br />int<br />isvariable(char* line)<br />{<br />	return spos(line, ".dsb") &gt; 0;<br />}<br /><br />int<br />isconstant(char* line)<br />{<br />	return spos(line, ".equ") &gt; 0;<br />}<br /><br />void<br />dolabel(char* src)<br />{<br />	char key[BUFLEN], cmt[BUFLEN];<br />	setkey(src, key);<br />	setcmt(src, cmt);<br />	key[0] = cuca(key[0]);<br />	if(key[0] == '@' || skipped)<br />		printf("%s %s\n", key, cmt);<br />	else<br />		printf("\n%s %s\n", key, cmt);<br />	skipped = 0;<br />}<br /><br />void<br />doopcode(char* src)<br />{<br />	char key[BUFLEN], val[BUFLEN], cmt[BUFLEN];<br />	setkey(src, key);<br />	suca(key);<br />	setval(src, val);<br />	setcmt(src, cmt);<br />	if(slen(cmt) &gt; 1)<br />		printf("\t%s %-30s %s\n", key, val, cmt);<br />	else<br />		printf("\t%s %s\n", key, val);<br />	skipped = 0;<br />}<br /><br />void<br />docomment(char* src)<br />{<br />	if(src[0] == src[1]) {<br />		printf("\n%s\n\n", src);<br />		skipped = 1;<br />	} else {<br />		printf("\t%s\n", src);<br />		skipped = 0;<br />	}<br />}<br /><br />void<br />dodirective(char* src)<br />{<br />	char key[BUFLEN], val[BUFLEN], cmt[BUFLEN];<br />	setkey(src, key);<br />	slca(key);<br />	setval(src, val);<br />	setcmt(src, cmt);<br />	if(slen(cmt) &gt; 1)<br />		printf("\t%s %s %s\n", key, val, cmt);<br />	else<br />		printf("\t%s %s\n", key, val);<br />	skipped = 0;<br />}<br /><br />void<br />dovariable(char* src)<br />{<br />	char key[BUFLEN], val[BUFLEN], cmt[BUFLEN];<br />	setkey(src, key);<br />	slca(key);<br />	setval(src, val);<br />	setcmt(src, cmt);<br />	if(slen(cmt) &gt; 1)<br />		printf("\t%-23s %-10s %s\n", key, val, cmt);<br />	else<br />		printf("\t%-23s %s\n", key, val);<br />	skipped = 0;<br />}<br /><br />void<br />doconstant(char* src)<br />{<br />	char key[BUFLEN], val[BUFLEN], cmt[BUFLEN];<br />	setkey(src, key);<br />	suca(key);<br />	setval(src, val);<br />	setcmt(src, cmt);<br />	printf("\t%-23s %-10s %s\n", key, val, cmt);<br />	skipped = 0;<br />}<br /><br />void<br />lint(FILE* f)<br />{<br />	char line[BUFLEN], trimed[BUFLEN];<br />	while(fgets(line, BUFLEN, f)) {<br />		scpy(strm(line), trimed);<br />		if(slen(trimed) &lt; 3)<br />			continue;<br />		if(islabel(trimed))<br />			dolabel(trimed);<br />		else if(isopcode(trimed))<br />			doopcode(trimed);<br />		else if(iscomment(trimed))<br />			docomment(trimed);<br />		else if(isdirective(trimed))<br />			dodirective(trimed);<br />		else if(isvariable(trimed))<br />			dovariable(trimed);<br />		else if(isconstant(trimed))<br />			doconstant(trimed);<br />		else<br />			printf("%s\n", line);<br />	}<br />	fclose(f);<br />}<br /><br />int<br />version(void)<br />{<br />	puts("Lin6 " VERSION);<br />	return 0;<br />}<br /><br />int<br />help(void)<br />{<br />	version();<br />	puts("");<br />	puts("A tool to format 6502 assembly code.\n");<br />	puts("Usage:  Lin6 [-options] [&lt;file&gt; ...]\n");<br />	puts("\t-?\tShow this help");<br />	puts("\t-v\tShow version");<br />	puts("See README for more info.\n");<br />	return 0;<br />}<br /><br />int<br />main(int argc, char* argv[])<br />{<br />	FILE* f;<br />	int i;<br />	if(argc &lt; 2)<br />		return help();<br />	for(i = 1; i &lt; argc; i++) {<br />		if(argv[i][1] == '?')<br />			return help();<br />		else if(argv[i][1] == 'v')<br />			return version();<br />		else {<br />			f = fopen(argv[i], "r");<br />			if(f != NULL)<br />				lint(f);<br />		}<br />	}<br />	return 0;<br />}<br /></pre>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/lin6' target='_blank'>source</a></li>
</ul>

</main><footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a><a href="http://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2021 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer></body></html>