<!DOCTYPE html><html><head><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/><title>XXIIVV &mdash; moogle</title></head><body><header><a href="home.html"><img src="../media/icon/logo.svg" alt="XXIIVV"/></a></header><nav><ul><li><a href="../site/roms.html">roms</a></li><li><a href="../site/tools.html">tools</a></li><li><a href="../site/utilities.html">utilities</a></li><li><a href="../site/formats.html">formats</a></li><li><a href="../site/games.html">games</a></li><li><a href="../site/toys.html">toys</a></li><li><a href="../site/mobile.html">mobile</a></li><li><a href="../site/unreleased.html">unreleased</a></li></ul><ul><li><a href="../site/dito.html">dito</a></li><li><a href="../site/dotgrid.html">dotgrid</a></li><li><a href="../site/ronin.html">ronin</a></li><li>moogle/</li></ul><ul><li><a href="../site/graf3dscene.html">graf3dscene</a></li></ul></nav><main><figure><img src="../media/diary/727.jpg" alt="moogle	Pitch Yaw Roll"/><figcaption>	Pitch Yaw Roll</figcaption></figure><h2>Moogle is a wireframe editor.</h2>

<p>Moogle is a minimal <b>3D wireframe tool</b> designed to be used alongside its companion tool <a href='noodle.html'>Noodle</a>, both can export to the <a href='chr_format.html'>chr_format</a>. It offers a handful of basic geometry drawing functions, it was written in <a href='ansi_c.html'>ANSI C</a>, and was inspired by <a href='graf3dscene.html'>Graf3DScene</a>.</p>
<p>Moogle was first written on <a href='plan9.html'>Plan9</a>, the original <a href='plan9_c.html'>Plan9 C</a> implementation is available <a href='../src/inc/text/moogle9.c.txt' target='_blank'>here</a>.</p>
<h3>moogle.c</h3>
<p>To control the window size and default colors, edit the values defined at the top of the file itself. To learn more, visit the <a href='https://git.sr.ht/~rabbits/moogle' target='_blank'>repository</a>.</p>
<pre>cc -std=c89 -Wall moogle.c -L/usr/local/lib -lSDL2 -lm -o moogle</pre>
<p>The following code is a single-file implementation written in <a href='ansi_c.html'>ANSI C</a>, the only dependecy is <a href='https://www.libsdl.org' target='_blank'>SDL2</a>.</p>
<pre>#include &lt;SDL2/SDL.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;math.h&gt;<br /><br />/* <br />Copyright (c) 2020 Devine Lu Linvega<br /><br />Permission to use, copy, modify, and distribute this software for any<br />purpose with or without fee is hereby granted, provided that the above<br />copyright notice and this permission notice appear in all copies.<br /><br />THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES<br />WITH REGARD TO THIS SOFTWARE.<br />*/<br /><br />#define HOR 32<br />#define VER 16<br />#define PAD 8<br />#define SZ (HOR * VER * 16)<br /><br />#define VLIMIT 256<br />#define ELIMIT 512<br />#define MLIMIT 128<br />#define PI 3.14159265358979323846<br /><br />#define VIEWFRONT Pt3d(180, 0, 0)<br />#define VIEWTOP Pt3d(90, 0, 0)<br />#define VIEWSIDE Pt3d(90, 90, 0)<br /><br />typedef struct {<br />	double x, y;<br />} Point2d;<br /><br />typedef struct {<br />	double x, y, z;<br />} Point3d;<br /><br />typedef struct {<br />	int color;<br />	Point3d *a, *b;<br />} Edge;<br /><br />typedef struct {<br />	int verticeslen, edgeslen;<br />	Point3d position, vertices[VLIMIT];<br />	Edge edges[ELIMIT];<br />} Mesh;<br /><br />typedef struct {<br />	int len;<br />	Point3d position, scale, rotation;<br />	Mesh meshes[MLIMIT];<br />} Scene;<br /><br />typedef enum {<br />	ISOMETRIC,<br />	PERSPECTIVE<br />} Projection;<br /><br />typedef struct {<br />	double range;<br />	Point3d origin, rotation, torigin, trotation;<br />	Projection projection;<br />} Camera;<br /><br />int WIDTH = 8 * HOR + PAD * 2;<br />int HEIGHT = 8 * (VER + 2) + PAD * 2;<br />int FPS = 30, GUIDES = 1, ZOOM = 2;<br /><br />Scene scn;<br />Camera cam;<br /><br />/* interface */<br /><br />Uint32 theme[] = {<br />	0x000000,<br />	0xFFFFFF,<br />	0x72DEC2,<br />	0x666666,<br />	0x222222};<br /><br />Uint8 icons[][8] = {<br />	{0x10, 0x28, 0x44, 0x92, 0x44, 0x28, 0x10, 0x00},<br />	{0x10, 0x28, 0x44, 0x82, 0x82, 0x82, 0xd6, 0x00},<br />	{0x1e, 0x22, 0x40, 0x82, 0x40, 0x22, 0x1e, 0x00},<br />	{0x04, 0x08, 0x50, 0xa4, 0x50, 0x08, 0x04, 0x00},<br />	{0x1e, 0x20, 0x40, 0xa2, 0x40, 0x20, 0x1e, 0x00},<br />	{0x00, 0x00, 0x00, 0x82, 0x44, 0x38, 0x00, 0x00}, /* eye open */<br />	{0x00, 0x38, 0x44, 0x92, 0x28, 0x10, 0x00, 0x00}  /* eye closed */<br />};<br /><br />SDL_Window *gWindow = NULL;<br />SDL_Renderer *gRenderer = NULL;<br />SDL_Texture *gTexture = NULL;<br />Uint32 *pixels;<br /><br />/* helpers */<br /><br />Point2d<br />Pt2d(double x, double y)<br />{<br />	Point2d p;<br />	p.x = x;<br />	p.y = y;<br />	return p;<br />}<br /><br />Point3d *<br />set3d(Point3d *v, double x, double y, double z)<br />{<br />	v-&gt;x = x;<br />	v-&gt;y = y;<br />	v-&gt;z = z;<br />	return v;<br />}<br /><br />Point3d<br />Pt3d(double x, double y, double z)<br />{<br />	Point3d p;<br />	set3d(&amp;p, x, y, z);<br />	return p;<br />}<br /><br />Mesh<br />Ms3d(double x, double y, double z)<br />{<br />	Mesh m;<br />	set3d(&amp;m.position, x, y, z);<br />	m.verticeslen = 0;<br />	m.edgeslen = 0;<br />	return m;<br />}<br /><br />Scene<br />Sc3d(void)<br />{<br />	Scene s;<br />	s.len = 0;<br />	set3d(&amp;s.position, 0, 0, 0);<br />	set3d(&amp;s.scale, 1, 1, 1);<br />	set3d(&amp;s.rotation, 0, 0, 0);<br />	return s;<br />}<br /><br />Camera<br />Cm3d(double pitch, double yaw, double roll)<br />{<br />	Camera c;<br />	set3d(&amp;c.rotation, pitch, yaw, roll);<br />	set3d(&amp;c.trotation, pitch, yaw, roll);<br />	c.projection = PERSPECTIVE;<br />	c.range = 50;<br />	return c;<br />}<br /><br />int<br />colortheme(Uint32 hex)<br />{<br />	int i = 0;<br />	for(i = 0; i &lt; 5; ++i)<br />		if(theme[i] == hex)<br />			return i;<br />	return 0;<br />}<br /><br />/* geometry */<br /><br />double<br />interpolate(double a, double b, double speed, double range)<br />{<br />	if(a &lt; b - range || a &gt; b + range) {<br />		a += (b - a) / speed;<br />	} else<br />		a = b;<br />	return a;<br />}<br /><br />Point2d<br />rot2d(Point2d a, Point2d b, double deg)<br />{<br />	double radian = deg * (PI / 180);<br />	double angle = atan2(b.y - a.y, b.x - a.x) + radian;<br />	double r = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));<br />	return Pt2d(a.x + r * cos(angle), a.y + r * sin(angle));<br />}<br /><br />int<br />equpt3d(Point3d p0, Point3d p1)<br />{<br />	return p0.x == p1.x &amp;&amp; p0.y == p1.y &amp;&amp; p0.z == p1.z;<br />}<br /><br />Point3d *<br />addpt3d(Point3d *p, double x, double y, double z)<br />{<br />	return set3d(p, p-&gt;x + x, p-&gt;y + y, p-&gt;z + z);<br />}<br /><br />Point3d<br />add3d(Point3d *a, Point3d *b)<br />{<br />	return Pt3d(a-&gt;x + b-&gt;x, a-&gt;y + b-&gt;y, a-&gt;z + b-&gt;z);<br />}<br /><br />Point3d<br />mul3d(Point3d *a, Point3d *b)<br />{<br />	return Pt3d(a-&gt;x * b-&gt;x, a-&gt;y * b-&gt;y, a-&gt;z * b-&gt;z);<br />}<br /><br />/* scene */<br /><br />Point3d *<br />translate3d(Point3d *p, Point3d *t)<br />{<br />	*p = add3d(p, t);<br />	return p;<br />}<br /><br />Point3d *<br />scale3d(Point3d *p, Point3d *t)<br />{<br />	*p = mul3d(p, t);<br />	return p;<br />}<br /><br />Point3d *<br />rotate3d(Point3d *p, Point3d *o, Point3d *t)<br />{<br />	if(t-&gt;x) {<br />		Point2d r = rot2d(Pt2d(o-&gt;y, o-&gt;z), Pt2d(p-&gt;y, p-&gt;z), t-&gt;x);<br />		p-&gt;y = r.x;<br />		p-&gt;z = r.y;<br />	}<br />	if(t-&gt;y) {<br />		Point2d r = rot2d(Pt2d(o-&gt;x, o-&gt;z), Pt2d(p-&gt;x, p-&gt;z), t-&gt;y);<br />		p-&gt;x = r.x;<br />		p-&gt;z = r.y;<br />	}<br />	if(t-&gt;z) {<br />		Point2d r = rot2d(Pt2d(o-&gt;x, o-&gt;y), Pt2d(p-&gt;x, p-&gt;y), t-&gt;z);<br />		p-&gt;x = r.x;<br />		p-&gt;y = r.y;<br />	}<br />	return p;<br />}<br /><br />Scene *<br />moveto(Scene *s, double x, double y, double z)<br />{<br />	set3d(&amp;s-&gt;position, x, y, z);<br />	return s;<br />}<br /><br />Scene *<br />scaleto(Scene *s, double x, double y, double z)<br />{<br />	set3d(&amp;s-&gt;scale, x, y, z);<br />	return s;<br />}<br /><br />Scene *<br />rotateto(Scene *s, double x, double y, double z)<br />{<br />	set3d(&amp;s-&gt;rotation, x, y, z);<br />	return s;<br />}<br /><br />Scene *<br />reset(Scene *s)<br />{<br />	moveto(scaleto(rotateto(s, 0, 0, 0), 1, 1, 1), 0, 0, 0);<br />	return s;<br />}<br /><br />Point3d *<br />addvertex(Mesh *m, double x, double y, double z)<br />{<br />	int i;<br />	Point3d v = Pt3d(x, y, z);<br />	if(m-&gt;verticeslen == VLIMIT) {<br />		printf("Warning: Reached vertex limit\n");<br />		return NULL;<br />	}<br />	translate3d(&amp;v, &amp;scn.position);<br />	scale3d(&amp;v, &amp;scn.scale);<br />	rotate3d(&amp;v, &amp;scn.position, &amp;scn.rotation);<br />	for(i = 0; i &lt; m-&gt;verticeslen; ++i)<br />		if(equpt3d(m-&gt;vertices[i], v))<br />			return &amp;m-&gt;vertices[i];<br />	return set3d(&amp;m-&gt;vertices[m-&gt;verticeslen++], v.x, v.y, v.z);<br />}<br /><br />Edge *<br />addedge(Mesh *m, Point3d *a, Point3d *b, int color)<br />{<br />	if(m-&gt;edgeslen == ELIMIT) {<br />		printf("Warning: Reached edge limit\n");<br />		return NULL;<br />	}<br />	m-&gt;edges[m-&gt;edgeslen].a = a;<br />	m-&gt;edges[m-&gt;edgeslen].b = b;<br />	m-&gt;edges[m-&gt;edgeslen].color = color;<br />	return &amp;m-&gt;edges[m-&gt;edgeslen++];<br />}<br /><br />Mesh *<br />addmesh(Scene *s)<br />{<br />	if(s-&gt;len == MLIMIT) {<br />		printf("Warning: Reached mesh limit\n");<br />		return NULL;<br />	}<br />	return &amp;s-&gt;meshes[s-&gt;len++];<br />}<br /><br />/* transforms */<br /><br />Mesh *<br />translate(Mesh *m, double x, double y, double z)<br />{<br />	int i;<br />	Point3d t = Pt3d(x, y, z);<br />	for(i = 0; i &lt; m-&gt;verticeslen; i++)<br />		translate3d(&amp;m-&gt;vertices[i], &amp;t);<br />	return m;<br />}<br /><br />Mesh *<br />scale(Mesh *m, double x, double y, double z)<br />{<br />	int i;<br />	Point3d t = Pt3d(x, y, z);<br />	for(i = 0; i &lt; m-&gt;verticeslen; i++)<br />		scale3d(&amp;m-&gt;vertices[i], &amp;t);<br />	return m;<br />}<br /><br />Mesh *<br />rotate(Mesh *m, double pitch, double yaw, double roll)<br />{<br />	int i;<br />	Point3d t = Pt3d(pitch, yaw, roll);<br />	for(i = 0; i &lt; m-&gt;verticeslen; i++)<br />		rotate3d(&amp;m-&gt;vertices[i], &amp;m-&gt;position, &amp;t);<br />	return m;<br />}<br /><br />Mesh *<br />extrude(Mesh *m, Point3d t, int color)<br />{<br />	int i, j, vl = m-&gt;verticeslen, el = m-&gt;edgeslen;<br />	for(i = 0; i &lt; vl; i++) {<br />		Point3d *a = &amp;m-&gt;vertices[i];<br />		addedge(m, &amp;m-&gt;vertices[i], addvertex(m, a-&gt;x + t.x, a-&gt;y + t.y, a-&gt;z + t.z), color);<br />	}<br />	for(i = 0; i &lt; el; i++) {<br />		Edge *e0 = &amp;m-&gt;edges[i];<br />		Edge *e1 = addedge(m, e0-&gt;a, e0-&gt;b, e0-&gt;color);<br />		for(j = 0; j &lt; vl; j++) {<br />			if(e0-&gt;a == &amp;m-&gt;vertices[j])<br />				e1-&gt;a = &amp;m-&gt;vertices[vl + j];<br />			else if(e0-&gt;b == &amp;m-&gt;vertices[j])<br />				e1-&gt;b = &amp;m-&gt;vertices[vl + j];<br />		}<br />	}<br />	return m;<br />}<br /><br />/* Primitives */<br /><br />Mesh *<br />addpoly(Mesh *m, int a, int b, int c, int color)<br />{<br />	addedge(m, &amp;m-&gt;vertices[a], &amp;m-&gt;vertices[b], color);<br />	addedge(m, &amp;m-&gt;vertices[b], &amp;m-&gt;vertices[c], color);<br />	addedge(m, &amp;m-&gt;vertices[c], &amp;m-&gt;vertices[a], color);<br />	return m;<br />}<br /><br />Mesh *<br />addline(Mesh *m, Point3d a, Point3d b, int color)<br />{<br />	addedge(m, addvertex(m, a.x, a.y, a.z), addvertex(m, b.x, b.y, b.z), color);<br />	return m;<br />}<br /><br />Mesh *<br />addarc(Mesh *m, double radius, double segs, double angle, int color)<br />{<br />	int i;<br />	double arc = 2 * PI * angle / 360 / segs;<br />	Point3d b;<br />	for(i = 0; i &lt; segs + 1; i++) {<br />		Point3d a = Pt3d(radius * cos(i * arc), radius * sin(i * arc), 0);<br />		if(i &gt; 0)<br />			addline(m, a, b, color);<br />		b = a;<br />	}<br />	return m;<br />}<br /><br />Mesh *<br />addshape(Mesh *m, double radius, int segs, int color)<br />{<br />	return addarc(m, radius, segs, 360, color);<br />}<br /><br />/* Primitives */<br /><br />Mesh *<br />createfrustum(Scene *s, double radius, int segs, double depth, double cap, int color)<br />{<br />	int i;<br />	Mesh *m = addmesh(s);<br />	addshape(m, cap, segs, color);<br />	translate(m, 0, 0, depth);<br />	addshape(m, radius, segs, color);<br />	for(i = 0; i &lt; segs + 1; i++)<br />		addedge(m, &amp;m-&gt;vertices[i], &amp;m-&gt;vertices[segs + i + 1], color);<br />	return m;<br />}<br /><br />Mesh *<br />createpyramid(Scene *s, double radius, int segs, double depth, int color)<br />{<br />	int i;<br />	Mesh *m = addmesh(s);<br />	Point3d *p = addvertex(m, 0, 0, depth);<br />	addshape(m, radius, segs, color);<br />	for(i = 0; i &lt; segs + 1; i++)<br />		addedge(m, &amp;m-&gt;vertices[i], p, color);<br />	return m;<br />}<br /><br />Mesh *<br />createprism(Scene *s, double radius, int segs, double depth, int color)<br />{<br />	return createfrustum(s, radius, segs, depth, radius, color);<br />}<br /><br />Mesh *<br />createplane(Scene *s, double width, double height, double xsegs, double ysegs, int color)<br />{<br />	int ix, iy;<br />	Mesh *m = addmesh(s);<br />	for(ix = 0; ix &lt; xsegs + 1; ix++)<br />		addline(m,<br />			Pt3d(ix * (width / xsegs) - width / 2, height / 2, 0),<br />			Pt3d(ix * (width / xsegs) - width / 2, -height / 2, 0),<br />			color);<br />	for(iy = 0; iy &lt; ysegs + 1; iy++)<br />		addline(m,<br />			Pt3d(width / 2, iy * (height / ysegs) - height / 2, 0),<br />			Pt3d(-width / 2, iy * (height / ysegs) - height / 2, 0),<br />			color);<br />	return m;<br />}<br /><br />Mesh *<br />createbox(Scene *s, double width, double height, double depth, int color)<br />{<br />	int i;<br />	Mesh *m = createplane(s, width, height, 1, 1, color);<br />	extrude(m, Pt3d(0, 0, depth), color);<br />	return m;<br />}<br /><br />Mesh *<br />createicosaedron(Scene *s, double radius, int color)<br />{<br />	int i;<br />	Mesh *m = addmesh(s);<br />	double t = (1.0 + sqrt(5.0)) / 2.0;<br />	addvertex(m, -1, t, 0);<br />	addvertex(m, 1, t, 0);<br />	addvertex(m, -1, -t, 0);<br />	addvertex(m, 1, -t, 0);<br />	addvertex(m, 0, -1, t);<br />	addvertex(m, 0, 1, t);<br />	addvertex(m, 0, -1, -t);<br />	addvertex(m, 0, 1, -t);<br />	addvertex(m, t, 0, -1);<br />	addvertex(m, t, 0, 1);<br />	addvertex(m, -t, 0, -1);<br />	addvertex(m, -t, 0, 1);<br />	addpoly(m, 0, 11, 5, 3); /* - */<br />	addpoly(m, 0, 5, 1, 3);<br />	addpoly(m, 0, 1, 7, 3);<br />	addpoly(m, 0, 7, 10, 3);<br />	addpoly(m, 0, 10, 11, 3);<br />	addpoly(m, 1, 5, 9, 3); /* - */<br />	addpoly(m, 5, 11, 4, 3);<br />	addpoly(m, 11, 10, 2, 3);<br />	addpoly(m, 10, 7, 6, 3);<br />	addpoly(m, 7, 1, 8, 3);<br />	addpoly(m, 3, 9, 4, 3); /* - */<br />	addpoly(m, 3, 4, 2, 3);<br />	addpoly(m, 3, 2, 6, 3);<br />	addpoly(m, 3, 6, 8, 3);<br />	addpoly(m, 3, 8, 9, 3);<br />	addpoly(m, 4, 9, 5, 3); /* - */<br />	addpoly(m, 2, 4, 11, 3);<br />	addpoly(m, 6, 2, 10, 3);<br />	addpoly(m, 8, 6, 7, 3);<br />	addpoly(m, 9, 8, 1, 3);<br />	scale(m, radius / 2, radius / 2, radius / 2);<br />	return m;<br />}<br /><br />Mesh *<br />createumbrella(Scene *s)<br />{<br />	int i;<br />	Mesh *umbrella = addmesh(s);<br />	reset(s);<br />	for(i = 0; i &lt; 5; ++i) {<br />		addarc(umbrella, 10, 8, 180, 2);<br />		rotateto(s, 0, 45 * i, 0);<br />	}<br />	rotateto(s, 90, 0, 0);<br />	addshape(umbrella, 10, 8, 1);<br />	translate(scale(umbrella, 1, 0.6, 1), 0, 2, 0);<br />	addline(umbrella, Pt3d(0, 0, -10), Pt3d(0, 0, 8), 1);<br />	rotateto(moveto(s, 0, -8, 2), 90, 90, 90);<br />	addarc(umbrella, 2, 8, 180, 2);<br />	reset(s);<br />	return umbrella;<br />}<br /><br />/* draw */<br /><br />void<br />clear(Uint32 *dst)<br />{<br />	int i, j;<br />	for(i = 0; i &lt; HEIGHT; i++)<br />		for(j = 0; j &lt; WIDTH; j++)<br />			dst[i * WIDTH + j] = theme[0];<br />}<br /><br />int<br />getpixel(Uint32 *dst, int x, int y)<br />{<br />	return dst[(y + PAD) * WIDTH + (x + PAD)];<br />}<br /><br />void<br />putpixel(Uint32 *dst, int x, int y, int color)<br />{<br />	if(x &gt;= 0 &amp;&amp; x &lt; WIDTH - 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; HEIGHT - 8)<br />		dst[(y + PAD) * WIDTH + (x + PAD)] = theme[color];<br />}<br /><br />void<br />line(Uint32 *dst, Point2d p0, Point2d p1, int color)<br />{<br />	int p0x = (int)p0.x, p0y = (int)p0.y;<br />	int p1x = (int)p1.x, p1y = (int)p1.y;<br />	int dx = abs(p1x - p0x), sx = p0x &lt; p1x ? 1 : -1;<br />	int dy = -abs(p1y - p0y), sy = p0y &lt; p1y ? 1 : -1;<br />	int err = dx + dy, e2;<br />	for(;;) {<br />		putpixel(dst, p0x, p0y, color);<br />		if(p0x == p1x &amp;&amp; p0y == p1y)<br />			break;<br />		e2 = 2 * err;<br />		if(e2 &gt;= dy) {<br />			err += dy;<br />			p0x += sx;<br />		}<br />		if(e2 &lt;= dx) {<br />			err += dx;<br />			p0y += sy;<br />		}<br />	}<br />}<br /><br />void<br />drawicon(Uint32 *dst, int x, int y, Uint8 *icon, int color)<br />{<br />	int v, h;<br />	for(v = 0; v &lt; 8; v++)<br />		for(h = 0; h &lt; 8; h++) {<br />			int c = (icon[v] &gt;&gt; (8 - h)) &amp; 0x1;<br />			putpixel(dst, x + h, y + v, c ? color : 0);<br />		}<br />}<br /><br />void<br />drawui(Uint32 *dst)<br />{<br />	int bottom = VER * 8 + 8;<br />	drawicon(dst, 0 * 8, bottom, icons[0], equpt3d(cam.rotation, VIEWFRONT) ? 1 : 2);<br />	drawic</main><footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a><a href="http://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2021 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer></body></html>