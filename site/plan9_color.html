<!DOCTYPE html><html><head><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/><title>XXIIVV &mdash; plan9 color</title></head><body><header><a href="home.html"><img src="../media/icon/logo.svg" alt="XXIIVV"/></a></header><nav><ul><li><a href="../site/plan9.html">plan9</a></li><li><a href="../site/linux.html">linux</a></li></ul><ul><li><a href="../site/rio.html">rio</a></li><li><a href="../site/acme.html">acme</a></li><li><a href="../site/plan9_c.html">plan9 c</a></li><li><a href="../site/plan9_clock.html">plan9 clock</a></li><li>plan9 color/</li></ul><ul></ul></nav><main><figure><img src="../media/diary/515.jpg" alt="Color Picker"/><figcaption>Color Picker</figcaption></figure><h2>A simple HSV color picker for Plan9.</h2>

<p>Just a simple color picker utility written in <a href='plan9_c.html'>Plan9 C</a>, following the style of the <a href='plan9_clock.html'>Plan9 Clock</a>. Alternatively, you can use <a href='https://git.sr.ht/~ft/picker' target='_blank'>Sigrid's Color Picker</a> if you want to use something made by someone who knows what they're doing.</p>
<h3>Installation</h3>
<p>Compile this source with the compiler for your platform, if you are using an ARM device:</p>
<pre>5c color.c && 5l -o color color.c</pre>
<pre>#include &lt;u.h&gt;<br />#include &lt;libc.h&gt;<br />#include &lt;draw.h&gt;<br />#include &lt;thread.h&gt;<br />#include &lt;event.h&gt;<br /><br />/* Conversion */<br /><br />typedef struct RgbColor {<br />	unsigned char r, g, b;<br />} RgbColor;<br /><br />typedef struct HsvColor {<br />	unsigned char h, s, v;<br />} HsvColor;<br /><br />static HsvColor selection;<br /><br />double<br />ptangle(Point a, Point b)<br />{<br />	return atan2(b.y - a.y, b.x - a.x);<br />}<br /><br />double<br />ptdistance(Point a, Point b)<br />{<br />	int x = a.x - b.x;<br />	int y = a.y - b.y;<br /><br />	return sqrt(x * x + y * y);<br />}<br /><br />Point<br />circlept(Point c, int r, int degrees)<br />{<br />	double rad = (double)degrees * PI / 180.0;<br /><br />	c.x += cos(rad) * r;<br />	c.y -= sin(rad) * r;<br />	return c;<br />}<br /><br />Point<br />getcenter(Rectangle r)<br />{<br />	return divpt(addpt(r.min, r.max), 2);<br />}<br /><br />int<br />within(Point p, Rectangle r)<br />{<br />	return p.x &gt; r.min.x &amp;&amp; p.x &lt; r.max.x &amp;&amp; p.y &gt; r.min.y &amp;&amp; p.y &lt; r.max.y;<br />}<br /><br />RgbColor<br />hsv2rgb(HsvColor hsv)<br />{<br />	RgbColor rgb;<br />	unsigned char region, remainder, p, q, t;<br /><br />	if(hsv.s == 0) {<br />		return ((RgbColor){hsv.v, hsv.v, hsv.v});<br />	}<br />	region = hsv.h / 43;<br />	remainder = (hsv.h - (region * 43)) * 6;<br />	p = (hsv.v * (255 - hsv.s)) &gt;&gt; 8;<br />	q = (hsv.v * (255 - ((hsv.s * remainder) &gt;&gt; 8))) &gt;&gt; 8;<br />	t = (hsv.v * (255 - ((hsv.s * (255 - remainder)) &gt;&gt; 8))) &gt;&gt; 8;<br />	switch(region) {<br />	case 0:<br />		rgb.r = hsv.v;<br />		rgb.g = t;<br />		rgb.b = p;<br />		break;<br />	case 1:<br />		rgb.r = q;<br />		rgb.g = hsv.v;<br />		rgb.b = p;<br />		break;<br />	case 2:<br />		rgb.r = p;<br />		rgb.g = hsv.v;<br />		rgb.b = t;<br />		break;<br />	case 3:<br />		rgb.r = p;<br />		rgb.g = q;<br />		rgb.b = hsv.v;<br />		break;<br />	case 4:<br />		rgb.r = t;<br />		rgb.g = p;<br />		rgb.b = hsv.v;<br />		break;<br />	default:<br />		rgb.r = hsv.v;<br />		rgb.g = p;<br />		rgb.b = q;<br />		break;<br />	}<br />	return rgb;<br />}<br /><br />HsvColor<br />rgb2hsv(RgbColor rgb)<br />{<br />	HsvColor hsv;<br />	unsigned char rgbMin, rgbMax;<br /><br />	rgbMin = rgb.r &lt; rgb.g ? (rgb.r &lt; rgb.b ? rgb.r : rgb.b) : (rgb.g &lt; rgb.b ? rgb.g : rgb.b);<br />	rgbMax = rgb.r &gt; rgb.g ? (rgb.r &gt; rgb.b ? rgb.r : rgb.b) : (rgb.g &gt; rgb.b ? rgb.g : rgb.b);<br />	hsv.v = rgbMax;<br />	if(hsv.v == 0) {<br />		hsv.h = 0;<br />		hsv.s = 0;<br />		return hsv;<br />	}<br />	hsv.s = 255 * (double)(rgbMax - rgbMin) / hsv.v;<br />	if(hsv.s == 0) {<br />		hsv.h = 0;<br />		return hsv;<br />	}<br />	if(rgbMax == rgb.r)<br />		hsv.h = 0 + 43 * (rgb.g - rgb.b) / (rgbMax - rgbMin);<br />	else if(rgbMax == rgb.g)<br />		hsv.h = 85 + 43 * (rgb.b - rgb.r) / (rgbMax - rgbMin);<br />	else<br />		hsv.h = 171 + 43 * (rgb.r - rgb.g) / (rgbMax - rgbMin);<br />	return hsv;<br />}<br /><br />unsigned int<br />rgb2hex(RgbColor clr)<br />{<br />	return ((clr.r &amp; 0xFF) &lt;&lt; 24) + ((clr.g &amp; 0xFF) &lt;&lt; 16) + ((clr.b &amp; 0xFF) &lt;&lt; 8) + (255 &amp; 0xFF);<br />}<br /><br />unsigned int<br />hsv2hex(HsvColor hsvclr)<br />{<br />	return rgb2hex(hsv2rgb(hsvclr));<br />}<br /><br />/* Defaults */<br /><br />void<br />lineb(Image* dst, Point p0, Point p1, Image* src, Point sp)<br />{<br />	int dx = abs(p1.x - p0.x), sx = p0.x &lt; p1.x ? 1 : -1;<br />	int dy = -abs(p1.y - p0.y), sy = p0.y &lt; p1.y ? 1 : -1;<br />	int err = dx + dy, e2;<br /><br />	for(;;) {<br />		draw(dst, Rect(p0.x, p0.y, p0.x + 1, p0.y + 1), src, nil, sp);<br />		if(p0.x == p1.x &amp;&amp; p0.y == p1.y)<br />			break;<br />		e2 = 2 * err;<br />		if(e2 &gt;= dy) {<br />			err += dy;<br />			p0.x += sx;<br />		}<br />		if(e2 &lt;= dx) {<br />			err += dx;<br />			p0.y += sy;<br />		}<br />	}<br />}<br /><br />unsigned int<br />gradeint(int a, int b, double ratio)<br />{<br />	return (a * ratio) + (b * (1 - ratio));<br />}<br /><br />Point<br />gradept(Point a, Point b, double ratio)<br />{<br />	return Pt(<br />	    gradeint(a.x, b.x, ratio),<br />	    gradeint(a.y, b.y, ratio));<br />}<br /><br />unsigned int<br />gradecolor(HsvColor a, HsvColor b, double ratio)<br />{<br />	HsvColor clr = (HsvColor){<br />	    gradeint(a.h, b.h, ratio),<br />	    gradeint(a.s, b.s, ratio),<br />	    gradeint(a.v, b.v, ratio)};<br /><br />	return hsv2hex(clr);<br />}<br /><br />void<br />gradeline(Image* dst, Point p0, Point p1, HsvColor clr0, HsvColor clr1, int segs, Point sp)<br />{<br />	for(int i = 0; i &lt; segs; i++) {<br />		double ratio = (double)i / segs;<br />		Image* clrimg = allocimage(display, Rect(0, 0, 1, 1), RGBA32, 1,<br />		                           gradecolor(clr0, clr1, ratio));<br />		lineb(dst,<br />		      gradept(p0, p1, ratio),<br />		      gradept(p0, p1, (double)(i + 1) / segs), clrimg, ZP);<br />		freeimage(clrimg);<br />	}<br />}<br /><br />void<br />redraw(Image* dst)<br />{<br />	Point size = subpt(screen-&gt;r.max, screen-&gt;r.min);<br />	Point center = divpt(size, 2);<br />	Rectangle frame = (Rectangle){Pt(0, 0), size};<br />	int pad = 20;<br />	int rad = ((size.x &lt; size.y ? size.x : size.y) / 2) - pad;<br />	Image* view = allocimage(display, frame, RGBA32, 1, 0x000000FF);<br /><br />	/* draw ring */<br />	for(int i = 0; i &lt; 180; i++) {<br />		Point p0 = circlept(center, rad, i * 2);<br />		Point p1 = circlept(center, rad, (i + 1) * 2);<br />		unsigned int angle = ptangle(center, p0) / PI / 2 * 255;<br />		int hexclr = hsv2hex((HsvColor){angle, 255, 255});<br />		Image* imgclr = allocimage(display, Rect(0, 0, 1, 1), RGBA32, 1, hexclr);<br />		lineb(view, p0, p1, imgclr, ZP);<br />		freeimage(imgclr);<br />	}<br /><br />	/* draw selection */<br />	RgbColor selrgb = hsv2rgb(selection);<br />	HsvColor selhue = (HsvColor){selection.h, 255, 255};<br />	unsigned int selhex = rgb2hex(selrgb);<br />	Image* selclr = allocimage(display, Rect(0, 0, 1, 1), RGBA32, 1, selhex);<br />	Image* selhueclr = allocimage(display, Rect(0, 0, 1, 1), RGBA32, 1, hsv2hex(selhue));<br /><br />	/* draw hue */<br />	double angle = (selection.h / 255.0) * -360.0;<br />	Point huepos = circlept(center, rad, angle);<br />	fillellipse(view, huepos, 2, 2, selhueclr, ZP);<br /><br />	/* draw sat */<br />	double distance = (selection.s / 255.0) * rad;<br />	Point satpos = circlept(center, distance, angle);<br />	ellipse(view, center, distance, distance, 0, selclr, ZP);<br />	fillellipse(view, satpos, 2, 2, selclr, ZP);<br />	gradeline(view, huepos, satpos, selhue, selection, 8, ZP);<br /><br />	/* collapse if window is horizontal */<br />	if(size.y &gt; size.x + 2 * pad) {<br />		Rectangle sliderect = Rect(0, size.y - pad * 2, size.x, size.y - pad);<br />		draw(view, sliderect, display-&gt;black, nil, ZP);<br />		gradeline(view,<br />		          addpt(sliderect.min, Pt(pad, pad / 2)),<br />		          addpt(sliderect.max, Pt(-pad, -pad / 2)),<br />		          (HsvColor){selection.h, selection.s, 0},<br />		          (HsvColor){selection.h, selection.s, 255}, 16, ZP);<br />		Point valpos = addpt(sliderect.min, Pt((selection.v / 255.0) * (size.x - 2 * pad) + pad, pad / 2));<br />		fillellipse(view, valpos, 2, 2, selclr, ZP);<br />	}<br /><br />	/* header */<br />	char hexstr[16];<br />	char rgbstr[12];<br />	snprint(hexstr, sizeof(hexstr), "#%02ux%02ux%02ux",<br />	        (selhex &gt;&gt; 24) &amp; 0xFF,<br />	        (selhex &gt;&gt; 16) &amp; 0xFF,<br />	        (selhex &gt;&gt; 8) &amp; 0xFF);<br />	snprint(rgbstr, sizeof(rgbstr), "%ud,%ud,%ud",<br />	        selrgb.r,<br />	        selrgb.g,<br />	        selrgb.b);<br />	Point hexstrsize = stringsize(display-&gt;defaultfont, hexstr);<br />	Point rgbstrsize = stringsize(display-&gt;defaultfont, rgbstr);<br /><br />	/* collapse if window is horizontal */<br />	if(size.y &gt; size.x + 2 * pad) {<br />		Rectangle clearrect = Rect(pad, pad, size.x - pad, 2 * pad);<br />		draw(view, clearrect, display-&gt;black, nil, ZP);<br />		string(view,<br />		       Pt(pad, pad),<br />		       display-&gt;white, ZP, display-&gt;defaultfont, hexstr);<br />		if(hexstrsize.x + rgbstrsize.x &lt; size.x)<br />			string(view,<br />			       Pt(size.x - pad - rgbstrsize.x, pad),<br />			       selclr, ZP, display-&gt;defaultfont, rgbstr);<br />	}<br /><br />	draw(dst, screen-&gt;r, view, nil, ZP);<br />	flushimage(display, 1);<br />	freeimage(selclr);<br />	freeimage(selhueclr);<br />	freeimage(view);<br />}<br /><br />void<br />select(HsvColor clr)<br />{<br />	selection.h = clr.h;<br />	selection.s = clr.s;<br />	selection.v = clr.v;<br />	redraw(screen);<br />}<br /><br />void<br />touch(Point m)<br />{<br />	Rectangle r = screen-&gt;r;<br />	Point center = getcenter(r);<br />	int pad = 20;<br />	int radius = ((Dx(r) &lt; Dy(r) ? Dx(r) : Dy(r)) / 2) - pad;<br />	HsvColor newsel = selection;<br /><br />	if(ptdistance(center, m) &gt; radius) {<br />		int width = (r.max.x - r.min.x) - pad * 2;<br />		Rectangle sliderect = Rect(r.min.x, r.max.y - pad * 2, r.max.x, r.max.y);<br />		if(within(m, sliderect)) {<br />			int touchx = m.x - screen-&gt;r.min.x - pad;<br />			double ratio = touchx / (double)width;<br />			newsel.v = ratio &gt; 1 ? 255.0 : ratio &lt; 0 ? 0 : ratio * 255.0;<br />		} else {<br />			double angle = ptangle(center, m);<br />			newsel.h = (int)(angle / PI / 2 * 255) % 255;<br />		}<br />	} else {<br />		double distance = ptdistance(center, m);<br />		newsel.s = (distance / radius) * 255.0;<br />	}<br />	select(newsel);<br />}<br /><br />int<br />hex2int(char a, char b)<br />{<br />	a = (a &lt;= '9') ? a - '0' : (a &amp; 0x7) + 9;<br />	b = (b &lt;= '9') ? b - '0' : (b &amp; 0x7) + 9;<br />	return (a &lt;&lt; 4) + b;<br />}<br /><br />void<br />dopaste(void)<br />{<br />	char* p;<br />	int f;<br />	if((f = open("/dev/snarf", OREAD)) &gt;= 0) {<br />		char body[8];<br />		read(f, body, 8);<br />		if(body[0] == '#') {<br />			RgbColor rgbclr = (RgbColor){<br />			    hex2int(body[1], body[2]),<br />			    hex2int(body[3], body[4]),<br />			    hex2int(body[5], body[6])};<br />			select(rgb2hsv(rgbclr));<br />		}<br />		close(f);<br />	}<br />}<br /><br />void<br />dosnarf(void)<br />{<br />	int f;<br />	if((f = open("/dev/snarf", OWRITE)) &gt;= 0) {<br />		unsigned int selhex = rgb2hex(hsv2rgb(selection));<br />		char hexstr[16];<br />		snprint(hexstr, sizeof(hexstr), "#%02ux%02ux%02ux",<br />		        (selhex &gt;&gt; 24) &amp; 0xFF,<br />		        (selhex &gt;&gt; 16) &amp; 0xFF,<br />		        (selhex &gt;&gt; 8) &amp; 0xFF);<br />		write(f, hexstr, strlen(hexstr));<br />		close(f);<br />	}<br />}<br />void<br />eresized(int new)<br />{<br />	if(new&amp;&amp; getwindow(display, Refnone) &lt; 0)<br />		fprint(2, "can't reattach to window");<br />	draw(screen, screen-&gt;r, display-&gt;black, nil, ZP);<br />	redraw(screen);<br />}<br /><br />void<br />main(int argc, char* argv[])<br />{<br />	USED(argc, argv);<br />	<br />	Event e;<br />	Mouse m;<br />	Menu menu;<br />	char* mstr[] = {"Snarf", "Paste", "Exit", 0};<br />	int key;<br /><br />	if(initdraw(0, 0, "Color") &lt; 0)<br />		sysfatal("initdraw failed");<br /><br />	/* initial color */<br />	selection.h = 110;<br />	selection.s = 120;<br />	selection.v = 220;<br /><br />	eresized(0);<br />	einit(Emouse);<br />	menu.item = mstr;<br />	menu.lasthit = 0;<br /><br />	redraw(screen);<br /><br />	/* Break on mouse3 */<br />	for(;;) {<br />		key = event(&amp;e);<br />		if(key == Emouse) {<br />			m = e.mouse;<br />			if(m.buttons &amp; 4) {<br />				if(emenuhit(3, &amp;m, &amp;menu) == 0)<br />					dosnarf();<br />				if(emenuhit(3, &amp;m, &amp;menu) == 1)<br />					dopaste();<br />				if(emenuhit(3, &amp;m, &amp;menu) == 2)<br />					exits(0);<br />			} else if(m.buttons &amp; 1) {<br />				touch(m.xy);<br />			}<br />		}<br />	}<br />}</pre>

<ul>
	<li><a href='https://git.sr.ht/~ft/picker' target='_blank'>Another Color Picker</a></li>
</ul>

<ul></ul></main><footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a><a href="http://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2021 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer></body></html>