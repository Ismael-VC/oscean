<!DOCTYPE html><html><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width, inital-scale=1"/><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/>
<title>XXIIVV &mdash; ornithomicon</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>
<nav><ul><li><a href="logic.html" class="parent">logic</a></li><li><a href="arithmetic.html">arithmetic</a></li><li><a href="geometry.html">geometry</a></li><li><a href="language.html">language</a></li><li><a href="computation.html">computation</a></li><li><a href="hardware.html">hardware</a></li></ul><ul><li><a href="ornithomicon.html" class="self">ornithomicon</a></li><li><a href="ornithodex.html">ornithodex</a></li></ul><ul><li><a href="ornithologics.html">ornithologics</a></li></ul></nav><main><h2>The Ornithomicon is the infamous grimoire of Avian Arithmetic.</h2>

<p>Before progressing deeper into the enchanted forest, you should be familiar with the 9 birds of the Bekimet, Becekew and Sekei forests.</p>

<img src="../media/refs/mocking2.png"/>

<h3>Avian Booleans</h3>

<p>The <i>Kestrel</i> takes two words and always selects the first, this is the Avian Binary for <b>True</b>:</p>

<pre><b>K</b><x>▲</x><y>◆</y> <span>&bull;</span> <x>▲</x> <comment>Kxy</comment></pre>

<p>The <i>Kite</i> takes two words and always selects the second, this is the Avian Binary for <b>False</b>:</p>

<pre><b>KI</b><x>▲</x><y>◆</y> <span>&bull;</span> <y>◆</y> <comment>KIxy</comment></pre>

<h3>Avian Bitwise</h3>

<p>The <i>Cardinal</i> takes two words and flips them, this is the Avian Bitwise for <b>NOT</b>:</p>

<pre><b>C</b><b>(</b><b>KI</b><x>▲</x><y>◆</y><b>)</b> <span>&bull;</span> <x>▲</x> <comment>C(Kxy)</comment></pre>

<p>The <i>Mockingbird</i> takes 2 booleans and returns True if at least one of them is True, this is the Avian Bitwise for <b>OR</b>:</p>

<pre><b>M</b><b>(</b><b>KI</b><b>)</b><b>(</b><b>K</b><b>)</b><x>▲</x><y>◆</y> <span>&bull;</span> <x>▲</x> <comment>W(WK)(KI)(K)xy</comment></pre>

<p>To return True, when both words are True, we use a combination of <i>Starlings</i> and a <i>Kestrel</i> to create <b>AND</b>:</p>

<pre><b>S</b><b>S</b><b>K</b><b>(</b><b>KI</b><b>)</b><b>(</b><b>K</b><b>)</b><x>▲</x><y>◆</y> <span>&bull;</span> <y>◆</y> <comment>SSK(KI)(K)xy</comment></pre>

<p>Since <b>True</b> selects the first of 2 words, and <b>False</b> selects the second, we need a way to pass the second and third words to the first one. Therefore, the <i>Idiotbird</i> is the equivalent to the Avian Binary for <b>IfThenElse</b>:</p>

<pre><b>I</b><b>(</b><b>KI</b><b>)</b><x>▲</x><y>◆</y> <span>&bull;</span> <y>◆</y> <comment>I(KI)xy</comment></pre>

<h3>Avian-Human Numerals</h3>

<p>The <i>Kite</i> is the both the boolean False, and the number zero, the <i>Idiotbird</i> is the number 1. These are the <a href='https://en.wikipedia.org/wiki/Church_encoding' target="_blank">Church Encoded</a> numerals, which talking birds only use to communicate numbers to humans who enter the forest.</p>

<table border="1">
	<tr><th>0</th><td>KIfx</td><td>x</td><th>5</th><td>SB(B(WB)(WB))fx</td><td>..</td></tr>
	<tr><th>1</th><td>Ifx</td><td>fx</td><th>6</th><td>B(WB)(SB(WB))fx</td><td>..</td></tr>
	<tr><th>2</th><td>WBfx</td><td>f(fx)</td><th>7</th><td>SB(B(WB)(SB(WB)))fx</td><td>..</td></tr>
	<tr><th>3</th><td>SB(WB)fx</td><td>f(f(fx))</td><th>8</th><td>B(WB)(B(WB)(WB))fx</td><td>..</td></tr>
	<tr><th>4</th><td>B(WB)(WB)fx</td><td>f(f(f(fx)))</td><th>9</th><td>SB(B(WB)(B(WB)(WB)))fx</td><td>..</td></tr>
</table>

<!--

<h3>Y combinator</h3>

<p>Applied to a function with one variable the Y combinator usually does not terminate. More interesting results are obtained by applying the Y combinator to functions of two or more variables. The second variable may be used as a counter, or index. The resulting function behaves like a while or a for loop in an imperative language.</p>

<pre>BM(CBM)fx</pre>

<p>WORK IN PROGRESS</p>

For equals we need a function which takes 2 boolean values and returns True if both of those values are the same.

const equals = p => q => p(q)(not(q));

This function basically reads as:

    If the first value is True, return the second value.
    If the first value is False, return the negation of the second value.


People learn such socially useless things as the names of birds and the grammar of dead languages because they are bored with the mind-dumbing options dished out to them on TV.

In such a fundamental discipline as this, we should not be surprised to find an object which is apparently disappearing up its own fundament.

<h3>Arithmetic</h3>

<pre>
true = K
false = KI
not = V false true = V(KI)K
implies = R true = RK
and = R false = R(KI)
or = T true = TK
equiv = CS not = CS(V(KI)K)
</pre>

-->

<style>
	pre comment { display: inline-block; float:right; color:#777 }
	pre b, pre x, pre y, pre z { display: inline-block;background: white;padding: 2px 5px;margin: 0px 1px;border-radius: 4px; font-size: 20px; }
	pre x, h3 x { color:#f4bd01 }
	pre y, h3 y { color:#c30d0a }
	pre z, h3 z { color:#72dec2 }
	pre span { color:white }
	table .bekimet { background:#f4bd01 }
	table .becekew { background:#f27876 }
	table .sekei { background:#72dec2 }
</style><h2>Ornithologics is the study of Avian Computing.</h2>

<p>WORK IN PROGRESS</p>

<pre>
const I = a => a;
const K = a => b => a;
const S = x => (y => (z => x(z)(y(z))));
const KI = a => b => b;
const C = f => a => b => f(b)(a);
const M = a => a(a);
const B = f => g => a => f(g(a));
const TH = a => b => b(a);
const V = a => b => f => f(a)(b);
const BL = f => g => a => b => f(g(a)(b));
const Y = x => (x(Y(x)));
</pre>

<ul>
	<li><a href="http://people.cs.uchicago.edu/~odonnell/Teacher/Lectures/Formal_Organization_of_Knowledge/Examples/combinator_calculus/" target="_blank">A universal formal system</a></li>
	<li><a href="https://github.com/4y8/ski-in-asm/blob/master/src/main.s" target="_blank">Assembly Implementation</a></li>
	<li><a href="https://crypto.stanford.edu/~blynn/lambda/sk.html" target="_blank">A Combinatory Compiler</a></li>
	<li><a href="https://www.willtaylor.blog/combinators-and-church-encoding-in-javscript/" target="_blank">Combinators and Church Encoding</a></li>
	<li><a href="https://blog.ngzhian.com/ski.html" target="_blank">SKI Stack Machine</a></li>
	<li><a href="https://paste.sr.ht/~rabbits/fd54369521fcf3f245f52bfd70834cffcc0be3b6" target="_blank">Javascript REPL</a></li>
	<li><a href="http://tunes.org/~iepos/joy.html" target="_blank">The Theory of Concatenative Combinators</a></li>
</ul>
<ul></ul></main>
<footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a> <a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a> <a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a> <a href="ethics.html"><img src="../media/icon/dreipfeile.svg" alt="NoNazis!"/></a> <a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a> <span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2022 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer>
</body></html>