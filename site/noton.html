<!DOCTYPE html><html><head><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/><title>XXIIVV &mdash; noton</title></head><body><header><a href="home.html"><img src="../media/icon/logo.svg" alt="XXIIVV"/></a></header><nav><ul><li><a href="../site/paper_computing.html">paper computing</a></li><li><a href="../site/programming.html">programming</a></li><li><a href="../site/virtual_machines.html">virtual machines</a></li><li><a href="../site/cellular_automata.html">cellular automata</a></li><li><a href="../site/fluidics.html">fluidics</a></li><li><a href="../site/fractals.html">fractals</a></li></ul><ul><li><a href="../site/fractran.html">fractran</a></li><li><a href="../site/gyo.html">gyo</a></li><li><a href="../site/uxn.html">uxn</a></li><li>noton/</li></ul><ul></ul></nav><main><figure><img src="../media/diary/668.jpg" alt="Noton Release"/><figcaption>Noton Release</figcaption></figure><h2>Noton is a livedrawing playground.</h2>

<p>Noton works by drawing cables between timers, logic gates and instruments inspired from pepep√©pepe's <a href='paper_computing.html'>Color Computers</a> to explore <a href='binary.html'>binary logic</a>.</p>
<p>Right-click to add nodes, and left-click to add wires. Nodes will emit a positive signal if all the connected wires have the same polarity. The screen has timers to the left, and notes to the right. The default timers are 6 trackers, 4 sequencers and 2 pools.</p>
<iframe width='624' height='380' src='https://www.youtube.com/embed/dhWNmAEcdcU?rel=0' style='max-width:700px' frameborder='0' allow='autoplay; encrypted-media' allowfullscreen></iframe>
<h3>noton.c</h3>
<p>The following code is a single-file implementation written in a few lines of <a href='ansi_c.html'>ANSI C</a>, the only dependencies are <a href='https://www.libsdl.org' target='_blank'>SDL2</a> and <a href='http://portmedia.sourceforge.net/portmidi' target='_blank'>PortMidi</a>. Read the manual <a href='https://git.sr.ht/~rabbits/noton' target='_blank'>here</a>.</p>
<pre>cc noton.c -std=c89 -Os -DNDEBUG -g0 -s -Wall -L/usr/local/lib -lSDL2 -lportmidi -o noton</pre>
<pre>#include &lt;SDL2/SDL.h&gt;<br />#include &lt;portmidi.h&gt;<br />#include &lt;porttime.h&gt;<br />#include &lt;stdio.h&gt;<br /><br />/* <br />Copyright (c) 2020 Devine Lu Linvega<br /><br />Permission to use, copy, modify, and distribute this software for any<br />purpose with or without fee is hereby granted, provided that the above<br />copyright notice and this permission notice appear in all copies.<br /><br />THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES<br />WITH REGARD TO THIS SOFTWARE.<br />*/<br /><br />#define HOR 32<br />#define VER 16<br />#define PAD 2<br />#define SZ (HOR * VER * 16)<br /><br />typedef unsigned char Uint8;<br /><br />#define GATEMAX 128<br />#define WIREMAX 256<br />#define WIREPTMAX 128<br />#define PORTMAX 32<br />#define INPUTMAX 12<br />#define OUTPUTMAX 12<br /><br />#define CHANNELS 6<br />#define DEVICE 0<br /><br />typedef enum {<br />	INPUT,<br />	OUTPUT,<br />	POOL,<br />	BASIC<br />} GateType;<br /><br />typedef struct {<br />	int x, y;<br />} Point2d;<br /><br />typedef struct Wire {<br />	int id, polarity, a, b, len, flex;<br />	Point2d points[WIREPTMAX];<br />} Wire;<br /><br />typedef struct Gate {<br />	int id, polarity, locked, inlen, outlen, channel, note, sharp;<br />	Point2d pos;<br />	GateType type;<br />	Wire *inputs[PORTMAX], *outputs[PORTMAX];<br />} Gate;<br /><br />typedef struct Noton {<br />	int alive, frame, channel, octave, glen, wlen;<br />	unsigned int speed;<br />	Gate gates[GATEMAX];<br />	Wire wires[WIREMAX];<br />	Gate *inputs[INPUTMAX], *outputs[OUTPUTMAX];<br />	PmStream *midi;<br />} Noton;<br /><br />typedef struct Brush {<br />	int down;<br />	Point2d pos;<br />	Wire wire;<br />} Brush;<br /><br />int WIDTH = 8 * HOR + 8 * PAD * 2;<br />int HEIGHT = 8 * (VER + 2) + 8 * PAD * 2;<br />int ZOOM = 2, GUIDES = 1;<br /><br />Noton noton;<br />Brush brush;<br /><br />Uint32 theme[] = {<br />	0x000000,<br />	0xffb545,<br />	0x72DEC2,<br />	0xffffff,<br />	0x222222};<br /><br />Uint8 icons[][8] = {<br />	{0x38, 0x7c, 0xee, 0xd6, 0xee, 0x7c, 0x38, 0x00}, /* gate:input */<br />	{0x38, 0x44, 0x92, 0xaa, 0x92, 0x44, 0x38, 0x00}, /* gate:output */<br />	{0x38, 0x44, 0x82, 0x92, 0x82, 0x44, 0x38, 0x00}, /* gate:output-sharp */<br />	{0x38, 0x7c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x00}, /* gate:binary */<br />	{0x10, 0x00, 0x10, 0xaa, 0x10, 0x00, 0x10, 0x00}, /* guide */<br />	{0x00, 0x00, 0x00, 0x82, 0x44, 0x38, 0x00, 0x00}, /* eye open */<br />	{0x00, 0x38, 0x44, 0x92, 0x28, 0x10, 0x00, 0x00}, /* eye closed */<br />	{0x10, 0x54, 0x28, 0xc6, 0x28, 0x54, 0x10, 0x00}  /* unsaved */<br />};<br /><br />SDL_Window *gWindow = NULL;<br />SDL_Renderer *gRenderer = NULL;<br />SDL_Texture *gTexture = NULL;<br />Uint32 *pixels;<br /><br />#pragma mark - Helpers<br /><br />int<br />distance(Point2d a, Point2d b)<br />{<br />	return (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);<br />}<br /><br />Point2d *<br />setpt2d(Point2d *p, int x, int y)<br />{<br />	p-&gt;x = x;<br />	p-&gt;y = y;<br />	return p;<br />}<br /><br />Point2d *<br />clamp2d(Point2d *p, int step)<br />{<br />	return setpt2d(p, p-&gt;x / step * step, p-&gt;y / step * step);<br />}<br /><br />Point2d<br />Pt2d(int x, int y)<br />{<br />	Point2d p;<br />	setpt2d(&amp;p, x, y);<br />	return p;<br />}<br /><br />#pragma mark - Midi<br /><br />void<br />initmidi(void)<br />{<br />	int i;<br />	Pm_Initialize();<br />	for(i = 0; i &lt; Pm_CountDevices(); ++i) {<br />		char const *name = Pm_GetDeviceInfo(i)-&gt;name;<br />		printf("Device #%d -&gt; %s%s\n", i, name, i == DEVICE ? "[x]" : "[ ]");<br />	}<br />	Pm_OpenOutput(&amp;noton.midi, DEVICE, NULL, 128, 0, NULL, 1);<br />}<br /><br />void<br />playmidi(int channel, int octave, int note, int z)<br />{<br />	Pm_WriteShort(noton.midi,<br />		Pt_Time(),<br />		Pm_Message(0x90 + channel, (octave * 12) + note, z ? 100 : 0));<br />}<br /><br />#pragma mark - Generics<br /><br />Gate *<br />nearestgate(Noton *n, Point2d pos)<br />{<br />	int i;<br />	for(i = 0; i &lt; n-&gt;glen; ++i) {<br />		Gate *g = &amp;n-&gt;gates[i];<br />		if(distance(pos, g-&gt;pos) &lt; 50)<br />			return g;<br />	}<br />	return NULL;<br />}<br /><br />Gate *<br />gateat(Noton *n, Point2d pos)<br />{<br />	int i;<br />	for(i = 0; i &lt; n-&gt;glen; ++i) {<br />		Gate *g = &amp;n-&gt;gates[i];<br />		if(pos.x == g-&gt;pos.x &amp;&amp; pos.y == g-&gt;pos.y)<br />			return g;<br />	}<br />	return NULL;<br />}<br /><br />int<br />getpolarity(Gate *g)<br />{<br />	int i;<br />	if(g-&gt;inlen &lt; 1)<br />		return -1;<br />	if(g-&gt;inlen == 1)<br />		return g-&gt;inputs[0]-&gt;polarity;<br />	for(i = 0; i &lt; g-&gt;inlen; i++)<br />		if(g-&gt;inputs[i]-&gt;polarity != g-&gt;inputs[0]-&gt;polarity)<br />			return 0;<br />	return 1;<br />}<br /><br />void<br />polarize(Gate *g)<br />{<br />	int i;<br />	if(g-&gt;type == OUTPUT) {<br />		int newpolarity = getpolarity(g);<br />		if(newpolarity != -1 &amp;&amp; g-&gt;polarity != newpolarity)<br />			playmidi(noton.channel + g-&gt;channel, noton.octave, g-&gt;note, newpolarity);<br />		g-&gt;polarity = newpolarity;<br />	} else if(g-&gt;type == BASIC)<br />		g-&gt;polarity = getpolarity(g);<br />	for(i = 0; i &lt; g-&gt;outlen; ++i)<br />		g-&gt;outputs[i]-&gt;polarity = g-&gt;polarity;<br />}<br /><br />void<br />bang(Gate *g, int depth)<br />{<br />	int i, d = depth - 1;<br />	if(d &amp;&amp; g) {<br />		polarize(g);<br />		if(g-&gt;type != OUTPUT)<br />			return;<br />		for(i = 0; i &lt; g-&gt;outlen; ++i)<br />			if(&amp;noton.gates[g-&gt;outputs[i]-&gt;b])<br />				bang(&amp;noton.gates[g-&gt;outputs[i]-&gt;b], d);<br />	}<br />}<br /><br />void<br />flex(Wire *w)<br />{<br />	int i;<br />	if(w-&gt;len &lt; 3 || !w-&gt;flex || noton.frame % 15 != 0)<br />		return;<br />	for(i = 1; i &lt; w-&gt;len - 1; ++i) {<br />		Point2d *a = &amp;w-&gt;points[i - 1];<br />		Point2d *b = &amp;w-&gt;points[i];<br />		Point2d *c = &amp;w-&gt;points[i + 1];<br />		b-&gt;x = (a-&gt;x + b-&gt;x + c-&gt;x) / 3;<br />		b-&gt;y = (a-&gt;y + b-&gt;y + c-&gt;y) / 3;<br />	}<br />	w-&gt;flex--;<br />}<br /><br />#pragma mark - Options<br /><br />void<br />selchan(Noton *n, int channel)<br />{<br />	n-&gt;channel = channel;<br />	printf("Select channel #%d\n", n-&gt;channel);<br />}<br /><br />void<br />modoct(Noton *n, int mod)<br />{<br />	if((n-&gt;octave &gt; 0 &amp;&amp; mod &lt; 0) || (n-&gt;octave &lt; 8 &amp;&amp; mod &gt; 0))<br />		n-&gt;octave += mod;<br />	printf("Select octave #%d\n", n-&gt;octave);<br />}<br /><br />void<br />modspeed(Noton *n, int mod)<br />{<br />	if((n-&gt;speed &gt; 10 &amp;&amp; mod &lt; 0) || (n-&gt;speed &lt; 100 &amp;&amp; mod &gt; 0))<br />		n-&gt;speed += mod;<br />	printf("Select speed #%d\n", n-&gt;speed);<br />}<br /><br />void<br />pause(Noton *n)<br />{<br />	n-&gt;alive = !n-&gt;alive;<br />	printf("%s\n", n-&gt;alive ? "Playing.." : "Paused.");<br />}<br /><br />void<br />reset(Noton *n)<br />{<br />	int i, locked = 0;<br />	for(i = 0; i &lt; n-&gt;wlen; i++)<br />		n-&gt;wires[i].len = 0;<br />	for(i = 0; i &lt; n-&gt;glen; i++) {<br />		n-&gt;gates[i].inlen = 0;<br />		n-&gt;gates[i].outlen = 0;<br />		if(n-&gt;gates[i].locked)<br />			locked++;<br />	}<br />	n-&gt;wlen = 0;<br />	n-&gt;glen = locked;<br />	n-&gt;alive = 1;<br />}<br /><br />/* Add/Remove */<br /><br />Wire *<br />addwire(Noton *n, Wire *temp, Gate *from, Gate *to)<br />{<br />	int i;<br />	Wire *w = &amp;n-&gt;wires[n-&gt;wlen];<br />	w-&gt;id = n-&gt;wlen++;<br />	w-&gt;polarity = -1;<br />	w-&gt;a = from-&gt;id;<br />	w-&gt;b = to-&gt;id;<br />	w-&gt;len = 0;<br />	w-&gt;flex = 4;<br />	for(i = 0; i &lt; temp-&gt;len; i++)<br />		setpt2d(&amp;w-&gt;points[w-&gt;len++], temp-&gt;points[i].x, temp-&gt;points[i].y);<br />	printf("Add wire #%d(#%d-&gt;#%d) \n", w-&gt;id, from-&gt;id, to-&gt;id);<br />	return w;<br />}<br /><br />Gate *<br />addgate(Noton *n, GateType type, int polarity, Point2d pos)<br />{<br />	Gate *g = &amp;n-&gt;gates[n-&gt;glen];<br />	g-&gt;id = n-&gt;glen++;<br />	g-&gt;polarity = polarity;<br />	g-&gt;channel = 0;<br />	g-&gt;note = 0;<br />	g-&gt;sharp = 0;<br />	g-&gt;inlen = 0;<br />	g-&gt;outlen = 0;<br />	g-&gt;type = type;<br />	setpt2d(&amp;g-&gt;pos, pos.x, pos.y);<br />	printf("Add gate #%d \n", g-&gt;id);<br />	return g;<br />}<br /><br />/* Wiring */<br /><br />int<br />extendwire(Brush *b)<br />{<br />	if(b-&gt;wire.len &gt;= WIREPTMAX)<br />		return 0;<br />	if(distance(b-&gt;wire.points[b-&gt;wire.len - 1], b-&gt;pos) &lt; 20)<br />		return 0;<br />	setpt2d(&amp;b-&gt;wire.points[b-&gt;wire.len++], b-&gt;pos.x, b-&gt;pos.y);<br />	return 1;<br />}<br /><br />int<br />beginwire(Brush *b)<br />{<br />	Gate *gate = nearestgate(&amp;noton, b-&gt;pos);<br />	Point2d *p = gate ? &amp;gate-&gt;pos : &amp;b-&gt;pos;<br />	b-&gt;wire.polarity = gate ? gate-&gt;polarity : -1;<br />	b-&gt;wire.len = 0;<br />	setpt2d(&amp;b-&gt;wire.points[b-&gt;wire.len++], p-&gt;x + 4, p-&gt;y + 4);<br />	return 1;<br />}<br /><br />int<br />abandon(Brush *b)<br />{<br />	b-&gt;wire.len = 0;<br />	return 1;<br />}<br /><br />int<br />endwire(Brush *b)<br />{<br />	Wire *newwire;<br />	Gate *gatefrom, *gateto;<br />	Point2d offset = Pt2d(b-&gt;pos.x - 4, b-&gt;pos.y - 4);<br />	if(b-&gt;wire.len &lt; 1)<br />		return abandon(b);<br />	gatefrom = nearestgate(&amp;noton, b-&gt;wire.points[0]);<br />	if(!gatefrom || gatefrom-&gt;outlen &gt;= PORTMAX)<br />		return abandon(b);<br />	if(gatefrom-&gt;type == OUTPUT)<br />		return abandon(b);<br />	gateto = nearestgate(&amp;noton, offset);<br />	if(!gateto || gateto-&gt;inlen &gt;= PORTMAX)<br />		return abandon(b);<br />	if(gateto-&gt;type == INPUT || gatefrom == gateto)<br />		return abandon(b);<br />	setpt2d(&amp;b-&gt;pos, gateto-&gt;pos.x + 4, gateto-&gt;pos.y + 4);<br />	extendwire(b);<br />	newwire = addwire(&amp;noton, &amp;b-&gt;wire, gatefrom, gateto);<br />	gatefrom-&gt;outputs[gatefrom-&gt;outlen++] = newwire;<br />	gateto-&gt;inputs[gateto-&gt;inlen++] = newwire;<br />	return abandon(b);<br />}<br /><br />#pragma mark - Draw<br /><br />void<br />putpixel(Uint32 *dst, int x, int y, int color)<br />{<br />	if(x &gt;= 0 &amp;&amp; x &lt; WIDTH - 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; HEIGHT - 8)<br />		dst[(y + PAD * 8) * WIDTH + (x + PAD * 8)] = theme[color];<br />}<br /><br />void<br />line(Uint32 *dst, int ax, int ay, int bx, int by, int color)<br />{<br />	int dx = abs(bx - ax), sx = ax &lt; bx ? 1 : -1;<br />	int dy = -abs(by - ay), sy = ay &lt; by ? 1 : -1;<br />	int err = dx + dy, e2;<br />	for(;;) {<br />		putpixel(dst, ax, ay, color);<br />		if(ax == bx &amp;&amp; ay == by)<br />			break;<br />		e2 = 2 * err;<br />		if(e2 &gt;= dy) {<br />			err += dy;<br />			ax += sx;<br />		}<br />		if(e2 &lt;= dx) {<br />			err += dx;<br />			ay += sy;<br />		}<br />	}<br />}<br /><br />void<br />drawicn(Uint32 *dst, int x, int y, Uint8 *sprite, int fg, int bg)<br />{<br />	int v, h;<br />	for(v = 0; v &lt; 8; v++)<br />		for(h = 0; h &lt; 8; h++) {<br />			int ch1 = (sprite[v] &gt;&gt; (7 - h)) &amp; 0x1;<br />			putpixel(dst, x + h, y + v, ch1 ? fg : bg);<br />		}<br />}<br /><br />void<br />drawgate(Uint32 *dst, Gate *g)<br />{<br />	switch(g-&gt;type) {<br />	case OUTPUT:<br />		drawicn(dst, g-&gt;pos.x, g-&gt;pos.y, icons[1 + g-&gt;sharp], g-&gt;polarity + 1 + g-&gt;sharp + 1, 0);<br />		break;<br />	case INPUT:<br />		drawicn(dst, g-&gt;pos.x, g-&gt;pos.y, icons[0], g-&gt;polarity + 1, 0);<br />		break;<br />	case POOL:<br />		drawicn(dst, g-&gt;pos.x, g-&gt;pos.y, icons[3], g-&gt;polarity + 1, 0);<br />		break;<br />	case BASIC:<br />		drawicn(dst, g-&gt;pos.x, g-&gt;pos.y, icons[3], g-&gt;polarity &lt; 0 ? 3 : g-&gt;polarity + 1, 0);<br />		break;<br />	}<br />}<br /><br />void<br />drawwire(Uint32 *dst, Wire *w, int color)<br />{<br />	int i;<br />	if(w-&gt;len &lt; 2)<br />		return;<br />	for(i = 0; i &lt; w-&gt;len - 1; i++) {<br />		Point2d *p1 = &amp;w-&gt;points[i];<br />		Point2d *p2 = &amp;w-&gt;points[i + 1];<br />		line(dst, p1-&gt;x, p1-&gt;y, p2-&gt;x, p2-&gt;y, w-&gt;polarity == -1 ? 4 : (int)(noton.frame / 3) % w-&gt;len != i ? w-&gt;polarity + 1<br />																										   : color);<br />	}<br />}<br /><br />void<br />drawguides(Uint32 *dst)<br />{<br />	int x, y;<br />	for(x = 0; x &lt; HOR; x++)<br />		for(y = 0; y &lt; VER; y++)<br />			drawicn(dst, x * 8, y * 8, icons[4], 4, 0);<br />}<br /><br />void<br />drawui(Uint32 *dst)<br />{<br />	int bottom = VER * 8 + 8;<br />	drawicn(dst, 0 * 8, bottom, icons[GUIDES ? 6 : 5], GUIDES ? 1 : 2, 0);<br />}<br /><br />void<br />clear(Uint32 *dst)<br />{<br />	int i, j;<br />	for(i = 0; i &lt; HEIGHT; i++)<br />		for(j = 0; j &lt; WIDTH; j++)<br />			dst[i * WIDTH + j] = theme[0];<br />}<br /><br />void<br />redraw(Uint32 *dst)<br />{<br />	int i;<br />	clear(dst);<br />	if(GUIDES)<br />		drawguides(dst);<br />	for(i = 0; i &lt; noton.glen; i++)<br />		drawgate(dst, &amp;noton.gates[i]);<br />	for(i = 0; i &lt; noton.wlen; i++)<br />		drawwire(dst, &amp;noton.wires[i], 3);<br />	drawwire(dst, &amp;brush.wire, 3);<br />	drawui(dst);<br />	SDL_UpdateTexture(gTexture, NULL, dst, WIDTH * sizeof(Uint32));<br />	SDL_RenderClear(gRenderer);<br />	SDL_RenderCopy(gRenderer, gTexture, NULL, NULL);<br />	SDL_RenderPresent(gRenderer);<br />}<br /><br />/* operation */<br /><br />void<br />savemode(int *i, int v)<br />{<br />	*i = v;<br />	redraw(pixels);<br />}<br /><br />void<br />selectoption(int option)<br />{<br />	switch(option) {<br />	case 0: savemode(&amp;GUIDES, !GUIDES); break;<br />	}<br />}<br /><br />void<br />run(Noton *n)<br />{<br />	int i;<br />	n-&gt;inputs[0]-&gt;polarity = (n-&gt;frame &gt;&gt; 2) % 2 == 0;<br />	n-&gt;inputs[2]-&gt;polarity = (n-&gt;frame &gt;&gt; 3) % 2 == 0;<br />	n-&gt;inputs[4]-&gt;polarity = (n-&gt;frame &gt;&gt; 4) % 2 == 0;<br />	n-&gt;inputs[6]-&gt;polarity = (n-&gt;frame &gt;&gt; 5) % 2 == 0;<br />	n-&gt;inputs[8]-&gt;polarity = (n-&gt;frame &gt;&gt; 6) % 2 == 0;<br />	n-&gt;inputs[10]-&gt;polarity = (n-&gt;frame &gt;&gt; 7) % 2 == 0;<br />	n-&gt;inputs[1]-&gt;polarity = (n-&gt;frame &gt;&gt; 3) % 4 == 0;<br />	n-&gt;inputs[3]-&gt;polarity = (n-&gt;frame &gt;&gt; 3) % 4 == 1;<br />	n-&gt;inputs[5]-&gt;polarity = (n-&gt;frame &gt;&gt; 3) % 4 == 2;<br />	n-&gt;inputs[7]-&gt;polarity = (n-&gt;frame &gt;&gt; 3) % 4 == 3;<br />	n-&gt;inputs[9]-&gt;polarity = 1;<br />	n-&gt;inputs[11]-&gt;polarity = 0;<br />	for(i = 0; i &lt; n-&gt;glen; ++i)<br />		bang(&amp;n-&gt;gates[i], 10);<br />	for(i = 0; i &lt; n-&gt;wlen; ++i)<br />		flex(&amp;n-&gt;wires[i]);<br />	n-&gt;frame++;<br />}<br /><br />void<br />setup(Noton *n)<br />{<br />	int i, j;<br />	int sharps[12] = {0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0};<br />	for(i = 0; i &lt; INPUTMAX; ++i) {<br />		int x = i % 2 == 0 ? 16 : 8;<br />		n-&gt;inputs[i] = addgate(n, INPUT, 0, Pt2d(x, 16 + i * 8));<br />		n-&gt;inputs[i]-&gt;locked = 1;<br />	}<br />	for(i = 0; i &lt; CHANNELS; ++i) {<br />		for(j = 0; j &lt; OUTPUTMAX; ++j) {<br />			int x = HOR * 8 - (j % 2 == 0 ? 24 : 16) - (i * 16);<br />			n-&gt;outputs[j] = addgate(n, OUTPUT, 0, Pt2d(x, 16 + j * 8));<br />			n-&gt;outputs[j]-&gt;locked = 1;<br />			n-&gt;outputs[j]-&gt;note = j + ((i % 3) * 24);<br />			n-&gt;outputs[j]-&gt;channel = i;<br />			n-&gt;outputs[j]-&gt;sharp = sharps[abs(n-&gt;outputs[j]-&gt;note) % 12];<br />		}<br />	}<br />	n-&gt;inputs[9]-&gt;type = POOL;<br />	n-&gt;inputs[11]-&gt;type = POOL;<br />}<br /><br />/* options */<br /><br />int<br />error(char *msg, const char *err)<br />{<br />	printf("Error %s: %s\n", msg, err);<br />	return 0;<br />}<br /><br />void<br />modzoom(int mod)<br />{<br />	if((mod &gt; 0 &amp;&amp; ZOOM &lt; 4) || (mod &lt; 0 &amp;&amp; ZOOM &gt; 1)) {<br />		ZOOM += mod;<br />		SDL_SetWindowSize(gWindow, WIDTH * ZOOM, HEIGHT * ZOOM);<br />	}<br />}<br /><br />void<br />quit(void)<br />{<br />	free(pixels);<br />	Pm_Terminate();<br />	SDL_DestroyTexture(gTexture);<br />	gTexture = NULL;<br />	SDL_DestroyRenderer(gRenderer);<br />	gRenderer = NULL;<br />	SDL_DestroyWindow(gWindow);<br />	gWindow = NULL;<br />	SDL_Quit();<br />	exit(0);<br />}<br /><br />#pragma mark - Triggers<br /><br />void<br />domouse(SDL_Event *event)<br />{<br />	setpt2d(&amp;brush.pos,<br />		(event-&gt;motion.x - (PAD * 8 * ZOOM)) / ZOOM,<br />		(event-&gt;motion.y - (PAD * 8 * ZOOM)) / ZOOM);<br />	switch(event-&gt;type) {<br />	case SDL_MOUSEBUTTONDOWN:<br />		if(event-&gt;motion.y / ZOOM / 8 - PAD == VER + 1) {<br />			selectoption(event-&gt;motion.x / ZOOM / 8 - PAD);<br />			break;<br />		}<br />		if(event-&gt;button.button == SDL_BUTTON_RIGHT)<br />			break;<br />		brush.down = 1;<br />		if(beginwire(&amp;brush))<br />			redraw(pixels);<br />		break;<br />	case SDL_MOUSEMOTION:<br />		if(event-&gt;button.button == SDL_BUTTON_RIGHT)<br />			break;<br />		if(brush.down) {<br />			if(extendwire(&amp;brush))<br />				redraw(pixels);<br />		}<br />		break;<br />	case SDL_MOUSEBUTTONUP:<br />		if(event-&gt;button.button == SDL_BUTTON_RIGHT) {<br />			if(brush.pos.x &lt; 24 || brush.pos.x &gt; HOR * 8 - 72)<br />				return;<br />			if(brush.pos.x &gt; HOR * 8 || brush.pos.y &gt; VER * 8)<br />				return;<br />			if(!gateat(&amp;noton, *clamp2d(&amp;brush.pos, 8)))<br />				addgate(&amp;noton, BASIC, -1, *clamp2d(&amp;brush.pos, 8));<br />			redraw(pixels);<br />			break;<br />		}<br />		brush.down = 0;<br />		if(endwire(&amp;brush))<br />			redraw(pixels);<br />		break;<br />	}<br />}<br /><br />void<br />dokey(SDL_Event *event)<br />{<br />	switch(event-&gt;key.keysym.sym) {<br />	case SDLK_EQUALS:<br />	case SDLK_PLUS: modzoom(1); break;<br />	case SDLK_UNDERSCORE:<br />	case SDLK_MINUS: modzoom(-1); break;<br />	case SDLK_BACKSPACE: reset(&amp;noton); break;<br />	case SDLK_SPACE: pause(&amp;noton); break;<br />	case SDLK_UP: modoct(&amp;noton, 1); break;<br />	case SDLK_DOWN: modoct(&amp;noton, -1); break;<br />	case SDLK_LEFT: modspeed(&amp;noton, 5); break;<br />	case SDLK_RIGHT: modspeed(&amp;noton, -5); break;<br />	case SDLK_1: selchan(&amp;noton, 0); break;<br />	case SDLK_2: selchan(&amp;noton, 1); break;<br />	case SDLK_3: selchan(&amp;noton, 2); break;<br />	case SDLK_4: selchan(&amp;noton, 3); break;<br />	case SDLK_5: selchan(&amp;noton, 4); break;<br />	case SDLK_6: selchan(&amp;noton, 5); break;<br />	case SDLK_7: selchan(&amp;noton, 6); break;<br />	case SDLK_8: selchan(&amp;noton, 7); break;<br />	case SDLK_9: selchan(&amp;noton, 8); break;<br />	}<br />}<br /><br />int<br />init(void)<br />{<br />	if(SDL_Init(SDL_INIT_VIDEO) &lt; 0)<br />		return error("Init", SDL_GetError());<br />	gWindow = SDL_CreateWindow("Noton",<br />		SDL_WINDOWPOS_UNDEFINED,<br />		SDL_WINDOWPOS_UNDEFINED,<br />		WIDTH * ZOOM,<br />		HEIGHT * ZOOM,<br />		SDL_WINDOW_SHOWN);<br />	if(gWindow == NULL)<br />		return error("Window", SDL_GetError());<br />	gRenderer = SDL_CreateRenderer(gWindow, -1, 0);<br />	if(gRenderer == NULL)<br />		return error("Renderer", SDL_GetError());<br />	gTexture = SDL_CreateTexture(gRenderer,<br />		SDL_PIXELFORMAT_ARGB8888,<br />		SDL_TEXTUREACCESS_STATIC,<br />		WIDTH,<br />		HEIGHT);<br />	if(gTexture == NULL)<br />		return error("Texture", SDL_GetError());<br />	pixels = (Uint32 *)malloc(WIDTH * HEIGHT * sizeof(Uint32));<br />	if(pixels == NULL)<br />		return error("Pixels", "Failed to allocate memory");<br />	clear(pixels);<br />	initmidi();<br />	return 1;<br />}<br /><br />int<br />main(int argc, char **argv)<br />{<br />	Uint32 begintime = 0;<br />	Uint32 endtime = 0;<br />	Uint32 delta = 0;<br /><br />	noton.alive = 1;<br />	noton.speed = 40;<br />	noton.channel = 0;<br />	noton.octave = 2;<br /><br />	if(!init())<br />		return error("Init", "Failure");<br /><br />	setup(&amp;noton);<br /><br />	while(1) {<br />		SDL_Event event;<br />		if(!begintime)<br />			begintime = SDL_GetTicks();<br />		else<br />			delta = endtime - begintime;<br /><br />		if(delta &lt; noton.speed)<br />			SDL_Delay(noton.speed - delta);<br /><br />		if(noton.alive) {<br />			run(&amp;noton);<br />			redraw(pixels);<br />		}<br /><br />		while(SDL_PollEvent(&amp;event) != 0) {<br />			switch(event.type) {<br />			case SDL_QUIT: quit(); break;<br />			case SDL_MOUSEBUTTONUP:<br />			case SDL_MOUSEBUTTONDOWN:<br />			case SDL_MOUSEMOTION: domouse(&amp;event); break;<br />			case SDL_KEYDOWN: dokey(&amp;event); break;<br />			case SDL_WINDOWEVENT:<br />				if(event.window.event == SDL_WINDOWEVENT_EXPOSED)<br />					redraw(pixels);<br />				break;<br />			}<br />		}<br />		begintime = endtime;<br />		endtime = SDL_GetTicks();<br />	}<br />	quit();<br />	(void)argc;<br />	(void)argv;<br />	return 0;<br />}<br /></pre>

<h3>Sequencing</h3>

<p>For example, if we wanted to play C3 every 2nd and 6th note, every 8 bars. We can combine two tracker nodes.</p>

<table border='1'>
	<tr><th>time</th><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr>
	<tr><th>Track 2/4 + <span style='background:#f00'>false pool</span></th><td>1</td><td style='background:#eee'>0</td><td>1</td><td style='background:#eee'>0</td><td>1</td><td style='background:#eee'>0</td><td>1</td><td style='background:#eee'>0</td></tr>
	<tr><th>Track 3/4</th><td style='background:#eee' colspan='2'>1</td><td colspan='2'>0</td><td style='background:#eee' colspan='2'>1</td><td colspan='2'>0</td></tr>
	<tr><th><span style='background:#72dec2'>true pool</span></th><td>0</td><td style='background:#eee'>1</td><td>0</td><td>0</td><td>0</td><td style='background:#eee'>1</td><td>0</td><td>0</td></tr>
</table>

<img src='../media/generic/noton.logic.jpg'/><ul>
	<li><a href='https://git.sr.ht/~rabbits/noton' target='_blank'>source</a></li>
	<li><a href='https://llllllll.co/t/noton-livedrawing-tool/38429' target='_blank'>forum</a></li>
</ul>

<ul><li>Noton Release</li></ul></main><footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a><a href="http://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2021 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer></body></html>