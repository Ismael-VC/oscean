<!DOCTYPE html><html><head><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/><title>XXIIVV &mdash; dito</title></head><body><header><a href="home.html"><img src="../media/icon/logo.svg" alt="XXIIVV"/></a></header><nav><ul><li><a href="../site/roms.html">roms</a></li><li><a href="../site/tools.html">tools</a></li><li><a href="../site/utilities.html">utilities</a></li><li><a href="../site/formats.html">formats</a></li><li><a href="../site/games.html">games</a></li><li><a href="../site/toys.html">toys</a></li><li><a href="../site/mobile.html">mobile</a></li><li><a href="../site/unreleased.html">unreleased</a></li></ul><ul><li>dito/</li><li><a href="../site/dotgrid.html">dotgrid</a></li><li><a href="../site/ronin.html">ronin</a></li><li><a href="../site/moogle.html">moogle</a></li></ul><ul></ul></nav><main><figure><img src="../media/diary/737.jpg" alt="Dito Desktop Release"/><figcaption>Dito Desktop Release</figcaption></figure><h2>Dito is an image dithering editor.</h2>

<p>Dito is a tool to convert bmp images to the <a href='chr_format.html'>.chr format</a>, designed to be used with <a href='nasu.html'>Nasu</a> for the creation of <a href='famicom.html'>Famicom</a> projects.</p>
<p>The application works by defining a range of 4 colors, each pixel of the original image will snap to the nearest color selected by one of the four color pickers.</p>
<iframe width='624' height='380' src='https://www.youtube.com/embed/BabcL8F5rDU?rel=0' style='max-width:700px' frameborder='0' allow='autoplay; encrypted-media' allowfullscreen></iframe>
<h3>dito.c</h3>
<p>To learn more, see the complete manual in the <a href='https://git.sr.ht/~rabbits/dito' target='_blank'>repository</a>.</p>
<pre>cc dito.c -std=c89 -Os -DNDEBUG -g0 -s -Wall -L/usr/local/lib -lSDL2 -o dito</pre>
<p>The following code is a single-file implementation written <a href='ansi_c.html'>ANSI C</a> with <a href='https://www.libsdl.org' target='_blank'>SDL2</a> as its only dependecy.</p>
<pre>#include &lt;SDL2/SDL.h&gt;<br />#include &lt;stdio.h&gt;<br /><br />/* <br />Copyright (c) 2020 Devine Lu Linvega<br /><br />Permission to use, copy, modify, and distribute this software for any<br />purpose with or without fee is hereby granted, provided that the above<br />copyright notice and this permission notice appear in all copies.<br /><br />THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES<br />WITH REGARD TO THIS SOFTWARE.<br />*/<br /><br />#define HOR 32<br />#define VER 16<br />#define PAD 2<br />#define SZ (HOR * VER * 16)<br /><br />typedef unsigned char Uint8;<br /><br />typedef struct {<br />	int unsaved;<br />	char name[256];<br />	Uint8 data[SZ];<br />} Document;<br /><br />typedef struct {<br />	int w, h;<br />} Size2d;<br /><br />typedef struct {<br />	int x, y;<br />} Point2d;<br /><br />int WIDTH = 8 * HOR + 8 * PAD * 2;<br />int HEIGHT = 8 * (VER + 2) + 8 * PAD * 2;<br />int FPS = 30, GUIDES = 1, DOWN = 0, ZOOM = 2, COLORS = 1;<br /><br />Document doc;<br />Size2d size;<br /><br />Point2d pickers[4];<br />Point2d *selected;<br /><br />Uint32 theme[] = {<br />	0x000000,<br />	0xFFFFFF,<br />	0x72DEC2,<br />	0x666666,<br />	0x222222};<br /><br />Uint8 icons[][8] = {<br />	{0x38, 0x7c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x00}, /* color:full */<br />	{0x00, 0x38, 0x7c, 0x7c, 0x7c, 0x38, 0x00, 0x00}, /* color:blank */<br />	{0xfe, 0x82, 0x82, 0xfe, 0x82, 0x82, 0xfe, 0x00}, /* brush:1bit */<br />	{0xfe, 0x92, 0x92, 0xfe, 0x92, 0x92, 0xfe, 0x00}, /* brush:2bit */<br />	{0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00}, /* picker:1 */<br />	{0x7c, 0xc6, 0x0e, 0x3c, 0x78, 0xe0, 0xfe, 0x00}, /* picker:2 */<br />	{0x7e, 0x0c, 0x18, 0x3c, 0x06, 0xc6, 0x7c, 0x00}, /* picker:3 */<br />	{0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x00}, /* picker:4 */<br />	{0xee, 0x92, 0x82, 0x54, 0x82, 0x92, 0xee, 0x00}, /* view:bigpixels */<br />	{0x00, 0x00, 0x00, 0x82, 0x44, 0x38, 0x00, 0x00}, /* eye open */<br />	{0x00, 0x38, 0x44, 0x92, 0x28, 0x10, 0x00, 0x00}, /* eye closed */<br />	{0x10, 0x54, 0x28, 0xc6, 0x28, 0x54, 0x10, 0x00}  /* unsaved */<br />};<br /><br />SDL_Window *gWindow;<br />SDL_Renderer *gRenderer;<br />SDL_Texture *gTexture;<br />Uint32 *pixels;<br />SDL_Surface *image;<br /><br />#pragma mark - HELPERS<br /><br />int<br />clamp(int val, int min, int max)<br />{<br />	return (val &gt;= min) ? (val &lt;= max) ? val : max : min;<br />}<br /><br />int<br />distance(int ax, int ay, int bx, int by)<br />{<br />	return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);<br />}<br /><br />int<br />coloroffset(Uint32 a, Uint32 b)<br />{<br />	Uint8 r0 = (a &gt;&gt; 16) &amp; 0xFF, g0 = (a &gt;&gt; 8) &amp; 0xFF, b0 = a &amp; 0xFF;<br />	Uint8 r1 = (b &gt;&gt; 16) &amp; 0xFF, g1 = (b &gt;&gt; 8) &amp; 0xFF, b1 = b &amp; 0xFF;<br />	return abs(r0 - r1) + abs(g0 - g1) + abs(b0 - b1);<br />}<br /><br />char *<br />scpy(char *src, char *dst, int len)<br />{<br />	int i = 0;<br />	while((dst[i] = src[i]) &amp;&amp; i &lt; len - 2)<br />		i++;<br />	dst[i + 1] = '\0';<br />	return dst;<br />}<br /><br />#pragma mark - CHR HANDLERS<br /><br />int<br />rowchr(int x, int y)<br />{<br />	return (y % 8) + ((x / 8 + y / 8 * HOR) * 16);<br />}<br /><br />int<br />getchr(int x, int y)<br />{<br />	int ch1, ch2, r = rowchr(x, y);<br />	if(r &lt; 0 || r &gt; SZ - 8)<br />		return 0;<br />	ch1 = (doc.data[r] &gt;&gt; (7 - x % 8)) &amp; 1;<br />	ch2 = (doc.data[r + 8] &gt;&gt; (7 - x % 8)) &amp; 1;<br />	if(ch1 &amp;&amp; !ch2)<br />		return 1;<br />	if(!ch1 &amp;&amp; ch2)<br />		return 2;<br />	if(ch1 &amp;&amp; ch2)<br />		return 3;<br />	return 0;<br />}<br /><br />void<br />putchr(int x, int y, int color)<br />{<br />	int row = rowchr(x, y), col = x % 8;<br />	if(x &lt; 0 || x &gt;= HOR * 8 || y &lt; 0 || y &gt;= VER * 8)<br />		return;<br />	if(color == 0 || color == 2)<br />		doc.data[row] &amp;= ~(1UL &lt;&lt; (7 - col));<br />	else<br />		doc.data[row] |= 1UL &lt;&lt; (7 - col);<br />	if(color == 0 || color == 1)<br />		doc.data[row + 8] &amp;= ~(1UL &lt;&lt; (7 - col));<br />	else<br />		doc.data[row + 8] |= 1UL &lt;&lt; (7 - col);<br />	doc.unsaved = 1;<br />}<br /><br />#pragma mark - DRAW<br /><br />void<br />clear(Uint32 *dst)<br />{<br />	int v, h;<br />	for(v = 0; v &lt; HEIGHT; v++)<br />		for(h = 0; h &lt; WIDTH; h++)<br />			dst[v * WIDTH + h] = theme[0];<br />}<br /><br />void<br />putpixel(Uint32 *dst, int x, int y, int color)<br />{<br />	if(x &gt;= 0 &amp;&amp; x &lt; WIDTH - 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; HEIGHT - 8)<br />		dst[(y + PAD * 8) * WIDTH + (x + PAD * 8)] = theme[color];<br />}<br /><br />void<br />drawchr(Uint32 *dst, int x, int y, Uint8 *sprite)<br />{<br />	int v, h;<br />	for(v = 0; v &lt; 8; v++)<br />		for(h = 0; h &lt; 8; h++) {<br />			int ch1 = ((sprite[v] &gt;&gt; h) &amp; 0x1);<br />			int ch2 = (((sprite[v + 8] &gt;&gt; h) &amp; 0x1) &lt;&lt; 1);<br />			putpixel(dst, x + 7 - h, y + v, ch1 + ch2);<br />		}<br />}<br /><br />void<br />drawicn(Uint32 *dst, int x, int y, Uint8 *sprite, int fg, int bg)<br />{<br />	int v, h;<br />	for(v = 0; v &lt; 8; v++)<br />		for(h = 0; h &lt; 8; h++) {<br />			int ch1 = (sprite[v] &gt;&gt; (7 - h)) &amp; 0x1;<br />			putpixel(dst, x + h, y + v, ch1 ? fg : bg);<br />		}<br />}<br /><br />void<br />drawicna(Uint32 *dst, int x, int y, Uint8 *icon, int fg)<br />{<br />	int v, h;<br />	for(v = 0; v &lt; 8; v++)<br />		for(h = 0; h &lt; 8; h++)<br />			if((icon[v] &gt;&gt; (7 - h)) &amp; 0x1)<br />				putpixel(dst, x + h, y + v, fg);<br />}<br /><br />void<br />drawui(Uint32 *dst)<br />{<br />	int bottom = VER * 8 + 8;<br />	drawicn(dst, 0, bottom, icons[COLORS ? 3 : 2], 1, 0);<br />	drawicn(dst, 2 * 8, bottom, icons[GUIDES ? 10 : 9], GUIDES ? 1 : 2, 0);<br />	drawicn(dst, (HOR - 1) * 8, bottom, icons[11], doc.unsaved ? 2 : 3, 0); /* save state */<br />}<br /><br />Uint32<br />getpixel(SDL_Surface *surface, int x, int y)<br />{<br />	int bpp = surface-&gt;format-&gt;BytesPerPixel;<br />	Uint8 *p = (Uint8 *)surface-&gt;pixels + y * surface-&gt;pitch + x * bpp;<br />	switch(bpp) {<br />	case 1: return *p;<br />	case 2: return *(Uint16 *)p;<br />	case 3:<br />		if(SDL_BYTEORDER == SDL_BIG_ENDIAN)<br />			return p[0] &lt;&lt; 16 | p[1] &lt;&lt; 8 | p[2];<br />		else<br />			return p[0] | p[1] &lt;&lt; 8 | p[2] &lt;&lt; 16;<br />	case 4: return *(Uint32 *)p;<br />	}<br />	return 0;<br />}<br /><br />Uint32<br />getcolor(int x, int y)<br />{<br />	SDL_Color rgb;<br />	SDL_GetRGB(getpixel(image, x, y), image-&gt;format, &amp;rgb.r, &amp;rgb.g, &amp;rgb.b);<br />	return ((rgb.r &amp; 0xFF) &lt;&lt; 16) + ((rgb.g &amp; 0xFF) &lt;&lt; 8) + (rgb.b &amp; 0xFF);<br />}<br /><br />int<br />getpattern(int palette, int x, int y)<br />{<br />	if(palette == 3)<br />		return 3;<br />	if(palette == 2)<br />		return ((x + y) % 2) == 0 &amp;&amp; ((y - x) % 2) == 0 ? 3 : 0;<br />	if(palette == 1)<br />		return ((x + y) % 4) == 0 &amp;&amp; ((y - x) % 4) == 0 ? 3 : 0;<br />	return 0;<br />}<br /><br />int<br />getpalette(Uint32 clr)<br />{<br />	Uint32 res = 0, dis = 999999;<br />	int i;<br />	for(i = 0; i &lt; 4; ++i) {<br />		Uint32 d = coloroffset(clr, theme[i]);<br />		if(d &lt; dis) {<br />			dis = d;<br />			res = i;<br />		}<br />	}<br />	return res;<br />}<br /><br />void<br />drawpicker(Uint32 *dst, int id)<br />{<br />	drawicna(dst, pickers[id].x - 3, pickers[id].y - 3, icons[0], 4);<br />	drawicna(dst, pickers[id].x + 6, pickers[id].y - 3, icons[4 + id], 4);<br />	drawicna(dst, pickers[id].x - 3, pickers[id].y - 3, icons[1], id);<br />}<br /><br />void<br />redraw(Uint32 *dst)<br />{<br />	int x, y;<br />	/* Update palette */<br />	theme[0] = getcolor(pickers[0].x, pickers[0].y);<br />	theme[1] = getcolor(pickers[1].x, pickers[1].y);<br />	theme[2] = getcolor(pickers[2].x, pickers[2].y);<br />	theme[3] = getcolor(pickers[3].x, pickers[3].y);<br />	/* Draw */<br />	clear(dst);<br />	drawui(dst);<br />	/* Draw images */<br />	SDL_LockSurface(image);<br />	for(y = 0; y &lt; image-&gt;h; ++y) {<br />		for(x = 0; x &lt; image-&gt;w; ++x) {<br />			int palette = getpalette(getcolor(x, y));<br />			putchr(x, y, COLORS ? palette : getpattern(palette, x, y));<br />		}<br />	}<br />	SDL_UnlockSurface(image);<br />	for(y = 0; y &lt; VER; ++y)<br />		for(x = 0; x &lt; HOR; ++x)<br />			drawchr(dst, x * 8, y * 8, &amp;doc.data[(x + y * HOR) * 16]);<br />	if(GUIDES) { /* draw pickers */<br />		drawpicker(dst, 0);<br />		drawpicker(dst, 1);<br />		drawpicker(dst, 2);<br />		drawpicker(dst, 3);<br />	}<br />	SDL_UpdateTexture(gTexture, NULL, dst, WIDTH * sizeof(Uint32));<br />	SDL_RenderClear(gRenderer);<br />	SDL_RenderCopy(gRenderer, gTexture, NULL, NULL);<br />	SDL_RenderPresent(gRenderer);<br />}<br /><br />#pragma mark - OPTIONS<br /><br />int<br />error(char *msg, const char *err)<br />{<br />	printf("Error %s: %s\n", msg, err);<br />	return 0;<br />}<br /><br />void<br />savemode(int *i, int v)<br />{<br />	*i = v;<br />	redraw(pixels);<br />}<br /><br />void<br />makedoc(Document *d, char *name)<br />{<br />	int i;<br />	for(i = 0; i &lt; SZ; ++i)<br />		d-&gt;data[i] = 0x00;<br />	d-&gt;unsaved = 0;<br />	scpy(name, d-&gt;name, 256);<br />	printf("Made: %s\n", d-&gt;name);<br />	redraw(pixels);<br />}<br /><br />int<br />savedoc(Document *d, char *name)<br />{<br />	FILE *f = fopen(name, "w");<br />	if(!fwrite(d-&gt;data, sizeof(d-&gt;data), 1, f))<br />		return error("Save", "Failure");<br />	d-&gt;unsaved = 0;<br />	scpy(name, d-&gt;name, 256);<br />	fclose(f);<br />	printf("0x%x 0x%x 0x%x 0x%x\n", theme[0], theme[1], theme[2], theme[3]);<br />	printf("Saved: %s\n", d-&gt;name);<br />	redraw(pixels);<br />	return 1;<br />}<br /><br />int<br />saveicn(Document *d, char *name)<br />{<br />	int i;<br />	FILE *f = fopen(name, "w");<br />	Uint8 data[SZ / 2];<br />	for(i = 0; i &lt; SZ / 2; ++i)<br />		data[i] = d-&gt;data[(i / 4) * 8 + (i % 8)];<br />	if(!fwrite(data, sizeof(data), 1, f))<br />		return error("Save", "Failure");<br />	d-&gt;unsaved = 0;<br />	scpy(name, d-&gt;name, 256);<br />	fclose(f);<br />	printf("Saved(icn): %s\n", d-&gt;name);<br />	redraw(pixels);<br />	return 1;<br />}<br /><br />void<br />setpicker(Point2d *picker, int x, int y)<br />{<br />	picker-&gt;x = clamp(x, 0, HOR * 8);<br />	picker-&gt;y = clamp(y, 0, VER * 8);<br />	redraw(pixels);<br />}<br /><br />Point2d *<br />selectpicker(int x, int y)<br />{<br />	int i;<br />	for(i = 0; i &lt; 4; ++i)<br />		if(distance(x, y, pickers[i].x, pickers[i].y) &lt; 20)<br />			return &amp;pickers[i];<br />	return NULL;<br />}<br /><br />int<br />savebmp(void)<br />{<br />	SDL_Surface *surface = SDL_GetWindowSurface(gWindow);<br />	SDL_RenderReadPixels(gRenderer,<br />		NULL,<br />		SDL_PIXELFORMAT_ARGB8888,<br />		surface-&gt;pixels,<br />		surface-&gt;pitch);<br />	if(SDL_SaveBMP(surface, "dito-render.bmp"))<br />		return error("Render", "Failed");<br />	puts("Render: dito-render.bmp");<br />	SDL_FreeSurface(surface);<br />	return 1;<br />}<br /><br />void<br />selectoption(int option)<br />{<br />	switch(option) {<br />	case 0: savemode(&amp;COLORS, !COLORS); break;<br />	case 2: savemode(&amp;GUIDES, !GUIDES); break;<br />	case HOR - 1: COLORS ? savedoc(&amp;doc, doc.name) : saveicn(&amp;doc, doc.name); break;<br />	}<br />}<br /><br />void<br />quit(void)<br />{<br />	free(pixels);<br />	SDL_DestroyTexture(gTexture);<br />	gTexture = NULL;<br />	SDL_DestroyRenderer(gRenderer);<br />	gRenderer = NULL;<br />	SDL_DestroyWindow(gWindow);<br />	gWindow = NULL;<br />	SDL_Quit();<br />	exit(0);<br />}<br /><br />#pragma mark - TRIGGERS<br /><br />void<br />domouse(SDL_Event *event)<br />{<br />	switch(event-&gt;type) {<br />	case SDL_MOUSEBUTTONUP:<br />		DOWN = 0;<br />		selected = NULL;<br />		break;<br />	case SDL_MOUSEBUTTONDOWN:<br />		if(event-&gt;motion.y / ZOOM / 8 - PAD == VER + 1) {<br />			selectoption(event-&gt;motion.x / ZOOM / 8 - PAD);<br />			return;<br />		}<br />		selected = selectpicker(event-&gt;motion.x / ZOOM - PAD * 8, event-&gt;motion.y / ZOOM - PAD * 8);<br />		DOWN = 1;<br />		break;<br />	case SDL_MOUSEMOTION:<br />		if(selected)<br />			setpicker(selected, event-&gt;motion.x / ZOOM - PAD * 8, event-&gt;motion.y / ZOOM - PAD * 8);<br />		break;<br />	}<br />}<br /><br />void<br />dokey(SDL_Event *event)<br />{<br />	int shift = SDL_GetModState() &amp; KMOD_LSHIFT || SDL_GetModState() &amp; KMOD_RSHIFT;<br />	int ctrl = SDL_GetModState() &amp; KMOD_LCTRL || SDL_GetModState() &amp; KMOD_RCTRL;<br />	if(ctrl) {<br />		switch(event-&gt;key.keysym.sym) {<br />		/* Generic */<br />		case SDLK_s: shift ? saveicn(&amp;doc, doc.name) : savedoc(&amp;doc, doc.name); break;<br />		case SDLK_h: savemode(&amp;GUIDES, !GUIDES); break;<br />		}<br />	} else {<br />		switch(event-&gt;key.keysym.sym) {<br />		case SDLK_SPACE: savemode(&amp;COLORS, !COLORS); break;<br />		case SDLK_1: selected = &amp;pickers[0]; break;<br />		case SDLK_2: selected = &amp;pickers[1]; break;<br />		case SDLK_3: selected = &amp;pickers[2]; break;<br />		case SDLK_4: selected = &amp;pickers[3]; break;<br />		}<br />	}<br />}<br /><br />int<br />init(void)<br />{<br />	if(SDL_Init(SDL_INIT_VIDEO) &lt; 0)<br />		return error("Init", SDL_GetError());<br />	gWindow = SDL_CreateWindow("Dito",<br />		SDL_WINDOWPOS_UNDEFINED,<br />		SDL_WINDOWPOS_UNDEFINED,<br />		WIDTH * ZOOM,<br />		HEIGHT * ZOOM,<br />		SDL_WINDOW_SHOWN);<br />	if(gWindow == NULL)<br />		return error("Window", SDL_GetError());<br />	gRenderer = SDL_CreateRenderer(gWindow, -1, 0);<br />	if(gRenderer == NULL)<br />		return error("Renderer", SDL_GetError());<br />	gTexture = SDL_CreateTexture(gRenderer,<br />		SDL_PIXELFORMAT_ARGB8888,<br />		SDL_TEXTUREACCESS_STATIC,<br />		WIDTH,<br />		HEIGHT);<br />	if(gTexture == NULL)<br />		return error("Texture", SDL_GetError());<br />	pixels = (Uint32 *)malloc(WIDTH * HEIGHT * sizeof(Uint32));<br />	if(pixels == NULL)<br />		return error("Pixels", "Failed to allocate memory");<br />	clear(pixels);<br />	return 1;<br />}<br /><br />int<br />main(int argc, char **argv)<br />{<br />	int ticknext = 0;<br />	if(argc &lt; 2)<br />		return error("Load", "Missing bmp image.");<br />	if(!init())<br />		return error("Init", "Failure");<br />	image = SDL_LoadBMP(argv[1]);<br />	if(!image)<br />		return error("Load", "Invalid bmp image.");<br />	setpicker(&amp;pickers[0], 66, 16);<br />	setpicker(&amp;pickers[1], 46, 49);<br />	setpicker(&amp;pickers[2], 140, 10);<br />	setpicker(&amp;pickers[3], 120, 40);<br />	makedoc(&amp;doc, "untitled.chr");<br />	while(1) {<br />		int tick = SDL_GetTicks();<br />		SDL_Event event;<br />		if(tick &lt; ticknext)<br />			SDL_Delay(ticknext - tick);<br />		ticknext = tick + (1000 / FPS);<br />		while(SDL_PollEvent(&amp;event) != 0) {<br />			switch(event.type) {<br />			case SDL_QUIT: quit(); break;<br />			case SDL_MOUSEBUTTONUP:<br />			case SDL_MOUSEBUTTONDOWN:<br />			case SDL_MOUSEMOTION: domouse(&amp;event); break;<br />			case SDL_KEYDOWN: dokey(&amp;event); break;<br />			case SDL_WINDOWEVENT:<br />				if(event.window.event == SDL_WINDOWEVENT_EXPOSED)<br />					redraw(pixels);<br />				break;<br />			}<br />		}<br />	}<br />	quit();<br />	return 0;<br />}<br /></pre>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/dito' target='_blank'>source</a></li>
	<li><a href='https://merveilles.town/web/statuses/105589734816667213' target='_blank'>thread</a></li>
</ul>

<ul><li><b>15B06</b> &mdash; Dito Desktop Release</li></ul></main><footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a><a href="http://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><a href="uxn.html"><img src="../media/icon/uxn.svg" alt="Uxn Powered"/></a><span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2021 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer></body></html>