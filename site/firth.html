<!DOCTYPE html><html><head><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/><title>XXIIVV &mdash; firth</title></head><body><header><a href="home.html"><img src="../media/icon/logo.svg" alt="XXIIVV"/></a></header><nav><ul><li><a href="../site/roms.html">roms</a></li><li><a href="../site/tools.html">tools</a></li><li><a href="../site/utilities.html">utilities</a></li><li><a href="../site/formats.html">formats</a></li><li><a href="../site/games.html">games</a></li><li><a href="../site/toys.html">toys</a></li><li><a href="../site/mobile.html">mobile</a></li><li><a href="../site/unreleased.html">unreleased</a></li></ul><ul><li>firth/</li><li><a href="../site/shim.html">shim</a></li><li><a href="../site/seconth.html">seconth</a></li><li><a href="../site/stopwatch.html">stopwatch</a></li></ul><ul></ul></nav><main><figure><img src="../media/diary/555.jpg" alt="graf3dscene	Andes Castel In Construction"/><figcaption>graf3dscene	Andes Castel In Construction</figcaption></figure><h2>Firth, or 1th, is a postfix calculator for fractions.</h2>

<p>Firth is a stack based <a href='reverse_polish.html'>rpn calculator</a>, created to be an improved version of <a href='unix.html'>Unix</a>'s <a href='https://en.wikipedia.org/wiki/Dc_(computer_program)' target='_blank'>dc</a>. It supports basic <a href='arithmetic.html'>arithmetic</a> and is the perfect companion utility to <a href='fractran.html'>Fractran</a>.</p>
<figure><img src='../media/refs/firth.jpg' width='400'/>&nbsp;<figcaption>â€”Firth session with 6 MHz 286, 2.5MB RAM, DOS 5.0</figcaption></figure>
<h3>Examples</h3>
<p>The following example, will print the mixed fraction <code>3&1/6</code>.</p>
<pre>clr 11 4 div 5 12 div add mix</pre>
<p>To print the decimal value of a fraction.</p>
<pre>clr 22 7 div 1 791 div sub dec</pre>
<p>To get the <code>floor()</code> of a fraction.</p>
<pre>clr 17 4 div dup 1 mod sub .</pre>
<h3>1th.c</h3>
<pre>#include &lt;stdio.h&gt;<br /><br />/* <br />Copyright (c) 2020 Devine Lu Linvega<br /><br />Permission to use, copy, modify, and distribute this software for any<br />purpose with or without fee is hereby granted, provided that the above<br />copyright notice and this permission notice appear in all copies.<br /><br />THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES<br />WITH REGARD TO THIS SOFTWARE.<br />*/<br /><br />#define SZ 256<br /><br />typedef struct Fraction {<br />	int num, den;<br />} Fraction;<br /><br />typedef struct Stack {<br />	Fraction data[SZ];<br />	Fraction *pointer;<br />} Stack;<br /><br />typedef enum {<br />	STANDARD,<br />	MIXED,<br />	DECIMAL,<br />	HEXADECIMAL,<br />	BINARY<br />} PrintMode;<br /><br />PrintMode MODE;<br /><br />#pragma mark - Helpers<br /><br />static int<br />scmp(char *a, char *b)<br />{<br />	int i = 0;<br />	while(a[i] == b[i])<br />		if(!a[i++])<br />			return 1;<br />	return 0;<br />}<br /><br />static int<br />gcd(int a, int b)<br />{<br />	if(b == 0)<br />		return a;<br />	return gcd(b, a % b);<br />}<br /><br />static void<br />pbin(int n, unsigned int l)<br />{<br />	while(l) {<br />		putchar(n &amp; l ? '1' : '0');<br />		l &gt;&gt;= 1;<br />	}<br />	putchar(' ');<br />}<br /><br />#pragma mark - Calculator<br /><br />static int<br />error(char *err, char *msg)<br />{<br />	printf("%s Error: %s\n", err, msg);<br />	return 0;<br />}<br /><br />static int<br />trypop(Stack *s, int len)<br />{<br />	int err = s-&gt;pointer - len &lt; s-&gt;data;<br />	if(err)<br />		error("Stack", "underflow");<br />	return !err;<br />}<br /><br />static int<br />trypush(Stack *s, int len)<br />{<br />	int err = s-&gt;pointer + len &gt;= s-&gt;data + SZ;<br />	if(err)<br />		error("Stack", "overflow");<br />	return !err;<br />}<br /><br />static Fraction<br />pop(Stack *s)<br />{<br />	return *(s-&gt;pointer--);<br />}<br /><br />static void<br />push(Stack *s, Fraction f)<br />{<br />	*(++s-&gt;pointer) = f;<br />}<br /><br />static Fraction *<br />get(Stack *s, int offset)<br />{<br />	return s-&gt;pointer - offset;<br />}<br /><br />static Fraction<br />Frac(int num, int den)<br />{<br />	Fraction f;<br />	int d = gcd(num, den);<br />	f.num = num / d;<br />	f.den = den / d;<br />	return f;<br />}<br /><br />static void<br />print(Stack *s)<br />{<br />	Fraction *f = s-&gt;data;<br />	while(f++ != s-&gt;pointer) {<br />		if(MODE == DECIMAL)<br />			printf("%f ", f-&gt;num / (double)f-&gt;den);<br />		else if(MODE == MIXED &amp;&amp; f-&gt;num &gt; f-&gt;den)<br />			printf("%d&amp;%d/%d ", f-&gt;num / f-&gt;den, f-&gt;num % f-&gt;den, f-&gt;den);<br />		else if(MODE == HEXADECIMAL)<br />			printf("%08hX ", f-&gt;num);<br />		else if(MODE == BINARY)<br />			pbin(f-&gt;num, 1 &lt;&lt; 7);<br />		else if(f-&gt;den != 1)<br />			printf("%d/%d ", f-&gt;num, f-&gt;den);<br />		else<br />			printf("%d ", f-&gt;num);<br />	}<br />	printf("\n");<br />}<br /><br />#pragma mark - Operations<br /><br />static int<br />interpret(Stack *s, char *word)<br />{<br />	int value;<br />	if(!word[0] || word[0] == ' ' || word[0] == '.')<br />		print(s);<br />	else if(scmp(word, "std"))<br />		MODE = STANDARD;<br />	else if(scmp(word, "mix"))<br />		MODE = MIXED;<br />	else if(scmp(word, "dec"))<br />		MODE = DECIMAL;<br />	else if(scmp(word, "hex"))<br />		MODE = HEXADECIMAL;<br />	else if(scmp(word, "bin"))<br />		MODE = BINARY;<br />	else if(sscanf(word, "%d", &amp;value) &amp;&amp; trypush(s, 1))<br />		push(s, Frac(value, 1));<br />	/* stack */<br />	else if(scmp(word, "pop") &amp;&amp; trypop(s, 1))<br />		pop(s);<br />	else if(scmp(word, "clr"))<br />		s-&gt;pointer = s-&gt;data;<br />	else if(scmp(word, "swp") &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(b.num, b.den));<br />		push(s, Frac(a.num, a.den));<br />	} else if(scmp(word, "dup") &amp;&amp; trypop(s, 1) &amp;&amp; trypush(s, 1)) {<br />		Fraction *f = get(s, 0);<br />		push(s, Frac(f-&gt;num, f-&gt;den));<br />	} else if(scmp(word, "ovr") &amp;&amp; trypop(s, 2) &amp;&amp; trypush(s, 1)) {<br />		Fraction *f = get(s, 1);<br />		push(s, Frac(f-&gt;num, f-&gt;den));<br />	} else if(scmp(word, "rot") &amp;&amp; trypop(s, 3)) {<br />		Fraction c = pop(s);<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(b.num, b.den));<br />		push(s, Frac(c.num, c.den));<br />		push(s, Frac(a.num, a.den));<br />		/* arithmetic */<br />	} else if((word[0] == '+' || scmp(word, "add")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) + (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '-' || scmp(word, "sub")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) - (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '*' || scmp(word, "mul")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(a.num * b.num, a.den * b.den));<br />	} else if((word[0] == '/' || scmp(word, "div")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(a.num * b.den, a.den * b.num));<br />	} else if((word[0] == '%' || scmp(word, "mod")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) % (a.den * b.num), a.den * b.den));<br />		/* bitwise */<br />	} else if((word[0] == '&amp;' || scmp(word, "and")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) &amp; (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '|' || scmp(word, "or")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) | (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '^' || scmp(word, "xor")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) ^ (a.den * b.num), a.den * b.den));<br />	} else if((scmp(word, "&lt;&lt;") || scmp(word, "rol")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) &lt;&lt; (a.den * b.num), a.den * b.den));<br />	} else if((scmp(word, "&gt;&gt;") || scmp(word, "ror")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) &gt;&gt; (a.den * b.num), a.den * b.den));<br />		/* special */<br />	} else if((scmp(word, "inv")) &amp;&amp; trypop(s, 1)) {<br />		Fraction f = pop(s);<br />		push(s, Frac(f.den, f.num));<br />	} else if(scmp(word, "vid") &amp;&amp; trypop(s, 1) &amp;&amp; trypush(s, 1)) {<br />		Fraction f = pop(s);<br />		push(s, Frac(f.num, 1));<br />		push(s, Frac(f.den, 1));<br />	} else if(word)<br />		return error("Command", word);<br />	return 1;<br />}<br /><br />static int<br />run(Stack *s)<br />{<br />	int len = 0;<br />	char c, word[64];<br />	while((c = fgetc(stdin)) != EOF) {<br />		if(c == ' ' || c == '\n') {<br />			word[len] = '\0';<br />			len = 0;<br />			interpret(s, word);<br />		} else<br />			word[len++] = c;<br />	}<br />	return 0;<br />}<br /><br />int<br />main(void)<br />{<br />	Stack s;<br />	s.pointer = s.data;<br />	while(run(&amp;s))<br />		;<br />	print(&amp;s);<br />	return 0;<br />}<br /></pre>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/firth' target='_blank'>source</a></li>
</ul>

<ul><li><b>14V06</b> &mdash; Firth Release</li></ul></main><footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a><a href="http://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><a href="uxn.html"><img src="../media/icon/uxn.svg" alt="Uxn Powered"/></a><span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2021 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer></body></html>