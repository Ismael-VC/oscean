<!DOCTYPE html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../links/main.css" type="text/css" rel="stylesheet"><link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<title>XXIIVV &mdash; matrioshka</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>

<nav><ul><li><a href="programming_languages.html" class="parent">programming languages</a></li><li><a href="operating_systems.html">operating systems</a></li><li><a href="graphical_input.html">graphical input</a></li><li><a href="file_formats.html">file formats</a></li><li><a href="data_encoding.html">data encoding</a></li><li><a href="type_systems.html">type systems</a></li><li><a href="versioning.html">versioning</a></li></ul><ul><li><a href="assembly.html">assembly</a></li><li><a href="concatenative.html">concatenative</a></li><li><a href="applicative.html">applicative</a></li><li><a href="flow-based.html">flow-based</a></li><li><a href="imperative.html">imperative</a></li><li><a href="matrioshka.html" class="self">matrioshka</a></li><li><a href="esoteric.html">esoteric</a></li></ul><ul><li><a href="thue.html">thue</a></li><li><a href="modal.html">modal</a></li></ul></nav>
<main><h2>Matrioshka languages have multiple, distinct phases with different syntactic and semantic rules. </h2>

<p>There are often two phases; the first gives a set of rules, and the second provides objects on which those rules are to be applied.</p>
<h2>Thue is a matrioshka esoteric computer based on string rewriting rules.</h2>

<p>A Thue program consists of two parts: a list of <a
href='logic.html'>substitution rules</a>, which is terminated with a line
having both sides of the operator empty, followed by a string representing the
initial program state.</p>

<pre>
#::=<span style='color:#777'>Unused rules are comments</span>
a::=~Hello Thue!
::=
[a] <span style='color:#777; float:right'>[]</span>
</pre>

<p>Execution consists of picking, from the list of rules, an arbitrary rule whose original string exists as a substring somewhere in the program state, and replacing that substring by the rule's replacement string. This process repeats until there are no rules that can be applied, at which point, the program ends. </p>

<pre>
#::=<span style='color:#777'>Increment binary number</span>
1_::=1++
0_::=1
01++::=10
11++::=1++0
_0::=_
_1++::=10
::=
_10010011_ <span style='color:#777; float:right'>_10010100</span>
</pre>

<p>Thue represents one of the simplest possible constraint-based programming
language. It is to the constraint-based paradigm what languages like OISC are
to the imperative paradigm. </p>

<img src='../media/refs/bthennota.png' width='100'/>

<h3>Input</h3>

<p>Added to this simple system are two strings which are used to permit Thue to communicate with the outside world. The first of these is the input symbol (":::").  The input symbol is actually the lhs of an implicit rule of which the user (or system's "input stream") is a component.  The input symbol, therefore, is replaced by a line of text received from the "input stream."</p>

<h3>Output</h3>

<p>As a counterpart of input, the output symbol ("~") is supplied.  Like the input symbol, the output symbol triggers an implicit rule which, in this case, encompasses the "output stream."  The specific effect is that all text to the right of the output symbol in the rhs of a production is sent to the output stream.</p>

<p>Note that either (or both) of these implicit rules may be overridden by providing explicit rules that perform some other task.</p>

<pre>
#::=<span style='color:#777'>Sierpinski's triangle, backticks are linebreaks</span>
X::=~_
Y::=~*
Z::=~`
_.::=._X
_*::=*_Y
._|::=.Z-|
*_|::=Z
..-::=.-.
**-::=*-.
*.-::=*-*
.*-::=.-*
@.-::=@_.
@*-::=@_*
::=
@_*...............................|
</pre>

<q>It is pitch black. You are likely to be eaten by a Thue.</q>

<ul>
	<li><a href='https://esolangs.org/wiki/Thue' target='_blank'>On Esolangs</a></li>
	<li><a href='https://git.sr.ht/~rabbits/thuesday' target='_blank'>Interpreter</a>, written in Uxntal. <a href='https://www.youtube.com/watch?v=A8f7IsQ8ENQ' target='_blank'>Video</a></li>
	<li><a href='https://git.catseye.tc/Wanda/' target='_blank'>Wanda</a>, concatenative language meets string rewriting.</li>
</ul>
<h2>Modal is a matrioshka language based on pattern-matching to rewrite trees.</h2>

<p>All Modal code is represented as a series of rules, formatted as tokens delimited with parenthesis, applied to a given tree which gets continually modified until no rules match any given part of the tree. </p>

<p>Rules are made of:</p>

<ul>
	<li><a href='#tokens'>Tokens</a>: foo, bar, baz</li>
	<li><a href='#variables'>Variables</a>: ?foo, ?bar, ?baz</li>
	<li><a href='#sequences'>Sequences</a>: (foo bar baz), (foo ?bar baz), foo (bar (baz))</li>         
</ul>

<h3 id='tokens'>Tokens</h3>

<p>To define a rule, we use the <b>define</b> keyword, followed by the two arguments to replace:</p>

<pre><b>define</b> hello bye

::> hello world
bye world</pre>

<h3 id='variables'>Variables</h3>

<p>A replacement can only use variables that have been used in
a pattern.</p>

<pre><b>define</b> (copy ?a) (?a ?a)

::> (copy cat)
(cat cat)</pre>

<p>When a variable is used in a pattern, and when we try
to match a given tree with a pattern, any variables are bound to their
corresponding tokens/sequences in said tree.</p>

<pre><b>define</b> (swap ?x ?y) (?y ?x)

::> (swap fox rat)
(rat fox)</pre>

<h3 id='sequences'>Sequences</h3>

<p>Modal operates beyond programming paradigms, it can be shaped to mimic an other programming language syntax or style. Any choice made in regard to syntax beyond this point is completely arbitrary. To demonstrate, we'll define a comment syntax and a new define syntax:</p>

<pre>
<b>define</b> (;; ?x) ()
;; (this is a comment)
<b>define</b> (?x -> ?y) (define ?x ?y)
(swap ?x ?y) -> (?y ?x)

::> swap fox rat
rat fox
</pre>

<p>To generate a list of numbers counting down from 10 to zero, in the prefix notation, we can define these three rules, notice how we use curlies for the right-side, delimiters are interchangeable:</p>

<pre>
<b>define</b> (0 range) {0}
<b>define</b> (?n range) {?n ?n - 1 range}
<b>define</b> (range ?n) {?n range}

::> (10 range)
(10 9 8 7 6 5 4 3 2 1 0)
</pre>

<h3>Logic</h3>

<p>Let us build a logic system, starting by comparing two variables:</p>

<pre>
<b>define</b> (eq ?x ?x) {#t}
<b>define</b> (eq ?x ?y) {#f}

::> eq fox owl
#f</pre>

<p>Building on the comparison rule above, we can write conditionals: </p>
<pre>
<b>define</b> (if (#t) ?branch) {?branch}
<b>define</b> (if (#f) ?branch) {}

::> if (eq bat bat) reached!
reached!</pre>

<p>We can implement the boolean truth tables by defining each cases:</p>

<pre>
<b>define</b> (and (#t) (#t)) {#t}
<b>define</b> (and (#t) (#f)) {#f}
<b>define</b> (and (#f) (#t)) {#f}
<b>define</b> (and (#f) (#f)) {#f}
<b>define</b> (or (#t) (#t)) {#t}
<b>define</b> (or (#t) (#f)) {#t}
<b>define</b> (or (#f) (#t)) {#t}
<b>define</b> (or (#f) (#f)) {#f}
<b>define</b> (not (#t)) {#f}
<b>define</b> (not (#f)) {#t}

::> if (or (eq cat bat) (eq fox fox))
#t</pre>

<p>Going further, we can create a rule that expects a ternary statement: </p>
<pre>
<b>define</b> (ifelse (#t) ?t ?f) {?t}
<b>define</b> (ifelse (#f) ?t ?f) {?f}

::> ifelse (eq cat fox) is-catfox not-catfox
not-catfox</pre>

<h3>Modal as language definition</h3>

<p>We can use rules to define entire languages, for example, this specifies a small <a href='concatenative.html'>concatenative</a> language with a postfix syntax:</p>

<pre>
<b>define</b> (: ?x ?y ;) {define ?x ?y}
: (?x dup) {?x ?x} ;
: (?x ?y swap) {?y ?x} ;
: (?x drop) {} ;
: (?x ?y p*) {?x * ?y} ;
: square {dup p*} ;

::> 10 square
100
</pre>

<!--

<h3>Modal Architecture</h3>
<p>There are only a few components to a Modal machine, and every single one of them is a queue of symbols:</p>

<ul>
    <li>The pattern queue, holding the string-under-rewrite. This is your "main memory".</li>
    <li>A number of "register" queues. These are your variables.</li>
    <li>A number of "rules" queues, holding strings of the form ?left ?right.</li>
</ul>

<p>Every "tick" (the underlying circuitry was clockless, so "tick" means global component handshakes), you'd step through the "rules" queues, one by one, and roll both the rule queue and the pattern queue.</p>

<p>Before matching, we enqueue a special symbol (SRT, or "start") to keep track of where we were so we can seek to it on success or failure, resetting the queue state for both the rule and the pattern.</p>

<p>If the symbols at the read-head of the pattern queue and the currently selected rule queue are equal, we roll both queues. If they aren't equal, we seek to that special SRT symbol and move on to the next rule.</p>

<p>If we reach the SRT symbol in the rule queue, we can say the rule has matched. We then enqueue an END symbol to the pattern queue, seek to the SRT symbol in the pattern queue, and then remove everything between SRT and END. Then we remove SRT and END, and enqueue the right-hand side of the rule.</p>


::> (hello) -> (good bye) hello
Reducing...
<>:    ( hello ) -> ( good bye ) hello  
<>:    hello  define ( hello ) ( good bye )  ::: ?x -> ?y 
<>:     define ( hello ) ( good bye ) hello 
<>:    define ( hello ) ( good bye ) hello  
<>:    hello   ::: define ?left ?right 
<>:     good bye  ::: hello 
<>:    good bye  
<>:    bye  good 
<>:     good bye 

That's why you see bye good, with a weird space between them. That's the invisible SRT token.
And that's the interpreter rolling through the pattern queue.
If you encounter a "register" symbol when evaluating a rule, you extract that delimited string symbol-by-symbol and put it in its corresponding register.
So (foo ?x ?y) -> (bar ?y ?x) looks like (foo R0 R1) (bar R1 R0) internally.
Each rule firing clears the registers.
There are some flaws with this machinery, namely that the register queues must be roughly the same size as the pattern queue if they're going to hold large strings.

One thing I'm removing from the implementation apart from arbitrary symbols is the concept of equality on the LHS of a rule. It's pre-defined/assumed that if you do foo ?x ?x, you want to assert equality instead of rebinding x to a new value.

Means you can do...

(?x == ?x) -> (true)
(?x == ?y) -> (false)

-->
<ul>
	<li><a href='https://git.sr.ht/~rabbits/modal' target='_blank'>sources</a>, python</li>
	<li>Original creation of <a href='https://wryl.tech/' target='_blank'>wryl</a>.</li>
</ul><ul></ul></main>
<footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a><a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><a href="ethics.html"><img src="../media/icon/dreipfeile.svg" alt="NoNazis!"/></a><a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a><span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2023 &mdash; <a href="about.html#license">BY-NC-SA 4.0</a></span></footer>
</body></html>