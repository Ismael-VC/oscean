<!DOCTYPE html><html lang='en'><head><meta charset='utf-8'><meta name='description' content='The Utilities are a collection of little tools created solve specific problems.'/><meta name='thumbnail' content='https://wiki.xxiivv.com/media/services/thumbnail.jpg' /><meta name='viewport' content='width=device-width,initial-scale=1'><link rel='alternate' type='application/rss+xml' title='RSS Feed' href='../links/rss.xml' /><link rel='stylesheet' type='text/css' href='../links/main.css'><link rel='shortcut icon' type='image/png' href='../media/services/icon.png'><title>XXIIVV &mdash; utilities</title><meta property='og:title' content='XXIIVV &mdash; utilities'><meta property='og:description' content='The Utilities are a collection of little tools created solve specific problems.'><meta property='og:url' content='https://wiki.xxiivv.com/site/utilities.html'><meta property='og:type' content='website' /><meta property='og:image' content='https://wiki.xxiivv.com/media/services/rss.jpg'></head><body><header><a href='home.html'><img src='../media/icon/logo.svg' alt='XXIIVV' height='29'></a></header><nav><ul><li><a href='physical.html'>physical</a></li><li><a href='photography.html'>photography</a></li><li><a href='illustration.html'>illustration</a></li><li><a href='software.html'>software/</a></li></ul><ul><li><a href='roms.html'>roms</a></li><li><a href='tools.html'>tools</a></li><li><a href='utilities.html'>utilities/</a></li><li><a href='formats.html'>formats</a></li><li><a href='games.html'>games</a></li><li><a href='toys.html'>toys</a></li><li><a href='mobile.html'>mobile</a></li><li><a href='unreleased.html'>unreleased</a></li></ul><ul><li><a href='firth.html'>firth</a></li><li><a href='shim.html'>shim</a></li><li><a href='seconth.html'>seconth</a></li><li><a href='stopwatch.html'>stopwatch</a></li></ul></nav><main><h2>The Utilities are a collection of little tools created solve specific problems.</h2><p>A collection of small applications that don't quite have a place in the wiki just yet.</p><h2><a href='firth.html'>firth</a></h2><h4>Firth, or 1th, is a postfix calculator for fractions.</h4><p>Firth is a stack based <a href='reverse_polish.html'>rpn calculator</a>, created to be an improved version of <a href='unix.html'>Unix</a>'s <a href='https://en.wikipedia.org/wiki/Dc_(computer_program)' target='_blank'>dc</a>. It supports basic <a href='arithmetic.html'>arithmetic</a> and is the perfect companion utility to <a href='fractran.html'>Fractran</a>.</p><figure><img src='../media/refs/firth.jpg' width='400'/>&nbsp;<figcaption>â€”Firth session with 6 MHz 286, 2.5MB RAM, DOS 5.0</figcaption></figure><h3>Examples</h3><p>The following example, will print the mixed fraction <code>3&1/6</code>.</p><pre>clr 11 4 div 5 12 div add mix</pre><p>To print the decimal value of a fraction.</p><pre>clr 22 7 div 1 791 div sub dec</pre><p>To get the <code>floor()</code> of a fraction.</p><pre>clr 17 4 div dup 1 mod sub .</pre><h3>1th.c</h3><figure><pre>#include &lt;stdio.h&gt;<br /><br />/* <br />Copyright (c) 2020 Devine Lu Linvega<br /><br />Permission to use, copy, modify, and distribute this software for any<br />purpose with or without fee is hereby granted, provided that the above<br />copyright notice and this permission notice appear in all copies.<br /><br />THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES<br />WITH REGARD TO THIS SOFTWARE.<br />*/<br /><br />#define SZ 256<br /><br />typedef struct Fraction {<br />	int num, den;<br />} Fraction;<br /><br />typedef struct Stack {<br />	Fraction data[SZ];<br />	Fraction *pointer;<br />} Stack;<br /><br />typedef enum {<br />	STANDARD,<br />	MIXED,<br />	DECIMAL,<br />	HEXADECIMAL,<br />	BINARY<br />} PrintMode;<br /><br />PrintMode MODE;<br /><br />#pragma mark - Helpers<br /><br />static int<br />scmp(char *a, char *b)<br />{<br />	int i = 0;<br />	while(a[i] == b[i])<br />		if(!a[i++])<br />			return 1;<br />	return 0;<br />}<br /><br />static int<br />gcd(int a, int b)<br />{<br />	if(b == 0)<br />		return a;<br />	return gcd(b, a % b);<br />}<br /><br />static void<br />pbin(int n, unsigned int l)<br />{<br />	while(l) {<br />		putchar(n &amp; l ? '1' : '0');<br />		l &gt;&gt;= 1;<br />	}<br />	putchar(' ');<br />}<br /><br />#pragma mark - Calculator<br /><br />static int<br />error(char *err, char *msg)<br />{<br />	printf("%s Error: %s\n", err, msg);<br />	return 0;<br />}<br /><br />static int<br />trypop(Stack *s, int len)<br />{<br />	int err = s-&gt;pointer - len &lt; s-&gt;data;<br />	if(err)<br />		error("Stack", "underflow");<br />	return !err;<br />}<br /><br />static int<br />trypush(Stack *s, int len)<br />{<br />	int err = s-&gt;pointer + len &gt;= s-&gt;data + SZ;<br />	if(err)<br />		error("Stack", "overflow");<br />	return !err;<br />}<br /><br />static Fraction<br />pop(Stack *s)<br />{<br />	return *(s-&gt;pointer--);<br />}<br /><br />static void<br />push(Stack *s, Fraction f)<br />{<br />	*(++s-&gt;pointer) = f;<br />}<br /><br />static Fraction *<br />get(Stack *s, int offset)<br />{<br />	return s-&gt;pointer - offset;<br />}<br /><br />static Fraction<br />Frac(int num, int den)<br />{<br />	Fraction f;<br />	int d = gcd(num, den);<br />	f.num = num / d;<br />	f.den = den / d;<br />	return f;<br />}<br /><br />static void<br />print(Stack *s)<br />{<br />	Fraction *f = s-&gt;data;<br />	while(f++ != s-&gt;pointer) {<br />		if(MODE == DECIMAL)<br />			printf("%f ", f-&gt;num / (double)f-&gt;den);<br />		else if(MODE == MIXED &amp;&amp; f-&gt;num &gt; f-&gt;den)<br />			printf("%d&amp;%d/%d ", f-&gt;num / f-&gt;den, f-&gt;num % f-&gt;den, f-&gt;den);<br />		else if(MODE == HEXADECIMAL)<br />			printf("%08hX ", f-&gt;num);<br />		else if(MODE == BINARY)<br />			pbin(f-&gt;num, 1 &lt;&lt; 7);<br />		else if(f-&gt;den != 1)<br />			printf("%d/%d ", f-&gt;num, f-&gt;den);<br />		else<br />			printf("%d ", f-&gt;num);<br />	}<br />	printf("\n");<br />}<br /><br />#pragma mark - Operations<br /><br />static int<br />interpret(Stack *s, char *word)<br />{<br />	int value;<br />	if(!word[0] || word[0] == ' ' || word[0] == '.')<br />		print(s);<br />	else if(scmp(word, "std"))<br />		MODE = STANDARD;<br />	else if(scmp(word, "mix"))<br />		MODE = MIXED;<br />	else if(scmp(word, "dec"))<br />		MODE = DECIMAL;<br />	else if(scmp(word, "hex"))<br />		MODE = HEXADECIMAL;<br />	else if(scmp(word, "bin"))<br />		MODE = BINARY;<br />	else if(sscanf(word, "%d", &amp;value) &amp;&amp; trypush(s, 1))<br />		push(s, Frac(value, 1));<br />	/* stack */<br />	else if(scmp(word, "pop") &amp;&amp; trypop(s, 1))<br />		pop(s);<br />	else if(scmp(word, "clr"))<br />		s-&gt;pointer = s-&gt;data;<br />	else if(scmp(word, "swp") &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(b.num, b.den));<br />		push(s, Frac(a.num, a.den));<br />	} else if(scmp(word, "dup") &amp;&amp; trypop(s, 1) &amp;&amp; trypush(s, 1)) {<br />		Fraction *f = get(s, 0);<br />		push(s, Frac(f-&gt;num, f-&gt;den));<br />	} else if(scmp(word, "ovr") &amp;&amp; trypop(s, 2) &amp;&amp; trypush(s, 1)) {<br />		Fraction *f = get(s, 1);<br />		push(s, Frac(f-&gt;num, f-&gt;den));<br />	} else if(scmp(word, "rot") &amp;&amp; trypop(s, 3)) {<br />		Fraction c = pop(s);<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(b.num, b.den));<br />		push(s, Frac(c.num, c.den));<br />		push(s, Frac(a.num, a.den));<br />		/* arithmetic */<br />	} else if((word[0] == '+' || scmp(word, "add")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) + (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '-' || scmp(word, "sub")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) - (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '*' || scmp(word, "mul")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(a.num * b.num, a.den * b.den));<br />	} else if((word[0] == '/' || scmp(word, "div")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac(a.num * b.den, a.den * b.num));<br />	} else if((word[0] == '%' || scmp(word, "mod")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) % (a.den * b.num), a.den * b.den));<br />		/* bitwise */<br />	} else if((word[0] == '&amp;' || scmp(word, "and")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) &amp; (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '|' || scmp(word, "or")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) | (a.den * b.num), a.den * b.den));<br />	} else if((word[0] == '^' || scmp(word, "xor")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) ^ (a.den * b.num), a.den * b.den));<br />	} else if((scmp(word, "&lt;&lt;") || scmp(word, "rol")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) &lt;&lt; (a.den * b.num), a.den * b.den));<br />	} else if((scmp(word, "&gt;&gt;") || scmp(word, "ror")) &amp;&amp; trypop(s, 2)) {<br />		Fraction b = pop(s);<br />		Fraction a = pop(s);<br />		push(s, Frac((a.num * b.den) &gt;&gt; (a.den * b.num), a.den * b.den));<br />		/* special */<br />	} else if((scmp(word, "inv")) &amp;&amp; trypop(s, 1)) {<br />		Fraction f = pop(s);<br />		push(s, Frac(f.den, f.num));<br />	} else if(scmp(word, "vid") &amp;&amp; trypop(s, 1) &amp;&amp; trypush(s, 1)) {<br />		Fraction f = pop(s);<br />		push(s, Frac(f.num, 1));<br />		push(s, Frac(f.den, 1));<br />	} else if(word)<br />		return error("Command", word);<br />	return 1;<br />}<br /><br />static int<br />run(Stack *s)<br />{<br />	int len = 0;<br />	char c, word[64];<br />	while((c = fgetc(stdin)) != EOF) {<br />		if(c == ' ' || c == '\n') {<br />			word[len] = '\0';<br />			len = 0;<br />			interpret(s, word);<br />		} else<br />			word[len++] = c;<br />	}<br />	return 0;<br />}<br /><br />int<br />main(void)<br />{<br />	Stack s;<br />	s.pointer = s.data;<br />	while(run(&amp;s))<br />		;<br />	print(&amp;s);<br />	return 0;<br />}<br /></pre><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/text/1th.c.txt' target='_blank'>edit</a> to <a href='../src/inc/text/1th.c.txt'>1th.c.txt</a>(264 lines)</figcaption></figure><h2><a href='shim.html'>shim</a></h2><h4>Shim is a utility that converts bytes into midi messages.</h4><p>Shim is designed to recieve the 3 bytes of <a href='midi.html'>midi</a>(channel, note, velocity) and pass it to a selected midi device. It is powered by <a href='http://portmedia.sourceforge.net/portmidi/' target='_blank'>Portmidi</a>.</p><p>This tiny script the ideal companion application to <a href='varvara.html'>Varvara</a> for sending midi from <a href='orca.html'>Orca</a>.</p><h3>Usage</h3><pre>uxnemu orca.rom | shim</pre><h2><a href='seconth.html'>seconth</a></h2><h4>Seconth, or 2th, is a plain-text calendar with events.</h4><p>Second is a calendar utility created to overlay events on pages of the gregorian calendar, written in <a href='ansi_c.html'>ANSI C</a>.</p><h3>Event Format</h3><p>The events are stored in text files in the format: </p><pre>20201126 Sailing trip to Port Townsend</pre><h3>2th.c</h3><figure><pre>#include &lt;stdio.h&gt;<br />#include &lt;time.h&gt;<br /><br />/* <br />Copyright (c) 2020 Devine Lu Linvega<br /><br />Permission to use, copy, modify, and distribute this software for any<br />purpose with or without fee is hereby granted, provided that the above<br />copyright notice and this permission notice appear in all copies.<br /><br />THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES<br />WITH REGARD TO THIS SOFTWARE.<br />*/<br /><br />#define EVENTMAX 1024<br /><br />typedef struct Event {<br />	int y, m, d;<br />	char name[256];<br />} Event;<br /><br />typedef struct Calendar {<br />	int y, m, d, len;<br />	Event events[EVENTMAX];<br />} Calendar;<br /><br />char *months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};<br /><br />int<br />slen(char *s)<br />{<br />	int i = 0;<br />	while(s[++i])<br />		;<br />	return i;<br />}<br /><br />int<br />sint(char *s, int len)<br />{<br />	int n = 0, i = 0;<br />	while(i &lt; len &amp;&amp; s[i] &amp;&amp; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') {<br />		n = n * 10 + (s[i] - '0');<br />		i++;<br />	}<br />	return n;<br />}<br /><br />char *<br />scpy(char *src, char *dst, int len)<br />{<br />	int i = 0;<br />	while(i &lt; len - 1 &amp;&amp; (dst[i] = src[i]))<br />		i++;<br />	return dst;<br />}<br /><br />int<br />daysmonth(int y, int m)<br />{<br />	if(m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12)<br />		return 31;<br />	else if((m == 2) &amp;&amp; ((y % 400 == 0) || (y % 4 == 0 &amp;&amp; y % 100 != 0)))<br />		return 29;<br />	else if(m == 2)<br />		return 28;<br />	else<br />		return 30;<br />	return 0;<br />}<br /><br />int<br />dayweek(int y, int m, int d)<br />{<br />	int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};<br />	y -= m &lt; 3;<br />	return (y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7;<br />}<br /><br />void<br />setevent(Calendar *c, int y, int m, int d, char *name)<br />{<br />	Event *e = &amp;c-&gt;events[c-&gt;len++];<br />	scpy(name, e-&gt;name, slen(name));<br />	e-&gt;y = y;<br />	e-&gt;m = m;<br />	e-&gt;d = d;<br />}<br /><br />Event *<br />getevent(Calendar *c, int y, int m, int d)<br />{<br />	int i;<br />	for(i = 0; i &lt; c-&gt;len; i++) {<br />		Event *e = &amp;c-&gt;events[i];<br />		if(e-&gt;y == y &amp;&amp; e-&gt;m == m &amp;&amp; e-&gt;d == d)<br />			return e;<br />	}<br />	return NULL;<br />}<br /><br />void<br />printevents(Calendar *c, int y, int m, int d)<br />{<br />	int i, l = c-&gt;m;<br />	for(i = 0; i &lt; 90; i++) {<br />		Event *e = getevent(c, y, m, d);<br />		if(e) {<br />			if(l != m)<br />				puts("");<br />			if(i == 0)<br />				printf(" Today        ");<br />			else if(i == 1)<br />				printf(" Tomorrow     ");<br />			else<br />				printf(" In %02d days   ", i);<br />			puts(e-&gt;name);<br />			l = m;<br />		}<br />		d++;<br />		if(d &gt; daysmonth(y, m)) {<br />			d = 1;<br />			m++;<br />			if(m &gt; 12) {<br />				m = 1;<br />				y++;<br />			}<br />		}<br />	}<br />	puts("");<br />}<br /><br />void<br />printcalendar(Calendar *c)<br />{<br />	int i;<br />	int dw = dayweek(c-&gt;y, c-&gt;m, 1);<br />	int dm = daysmonth(c-&gt;y, c-&gt;m);<br />	printf(" %s %d\n", months[c-&gt;m - 1], c-&gt;y);<br />	printf(" Su  Mo  Tu  We  Th  Fr  Sa ");<br />	for(i = 0; i &lt;= 35; i++) {<br />		int d = i - dw + 1;<br />		if(i % 7 == 0)<br />			puts("");<br />		if(d == c-&gt;d)<br />			printf("&lt;%2d&gt;", d);<br />		else if(getevent(c, c-&gt;y, c-&gt;m, d))<br />			printf("[%2d]", d);<br />		else if(d &gt; 0 &amp;&amp; d &lt;= dm)<br />			printf(" %2d ", d);<br />		else<br />			printf("    ");<br />	}<br />	puts("");<br />}<br /><br />void<br />loadevents(FILE *f, Calendar *c)<br />{<br />	char line[256];<br />	if(!f)<br />		return;<br />	while(fgets(line, 256, f)) {<br />		if(line[0] == ';' || slen(line) &lt; 12)<br />			continue;<br />		if(c-&gt;len &gt;= EVENTMAX)<br />			break;<br />		setevent(c,<br />			line[0] == '*' ? c-&gt;y : sint(line, 4),<br />			line[5] == '*' ? c-&gt;m : sint(line + 4, 2),<br />			line[7] == '*' ? c-&gt;d : sint(line + 6, 2),<br />			line + 9);<br />	}<br />	fclose(f);<br />}<br /><br />void<br />init(Calendar *cal)<br />{<br />	time_t t;<br />	struct tm *local;<br />	time(&amp;t);<br />	local = localtime(&amp;t);<br />	cal-&gt;y = local-&gt;tm_year + 1900;<br />	cal-&gt;m = local-&gt;tm_mon + 1;<br />	cal-&gt;d = local-&gt;tm_mday;<br />}<br /><br />int<br />main(int argc, char *argv[])<br />{<br />	Calendar cal;<br />	init(&amp;cal);<br />	loadevents(fopen(argc &gt; 1 ? argv[1] : "calendar", "r"), &amp;cal);<br />	printcalendar(&amp;cal);<br />	printevents(&amp;cal, cal.y, cal.m, cal.d);<br />	return 0;<br />}<br /></pre><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/text/2th.c.txt' target='_blank'>edit</a> to <a href='../src/inc/text/2th.c.txt'>2th.c.txt</a>(198 lines)</figcaption></figure><h2><a href='stopwatch.html'>stopwatch</a></h2><h4>Stopwatch is a terminal utility countdown.</h4><p>Why the heck did I even have to write this in the first place.</p><pre>cc sw.c -std=c89 -Os -DNDEBUG -g0 -s -Wall -o sw</pre><figure><pre>#include &lt;stdio.h&gt;<br />#include &lt;unistd.h&gt;<br /><br />int<br />main()<br />{<br />	int h = -1, m = -1, s = -1, t = 0;<br />	printf("Timeout(HH:MM:SS) | ");<br />	if(!scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s)) {<br />		printf("Invalid timestamp\n");<br />		return 0;<br />	}<br />	if(m == -1 &amp;&amp; s == -1) {<br />		s = h;<br />		h = 0;<br />		m = 0;<br />	} else if(s == -1) {<br />		s = m;<br />		m = h;<br />		h = 0;<br />	}<br />	t = h * 3600 + m * 60 + s;<br />	putchar('\n');<br />	do {<br />		if(t &gt; 3600)<br />			printf("\033[A%02d:%02d:%02d\n",<br />				t / 3600,<br />				(t / 60) % 60,<br />				t % 60);<br />		else if(t &gt; 60)<br />			printf("\033[A%02d:%02d\n",<br />				(t / 60) % 60,<br />				t % 60);<br />		else<br />			printf("\033[A%02d\n",<br />				t);<br />		sleep(1);<br />		t--;<br />	} while(t &gt;= 0);<br />	printf("Ended.\n");<br />	return 0;<br />}<br /></pre><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/text/stopwatch.c.txt' target='_blank'>edit</a> to <a href='../src/inc/text/stopwatch.c.txt'>stopwatch.c.txt</a>(42 lines)</figcaption></figure></main><footer><a href='https://creativecommons.org/licenses/by-nc-sa/4.0'><img src='../media/icon/cc.svg' width='30'/></a><a href='http://webring.xxiivv.com/'><img src='../media/icon/webring.svg' width='30'/></a><a href='https://merveilles.town/@neauoire'><img src='../media/icon/merveilles.svg' width='30'/></a><a href='https://github.com/neauoire'><img src='../media/icon/github.png' alt='github' width='30'/></a><span><a href='devine_lu_linvega.html'>Devine Lu Linvega</a> &copy; 2021 &mdash; <a href='about.html'>BY-NC-SA 4.0</a></span></footer></body></html>