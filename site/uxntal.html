<!DOCTYPE html><html><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width, inital-scale=1"/><link href="../links/main.css" type="text/css" rel="stylesheet"/><link href="../media/services/icon.png" type="image/png" rel="shortcut icon"/>
<title>XXIIVV &mdash; uxntal</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>
<nav><ul><li><a href="oisc.html">oisc</a></li><li><a href="brainfuck.html">brainfuck</a></li><li><a href="gyo.html">gyo</a></li><li><a href="chip8.html">chip8</a></li><li><a href="turquoise.html">turquoise</a></li><li><a href="uxn.html" class="parent">uxn</a></li><li><a href="orca.html">orca</a></li></ul><ul><li><a href="uxntal.html" class="self">uxntal</a></li><li><a href="varvara.html">varvara</a></li></ul><ul><li><a href="uxntal_opcodes.html">uxntal opcodes</a></li><li><a href="uxntal_modes.html">uxntal modes</a></li><li><a href="uxntal_stacks.html">uxntal stacks</a></li><li><a href="uxntal_memory.html">uxntal memory</a></li><li><a href="uxntal_devices.html">uxntal devices</a></li><li><a href="uxntal_syntax.html">uxntal syntax</a></li><li><a href="uxntal_logic.html">uxntal logic</a></li><li><a href="uxntal_errors.html">uxntal errors</a></li></ul></nav><main><figure><img alt="Rostiger's Uxn Zine" src="../media/diary/804.jpg"/><figcaption>Rostiger's Uxn Zine</figcaption></figure><h2>Tal is the programming language for the Uxn virtual machine.</h2>

<img src="../media/generic/uxn.beet.png" style="float:right; margin-left: 15px;" width="150">

<p>Uxn programs are written in a unique flavor of assembly designed especially for this virtual machine. TAL files are human-readable source files, ROM files are uxn-compatible binary program files; an application that transforms a source file into a program is called an <i>Assembler</i>.</p>

<ul>
	<li><a href='https://compudanzas.net/uxn_tutorial.html' target='_blank'>Introduction to Uxntal</a>, online book</li>
</ul>
<h2>Uxntal Opcodes</h2>

<p>Uxn has 64kb of memory, 16 devices, 254 bytes of working stack, 254 bytes of return stack, 32 opcodes and each opcode has 3 possible modes.</p>

<pre>
<b>LIT</b> a b c M[PC+1] <b>EQU</b> a b?c             <b>LDZ</b> a b M[c8]      <b>ADD</b> a b+c
<b>INC</b> a b c+1       <b>NEQ</b> a b!c             <b>STZ</b> a {M[c8]=b}    <b>SUB</b> a b-c
<b>POP</b> a b           <b>GTH</b> a b&gt;c             <b>LDR</b> a b M[PC+c8]   <b>MUL</b> a b*c
<b>NIP</b> a c           <b>LTH</b> a b&lt;c             <b>STR</b> a {M[PC+c8]=b} <b>DIV</b> a b/c
<b>SWP</b> a c b         <b>JMP</b> a b {PC+=c}       <b>LDA</b> a b M[c16]     <b>AND</b> a b&c
<b>ROT</b> b c a         <b>JCN</b> a {(b8)PC+=c}     <b>STA</b> a {M[c16]=b}   <b>ORA</b> a b|c
<b>DUP</b> a b c c       <b>JSR</b> a b {rs.PC PC+=c} <b>DEI</b> a b D[c8]      <b>EOR</b> a b^c
<b>OVR</b> a b c b       <b>STH</b> a b {rs.c}        <b>DEO</b> a {D[c8]=b}    <b>SFT</b> a b&gt;&gt;c8l&lt;&lt;c8h

<b>--2</b> a16 b16+c16   <b>--r</b> a b c {rs.b+rs.c} <b>--k</b> a b c b+c
</pre>

<p>The list above show the opcodes and their effect on a given stack <b>a b c</b>, where <b>PC</b>: Program Counter, <b>M</b>: Memory, <b>D</b>: Devices, and <b>rs</b>: Return Stack. To learn more about each opcode, see the <a href='uxntal_reference.html'>Uxntal Reference</a>.</p>

<h2>Uxntal Modes</h2>

<p>Each opcode has 3 possible modes, which can combined:</p>

<ul>
	<li>The <b>short mode</b> operates on shorts instead of bytes.</li>
	<li>The <b>return mode</b> operate on the return stack.</li>
	<li>The <b>keep mode</b> operates without consuming items.</li>
</ul>

<p>By default, operators consume bytes from the working stack, notice how in the following example only the last two bytes <code>#45</code> and <code>#67</code> are added, even if there are two shorts on the stack.</p>
<pre>#1234 #4567 ADD<span style='float:right'>12 34 ac</span></pre>

<p>The <b>short mode</b> consumes two bytes from the stack. In the case of jump opcodes, the short-mode operation jumps to an absolute address in memory. For the memory accessing opcodes, the short mode operation indicates the size of the data to read and write.</p>
<pre>#1234 #4567 ADD2 <span style='float:right'>57 9b</span></pre>

<p>The <b>keep mode</b> does not consume items from the stack, and pushes the result on top. The following example adds the two shorts together, but does not consume them. Under the hood, the keep mode keeps a temporary stack pointer that is decrement on <code>POP</code>.</p>
<pre>#1234 #4567 ADD2k <span style='float:right'>12 34 45 67 57 9b</pre>

<p>The <b>return mode</b> makes it possible for any opcode to operate on the return-stack directly. For that reason, there is no dedicated return opcode. For example, the <code class='op'>JSR</code> opcode pushes the program's address onto the return stack before jumping, to return to that address, the <code class='op'>JMP2r</code> opcode is used, where instead of using the address on the working-stack, it takes its address from the return-stack.</p>
<pre>#1234 LIT2r 4567 STHr <span style='float:right'>57 9b</span></pre>

<h2>Uxntal stacks</h2>

<p>In stack-machine programming, there are no precedence rules, the calculations are merely performed in the sequence in which they are presented. The order in which elements come off a stack is known as last in, first out. In the stack items <i>a b c</i>, the <i>c</i> item was the last to be added, and will be the first to be removed.</p>

<pre>
#12 <span style='float:right'>12</span>
#3456 <span style='float:right'>34 56</span>
LIT 12 STH <span style='float:right; color:red'>12</span>
LIT2r 1234 <span style='float:right; color:red'>12 34</span>
LIT2r 1234 STHr <span style='float:right;color:red'> 12</span> <span style='float:right'>34</span>
</pre>

<p>All programming in Unxtal is done by manipulating the working stack(wst), and return stack(rst). Each stack contains 256 bytes, the items in the stacks are presented below in hexadecimal.</p>

<table border='1'>
	<tr><th>POP</th><td>a b</td><td>Discard top item.</td></tr>
	<tr><th>NIP</th><td>a c</td><td>Discard second item.</td></tr>
	<tr><th>SWP</th><td>a c b</td><td>Move second item to top.</td></tr>
	<tr><th>ROT</th><td>b c a</td><td>Move third item to top.</td></tr>
	<tr><th>DUP</th><td>a b c c</td><td>Copy top item.</td></tr>
	<tr><th>OVR</th><td>a b c b</td><td>Copy second item to top.</td></tr>
</table>

<p>Shorts are made of two bytes, each byte can be manipulated individually.</p>

<pre>
#1234 POP <span style='float:right'>12</span>
#1234 NIP <span style='float:right'>34</span>
#12 DUP <span style='float:right'>12 12</span>
#1234 OVR <span style='float:right'>12 34 12</span>
#abcd #5678 SWP2 <span style='float:right'>56 78 ab cd</span>
#1234 #5678 SWP <span style='float:right'>12 34 78 56</span>
</pre>

<p>A literal is a byte or short value to be pushed on the stacks, it is prefixed with the <a href='#lit'>LIT opcode</a>. Hexadecimal values are always lowercase, either a byte or a short in length.</p>

<table border="1">
	<tr><td></td><th>Byte</th><th>Char</th><th>Relative</th><th>ZeroPage</th><th>Absolute*</th><th>Short*</th></tr>
	<tr><td><i>Literal</i></td><td><code>#ab</code></td><td></td><td><code>,label</code></td><td><code>.label</code></td><td><code>;label</code></td><td><code>#abcd</code></td></tr>
	<tr><td><i>Plain</i></td><td><code>ab</code></td><td><code>"Q</code></td><td><code>_label</code></td><td><code>-label</code></td><td><code>=label</code></td><td><code>abcd</code></td></tr>
</table>

<p>Give a special attention to the <code>add2</code> hexadecimal value which, equals 44498 in decimal, and will not be interpreted as an opcode.</p>

<h2>Uxntal Memory</h2>

<p>There are 64kb of addressable memory. Roms are loaded at 0x0100. Once in memory, a Uxn program can write over itself, store values among its running code, it is not uncommon for a uxntal program to directly modify the value of a literal in memory, or to change an opcode for another instead of branching. When writing or reading a short in memory, the position is that of the high byte.</p>

<pre>
#12 #0200 STA <span style='float:right'>0x0200=12</span>
#3456 #0400 STA2 <span style='float:right'>0x0400=34, 0x0401=56</span>
#0400 LDA2 <span style='float:right'>34 56</span>
</pre>

<p>The zero-page is the memory located between 0x0000 and 0x0100, its purpose is to store variables that will be accessed often. It is sligthly faster to read and write from the zero-page using the LDZ and STZ opcodes as they use only a single byte instead of a short. This memory space cannot be pre-filled in the rom prior to assembly.</p>

<pre>
#1234 #80 STZ2 <span style='float:right'>0x0080=12, 0x0081=34</span>
#80 LDZ2 <span style='float:right'>12 34</span>
</pre>

<p>A nearby address can also be addressed relative to the current position of the Program Counter, with the relative addressing opcodes.</p>

<pre>
#1234 ADD ,&later STR BRK &later $1
</pre>

<h2>Uxntal Devices</h2>

<p>Each device has 16 ports, each port handles a specific I/O message. Ports are mapped to the devices memory page, which is located outside of the main addressable memory.</p>

<p><b>Uxn is non-interruptible</b>, vectors are locations in programs that are evaluated when certain events occur. A vector is evaluated until a BRK opcode is encountered, no new events will be triggered while a vector is evaluated. Only one vector is executed at a time. The content of the stacks are preserved between vectors.</p>

<p>In other words, the <code>Mouse/vector</code> port holds an address to a part of the program that will be evaluated when the cursor is moved, or a button state has changed. </p>


<h2>Uxntal syntax</h2>

<p>Uppercased opcodes are reserved words, hexadecimal values are always lowercased. Comments are within parentheses, curlies are used in the definition of macros, and the square brackets are ignored.</p>

<pre class='example'>
|0100 <span class='comment'>( init )</span>

	<b>;hello-word</b>

	<span class='label'>&while</span>
		<span class='comment'>( send )</span> LDAk #18 DEO
		<span class='comment'>( loop )</span> INC2 LDAk <b>,&while</b> JCN
	POP2

BRK

<span class='label'>@hello-word</span> "Hello 20 "World! 00
</pre>

<style>
.example span.label { font-weight: bold;background: #fff;color: #000;padding: 2px 4px; }
.example span.comment { color:#aaa }
</style>

<p>The first token in this program is the padding operation <kbd>|0100</kbd>, which is where the first page of memory ends, and where all Uxn programs begin. Our program begins by pushing the absolute address of the label <kbd>@hello-world</kbd> to the stack, which is defined later, and points to a series of <a href='ascii.html'>ASCII</a> characters. This absolute address is made of two bytes.</p>

<img src="../media/generic/uxn.team.png" style="margin:0 auto 30px" width="250">

<p>Next, we create the child label <kbd>&while</kbd> to this position of the program so we can return to it later. Both <kbd>&while</kbd> and <kbd>@while</kbd> are ways to define labels, but using <code>&while</code> will automatically prefix a new <code>&label</code> with the name of the last <code>@label</code>, in this example <code>program/while</code>. </p>

<table border="1">
	<tr><th colspan="4">Padding</th><th colspan="4">Literals</th></tr>
	<tr><td><code>|</code></td><td>absolute</td><td><code>$</code></td><td>relative</td><td><code>#</code></td><td colspan="3">literal hex</td></tr>
	<tr><th colspan="4">Labels</th><th colspan="4">Ascii</th></tr>
	<tr><td><code>@</code></td><td>parent</td><td><code>&</code></td><td>child</td><td><code>&quot;</code></td><td colspan="3">raw ascii</td></tr>
	<tr><th colspan="4">Addressing</th><th colspan="4">Pre-processor</th></tr>
	<tr><td><code>,</code></td><td>literal relative</td><td><code>_</code></td><td>raw relative</td><td><code>%</code></td><td>macro-define</td><td><code>~</code></td><td>include</td></tr>
	<tr><td><code>.</code></td><td>literal zero-page</td><td><code>-</code></td><td>raw zero-page</td></tr>
	<tr><td><code>;</code></td><td>literal absolute</td><td><code>=</code></td><td>raw absolute</td></tr>
</table>

<p>Next, the <kbd>LDAk</kbd> opcode takes two bytes at the top of the stack to form an absolute address, and puts the value in memory found at that address to the top of the stack, in this case, the ASCII value of the letter H. That value is sent to Console/write(port #18) which prints that character to the terminal.</p>

<p>We increment the absolute address found on top of the stack with <kbd>INC2</kbd>, because the address is made of two bytes. We load the incremented value, the <kbd>JCN</kbd> opcode will jump to the position of label <kbd>&while</kbd> for as long as the item on the stack not zero. We complete the program with <kbd>POP2</kbd> to remove the address on the stack, to keep the stack clean at the end of the program.</p>

<h2>Uxntal Logic</h2>

<p>Comparison operators will always push 01 for true, 00 for false. This is also true for operators in <i>short mode</i>.</p>

<pre>
#12 #34 EQU <span style='float:right'>00</span>
#1234 NEQ <span style='float:right'>01</span>
#1234 #7856 LTH2 <span style='float:right'>01</span>
</pre>

<p>A non-null byte can be fed to the conditional jump opcode to create a <i>for</i> loop:</p>

<pre>
#10 #00
@loop
	( body, will be ran 16 times )
	INC GTHk ,loop JCN
POP2
</pre>

<p>It can also be used to create something like a <i>while</i> loop:</p>

<pre>
;word
@while
	LDAk #18 DEO
	INC2 LDAk ,while JCN
POP2
@word "vermillion $1
</pre>

<h2 id='errors'>Errors</h2>

<p>Errors occur when a program behaves unexpectedly. Errors are normally handled by the emulator, but programs can set a system vector to evaluate when errors occurs. There are three known error types, and each one has an error code:</p>

<ul>
	<li><code>01</code> <b>Underflow</b>: Occurs when an opcode is trying to pop an item from an empty stack.</li>
	<li><code>02</code> <b>Overflow</b>: Occurs when an opcode is trying to push an item to a full stack.</li>
	<li><code>03</code> <b>Division By Zero</b>: Occurs when the DIV opcode is done on a value of zero.</li>
</ul>

<ul></ul><p><b>Incoming</b>: <a href="left.html">left</a> <a href="dexe.html">dexe</a> <a href="noodle.html">noodle</a> <a href="theme.html">theme</a> <a href="gly_format.html">gly format</a> <a href="ufx_format.html">ufx format</a> <a href="bifurcan.html">bifurcan</a> <a href="catclock.html">catclock</a> <a href="yufo.html">yufo</a> <a href="proquints.html">proquints</a> <a href="brainfuck.html">brainfuck</a> <a href="uxn.html" class="parent">uxn</a> <a href="uxntal_alphabet.html">uxntal alphabet</a> <a href="bicycle.html">bicycle</a> <a href="drifblim.html">drifblim</a> <a href="beetbug.html">beetbug</a> <a href="about.html">about</a> <a href="computer.html">computer</a> <a href="oscean.html">oscean</a> <a href="arvelie.html">arvelie</a> </p></main>
<footer><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a> <a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a> <a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a> <a href="ethics.html"><img src="../media/icon/dreipfeile.svg" alt="NoNazis!"/></a> <a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a> <span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2022 &mdash; <a href="about.html">BY-NC-SA 4.0</a></span></footer>
</body></html>